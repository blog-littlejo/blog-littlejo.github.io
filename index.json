[{"content":"","date":"15 septembre 2025","externalUrl":null,"permalink":"/en/series/getting-started-with-ebpf-uprobes-in-aya/","section":"Series","summary":"","title":"Getting Started With EBPF UProbes in Aya","type":"series"},{"content":"","date":"15 septembre 2025","externalUrl":null,"permalink":"/series/apprenons-uprobe-avec-ebpf-et-aya/","section":"Series","summary":"","title":"Apprenons UProbe Avec EBPF Et Aya","type":"series"},{"content":"","date":"15 septembre 2025","externalUrl":null,"permalink":"/tags/aya/","section":"Tags","summary":"","title":"Aya","type":"tags"},{"content":"","date":"15 septembre 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"15 septembre 2025","externalUrl":null,"permalink":"/categories/development/","section":"Categories","summary":"","title":"Development","type":"categories"},{"content":"","date":"15 septembre 2025","externalUrl":null,"permalink":"/tags/ebpf/","section":"Tags","summary":"","title":"EBPF","type":"tags"},{"content":"","date":"15 septembre 2025","externalUrl":null,"permalink":"/ebpf-another-type/","section":"Ebpf-Another-Types","summary":"","title":"Ebpf-Another-Types","type":"ebpf-another-type"},{"content":"","date":"15 septembre 2025","externalUrl":null,"permalink":"/tags/go/","section":"Tags","summary":"","title":"Go","type":"tags"},{"content":"","date":"15 septembre 2025","externalUrl":null,"permalink":"/","section":"Le blog de Little Jo","summary":"","title":"Le blog de Little Jo","type":"page"},{"content":"Nous avons vu ce qu\u0026rsquo;√©tait un programme de type uProbe dans la premi√®re partie : un moyen de sonder les fonctions de vos programmes.\nDans cette partie, nous allons d\u0026rsquo;abord cr√©er un programme tr√®s simple en Go et nous allons le faire r√©agir avec deux programmes eBPF :\nLe premier de type uProbe Le deuxi√®me de type uRetProbe \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rJe suppose que vous √™tes d√©j√† dans un environnement pour d√©velopper avec Aya et que vous avez install√© le compilateur go et bpftrace. Si ce n\u0026rsquo;est pas le cas, vous pouvez utiliser le lab Killercoda :\nCr√©ons un programme pour tester les uProbes # Un code tout simple # Pour changer du Rust, nous allons cr√©er un petit programme en Go :\n// hello.go package main import \u0026#34;fmt\u0026#34; func hello() int { fmt.Println(\u0026#34;Hello, world!\u0026#34;) return 3 } func main() { ret := hello() fmt.Println(\u0026#34;Returned:\u0026#34;, ret) } \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rVous pouvez tester pour un autre programme compil√© comme C/C++ ou Rust si vous pr√©f√©rez. Comment va-t-on activer des uProbes ? # Le but de l\u0026rsquo;article est d\u0026rsquo;activer :\nun programme eBPF de type uProbe √† chaque fois que l\u0026rsquo;on rentre dans la fonction hello() : un programme eBPF de type uRetProbe √† chaque fois que l\u0026rsquo;on sort de la fonction hello() : Maintenant qu\u0026rsquo;on a vu les tenants et les aboutissants de l\u0026rsquo;article, passons √† la compilation du programme.\nCompilons le programme # Pour le compiler, il suffit de taper :\ngo build -gcflags=\u0026#34;all=-N -l\u0026#34; -o hello hello.go On peut remarquer qu\u0026rsquo;on a ajout√© une option -gcflags=\u0026quot;all=-N -l\u0026quot;. Normalement, on n\u0026rsquo;a pas besoin d\u0026rsquo;utiliser cette option pour compiler un programme Go :\ngo build -o hello hello.go Cela fonctionne √©galement. Mais alors pourquoi utiliser cette option ?\n-gcflags veut dire go compiler flags ce sont des options pass√©es au compilateur Go. all permet de dire que les options s\u0026rsquo;appliquent √† tous les packages compil√©s. Les options sp√©cifi√©es au compilateur Go sont :\n-N : par d√©faut, le compilateur modifie (mangle) le nom de la fonction. Cette option permet de d√©sactiver cette modification. En anglais, to mangle peut se traduire par modifier, mutiler ou m√™me d√©figurer. En informatique, name mangling se traduit par d√©coration de nom. On a compl√®tement gomm√© le c√¥t√© p√©joratif du terme ! -l : par d√©faut, le compilateur inline les fonctions c\u0026rsquo;est √† dire qu\u0026rsquo;elle int√®gre directement le contenu de la fonction dans le code appelant permettant ainsi aux programmes d\u0026rsquo;√™tre plus performants. Cette option permet de d√©sactiver cet inline. Ainsi ces options vont nous permettre de garder les fonctions et de les rendre lisible, ce qui va nous simplifier pour trouver le point d\u0026rsquo;attache pour notre programme eBPF.\nComment trouver le point d\u0026rsquo;attache ? # Maintenant qu\u0026rsquo;on a cr√©√© et compil√© le petit programme, il faut trouver comment d√©clencher le programme eBPF de type uProbe ou uRetProbe. Lorsqu\u0026rsquo;on utilise cargo generate pour le repo aya, il faut r√©pondre √† deux questions : o√π se trouve le nom du binaire et quelle fonction observ√©e. Voyons cela en d√©tail.\nNom du binaire # ü§∑ Target to attach the (u|uret)probe? (e.g libc): Pour garantir la portabilit√© du programme eBPF, il faut r√©pondre le chemin absolu du binaire. Par exemple je l\u0026rsquo;ai cr√©√© l√† : /home/cloud_user/hello.\nNom de la fonction # Une fois que tu as r√©pondu √† la premi√®re question, il reste une seconde question :\nü§∑ Function name to attach the (u|uret)probe? (e.g getaddrinfo): Que faut-il r√©pondre ? On serait tent√© de r√©pondre hello vu qu\u0026rsquo;on a mis l\u0026rsquo;option -N qui d√©sactive la d√©coration de nom lors de la compilation.\nMais c\u0026rsquo;est un peu plus compliqu√©. Le compilateur Go modifie tout de m√™me l√©g√®rement le nom de la fonction pendant l\u0026rsquo;√©tape de compilation.\nNous l\u0026rsquo;avons vu dans le pr√©c√©dent √©pisode pour trouver toutes les fonctions d\u0026rsquo;un binaire, il suffit d\u0026rsquo;utiliser bpftrace :\nbpftrace -l \u0026#39;uprobe:/home/cloud_user/hello:*\u0026#39; l\u0026rsquo;option -l permet de lister toutes les probes disponibles uprobe : le type de programme eBPF /home/cloud_user/hello : l\u0026rsquo;emplacement du binaire * : le joker (0 ou plusieurs caract√®res) Le format d\u0026rsquo;affichage est alors :\nuprobe:/home/cloud_user/hello:[fonction1] uprobe:/home/cloud_user/hello:[fonction2] uprobe:/home/cloud_user/hello:[fonction3] uprobe:/home/cloud_user/hello:[fonction4] etc C\u0026rsquo;est pas de bol : le nom de la fonction est le m√™me que le nom de mon fichier\u0026hellip; On ne peut pas faire de | grep hello. Comment s\u0026rsquo;en sortir ? avec awk, cut ou pire une regex ? Faisons simple :\nbpftrace -l \u0026#39;uprobe:/home/cloud_user/hello:*hello*\u0026#39; Et √ßa va vous r√©pondre :\nuprobe:/home/cloud_user/hello:main.hello Ainsi le nom r√©el de la fonction est main.hello\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Si vous ne pouvez pas installer bpftrace, vous pouvez utiliser la commande nm. Elle permet de voir tous les symboles qui sont pr√©sents dans un fichier binaire. Maintenant qu\u0026rsquo;on a la r√©ponse aux deux questions, nous pouvons cr√©er nos programmes eBPF.\nCommen√ßons par le programme de type uProbe.\nCr√©ons un programme eBPF de type uProbe # Testons avec bpftrace # Avant de foncer t√™te baiss√©e sur un programme Aya, v√©rifions que √ßa fonctionne bien avec bpftrace, le programme qui cr√©e en une ligne de commande un programme eBPF. √áa tombe bien : on a d√©j√† trouv√© le d√©but dans la section pr√©c√©dente :\nuprobe:/home/cloud_user/hello:main.hello Il reste plus qu\u0026rsquo;√† compl√©ter par un hello world :\nsudo bpftrace -e \\ \u0026#39;uprobe:/home/cloud_user/hello:main.hello { printf(\u0026#34;Hello go\\n\u0026#34;); }\u0026#39; Historiquement, il fallait avoir les droits root pour installer un programme eBPF dans le noyau. Avec un Linux moderne, un utilisateur non root peut installer un programme eBPF avec juste quelques capacit√©s suppl√©mentaires comme CAP_BPF. Cependant bpftrace ne g√®re pas cela : il faut √™tre en root. Dans un autre terminal, lan√ßons alors le programme hello (sans les droits root) :\n./hello Sur le terminal o√π est lanc√© bpftrace, vous voyez Hello go √† chaque fois que vous lancez le programme hello.\nVerifions qu\u0026rsquo;on peut cr√©er un programme similaire avec Aya.\nG√©n√©ration du programme Aya # D√©finissons d√©j√† les diff√©rentes r√©ponses pour le point d\u0026rsquo;attache dans des variables, pour mon cas √ßa sera :\ntarget=/home/cloud_user/hello fn_name=main.hello Lan√ßons maintenant la commande pour g√©n√©rer le programme Aya :\ncargo generate --name test-uprobe \\ -d program_type=uprobe \\ -d uprobe_target=$target \\ -d uprobe_fn_name=$fn_name \\ https://github.com/aya-rs/aya-template Sans les options qu\u0026rsquo;on lui a indiqu√©, cargo generate fonctionnerait en mode interactif : on devrait r√©pondre √† des questions.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rPour trouver le nom des arguments (uprobe_target et uprobe_fn_name), vous pouvez regarder le fichier test.sh dans le repo aya-template. Vous aurez la sortie suivante :\nüîß program_type: \u0026#34;uprobe\u0026#34; (value from CLI) üîß uprobe_target: \u0026#34;/home/cloud_user/hello\u0026#34; (value from CLI) üîß uprobe_fn_name: \u0026#34;main.hello\u0026#34; (value from CLI) üîß Destination: /home/cloud_user/test-uprobe ... üîß project-name: test-uprobe ... üîß Generating template ... [ 1/23] Done: .gitignore [ 2/23] Done: Cargo.toml [ 3/23] Done: LICENSE-APACHE [ 4/23] Done: LICENSE-GPL2 [ 5/23] Done: LICENSE-MIT [ 6/23] Done: README.md [ 7/23] Ignored: pre-script.rhai [ 8/23] Done: rustfmt.toml [ 9/23] Done: test-uprobe/Cargo.toml [10/23] Done: test-uprobe/build.rs [11/23] Done: test-uprobe/src/main.rs [12/23] Done: test-uprobe/src [13/23] Done: test-uprobe [14/23] Done: test-uprobe-common/Cargo.toml [15/23] Done: test-uprobe-common/src/lib.rs [16/23] Done: test-uprobe-common/src [17/23] Done: test-uprobe-common [18/23] Done: test-uprobe-ebpf/Cargo.toml [19/23] Done: test-uprobe-ebpf/build.rs [20/23] Done: test-uprobe-ebpf/src/lib.rs [21/23] Done: test-uprobe-ebpf/src/main.rs [22/23] Done: test-uprobe-ebpf/src [23/23] Done: test-uprobe-ebpf üîß Initializing a fresh Git repository ‚ú® Done! New project created /home/cloud_user/test-uprobe Compilation et installation dans le noyau # Maintenant qu\u0026rsquo;on a g√©n√©r√© le programme, il faut compiler le programme et l\u0026rsquo;installer dans le noyau linux :\ncd test-uprobe/ RUST_LOG=info cargo run Pour simplifier, j\u0026rsquo;ai fait la compilation et l\u0026rsquo;installation du programme eBPF en root. Cela va prendre un peu de temps la premi√®re fois :\nUpdating crates.io index Locking 103 packages to latest compatible versions Adding which v6.0.3 (available: v8.0.0) Downloaded anstyle v1.0.11 Downloaded cfg-if v1.0.1 Downloaded anyhow v1.0.98 Downloaded either v1.15.0 Downloaded cargo_metadata v0.19.2 Downloaded version_check v0.9.5 Downloaded which v6.0.3 Downloaded socket2 v0.6.0 Downloaded mio v1.0.4 [...] warning: test-uprobe@0.1.0: Finished `release` profile [optimized] target(s) in 19.59s Finished `dev` profile [unoptimized + debuginfo] target(s) in 50.16s Running `/root/build-cache/debug/test-uprobe` Waiting for Ctrl-C... Testons maintenant # Laisser le programme Aya tourn√© et sur un autre terminal, lancer le programme que vous voulez examiner. Pour mon cas :\n./hello Sur le terminal o√π on a lanc√© la commande cargo run, Vous devriez voir la sortie suivante √† chaque fois que vous lancez le programme :\n[INFO test_uprobe] function main.hello called by /home/cloud_user/hello Vous voyez que la difficult√© est la m√™me qu\u0026rsquo;avec bpftrace mais que le temps de compilation est beaucoup plus long.\nCr√©ons un programme eBPF de type uRetProbe # Nous avons vu un exemple de programme eBPF de type uProbe o√π on n\u0026rsquo;avait pas √† modifier le code g√©n√©r√©. Nous allons maintenant complexifier l√©g√®rement avec un programme eBPF de type uRetProbe et nous allons r√©cup√©rer la valeur de retour.\nTestons avec bpftrace # Le code bpftrace est alors l√©g√®rement modifi√© :\nsudo bpftrace -e \\ \u0026#39;uretprobe:/home/cloud_user/hello:main.hello { printf(\u0026#34;retval=%d\\n\u0026#34;, retval); }\u0026#39; uprobe est donc remplac√© par uretprobe on a rajout√© la variable de retour : retval Lancer le programme hello dans un autre terminal et vous verrez dans le terminal bpftrace :\nretval=3 Regardons comment produire le programme √©quivalent en Aya.\nG√©n√©ration du programme Aya # La g√©n√©ration du code se fait de mani√®re similaire qu\u0026rsquo;avec une uProbe :\ntarget=/home/cloud_user/hello fn_name=main.hello cargo generate --name test-uretprobe \\ -d program_type=uretprobe \\ -d uprobe_target=$target \\ -d uprobe_fn_name=$fn_name \\ https://github.com/aya-rs/aya-template Compilation et installation # De la m√™me mani√®re on va compiler et installer le programme eBPF :\ncd test-uretprobe/ RUST_LOG=info cargo run √Ä la sortie de chaque fonction hello(), le programme eBPF affiche bien :\n[INFO test_uretprobe] function main.hello called by /home/cloud_user/hello Jusqu\u0026rsquo;√† pr√©sent, nous avons fait un peu pr√®s la m√™me chose que pour l\u0026rsquo;uProbe. Regardons maintenant comment r√©cup√©rer la valeur de retour 3.\nModification du code # Il faut modifier le fichier test-uretprobe-ebpf/src/main.rs : le code de l\u0026rsquo;espace noyau. En particulier ce bout de code :\nfn try_test_uretprobe(ctx: RetProbeContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { info!(\u0026amp;ctx, \u0026#34;function main.hello called by /home/cloud_user/hello\u0026#34;); Ok(0) } Il faut voir comment utiliser la structure RetProbeContext pour afficher le code retour.\nRegardons la documentation :\nIl faut donc utiliser la m√©thode ret(). On va rajouter un truc comme √ßa :\nlet retval: u32 = ctx.ret().ok_or(1u32)?; \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Si la fonction n\u0026rsquo;a pas de retour on affiche 1u32 (entier non sign√© de 32 bits) car la signature de la fonction est Result\u0026lt;u32, u32\u0026gt;. Il faut √©galement modifier la macro Aya info! pour afficher cette valeur.\nCe qui donne au final :\nfn try_test_uretprobe(ctx: RetProbeContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let retval: u32 = ctx.ret().ok_or(1u32)?; info!(\u0026amp;ctx, \u0026#34;retval={}\u0026#34;, retval); Ok(0) } Testons maintenant # Appliquons les modifications :\nRUST_LOG=info cargo run Lan√ßons la commande hello dans un autre terminal :\n./hello Et du c√¥t√© du programme Aya, on a l\u0026rsquo;affichage suivant :\n[INFO test_uretprobe] retval=3 Ce qui est coh√©rent avec ce qu\u0026rsquo;on avait trouv√© avec bpftrace.\nCet √©pisode est maintenant termin√© ! Nous avons vu les bases pour faire r√©agir un programme eBPF de type uProbe et uRetProbe lors du lancement d\u0026rsquo;un programme Go.\nCependant, nous n\u0026rsquo;avons pas encore explor√© comment r√©cup√©rer les arguments d\u0026rsquo;une fonction.\n√áa tombe bien ! Dans le prochain √©pisode, nous allons sonder une biblioth√®que bien connue en r√©cup√©rant les arguments de fonction et en les traitant !\n","date":"15 septembre 2025","externalUrl":null,"permalink":"/ebpf-another-type/uprobe/example-1/","section":"Ebpf-Another-Types","summary":"Observons un petit programme Go avec des programmes eBPF de type u‚Ä¢Ret‚Ä¢Probe et avec Aya","title":"Observons une fonction simple de ton programme avec des uProbes","type":"ebpf-another-type"},{"content":"","date":"15 septembre 2025","externalUrl":null,"permalink":"/tags/rust/","section":"Tags","summary":"","title":"Rust","type":"tags"},{"content":"","date":"15 septembre 2025","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"15 septembre 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"15 septembre 2025","externalUrl":null,"permalink":"/categories/tutorial/","section":"Categories","summary":"","title":"Tutorial","type":"categories"},{"content":"","date":"15 septembre 2025","externalUrl":null,"permalink":"/tags/uprobe/","section":"Tags","summary":"","title":"Uprobe","type":"tags"},{"content":"","date":"15 septembre 2025","externalUrl":null,"permalink":"/tags/uretprobe/","section":"Tags","summary":"","title":"Uretprobe","type":"tags"},{"content":"Nous avons vu ce qu\u0026rsquo;√©tait un programme de type uProbe dans la premi√®re partie : √ßa peut √™tre un moyen de sonder une biblioth√®que.\nNous allons v√©rifier cela avec un programme Aya qui va r√©cup√©rer les diff√©rents arguments de la fonction execve() de la Libc.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rJe suppose que vous √™tes d√©j√† dans un environnement pour d√©velopper avec Aya et que vous avez install√© bpftrace. Si ce n\u0026rsquo;est pas le cas, vous pouvez utiliser le lab Killercoda :\nQue va-t-on vraiment faire ? # Libc # Contrairement √† la pr√©c√©dente partie o√π on a attach√© notre programme eBPF √† un programme, l√† nous l\u0026rsquo;attachons √† une biblioth√®que partag√©e.\nLa libc est la biblioth√®que standard du C. Donc √† chaque fois qu\u0026rsquo;un programme en C (ou en C++) est ex√©cut√©, potentiellement, un programme eBPF pourra √™tre lanc√©.\n\u003c?xml version=\"1.0\" encoding=\"iso-8859-1\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rJe parle de libc tout au long du chapitre. Pour √™tre plus pr√©cis, il faudrait parler de la glibc (GNU C Library) l\u0026rsquo;impl√©mentation la plus r√©pandue dans les distributions GNU/Linux (Comme Debian ou Red Hat). Mais il y a d\u0026rsquo;autres impl√©mentations comme musl (notamment pour Alpine Linux) ou ulibc qui sont plus l√©g√®res et adapt√©es pour les syst√®mes embarqu√©s. La fonction execve # execve est un appel syst√®me (un syscall) du noyau Linux. Mais c\u0026rsquo;est aussi le nom d\u0026rsquo;une fonction de la libc qui fait appel √† ce m√™me syscall (un wrapper). Ainsi, √† chaque fois que la fonction execve() de la libc sera appel√©, notre programme eBPF de type uProbe sera lanc√©.\nLes arguments de la fonction execve # Nous devons √©galement r√©cup√©rer les diff√©rents arguments de la fonction execve().\nPour trouver ses arguments, on peut √©videmment regarder dans le code source de la libc. Mais il y a plus simple :\nman execve La partie qui nous int√©resse est la suivante :\nint execve(const char *pathname, char *const _Nullable argv[], char *const _Nullable envp[]); On voit que la fonction a trois arguments :\npathname: le nom de la commande avec le chemin complet (exemple /bin/bash). Il est de type const char * (√©quivalent en Rust √† *const u8). argv: un tableau d\u0026rsquo;arguments de la commande. Il est de type char *const _Nullable[] (√©quivalent en Rust √† *const *const u8) argv[0] : le nom de la commande argv[1] : la premi√®re option etc. envp : un tableau de variables d\u0026rsquo;environnement de la commande. Il est de type char *const _Nullable[] (√©quivalent en Rust √† *const *const u8). \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e _Nullable indique simplement que la valeur peut √™tre NULL. Comment d√©clencher le programme eBPF ? # Prenons un exemple simple. Si tu lances une commande dans un terminal par exemple ls, que va-t-il se passer ?\nGr√¢ce √† la variable d\u0026rsquo;environnement PATH, le shell (par exemple le bash) va trouver le bon chemin pour trouver o√π se trouve le binaire ls : /usr/bin/ls Pour ex√©cuter le binaire, le shell va alors appeler la fonction execve() de la libc : execve(\u0026#34;/usr/bin/ls\u0026#34;, [\u0026#34;ls\u0026#34;], [\u0026#34;PATH=/bin:/usr/bin\u0026#34;, ...]) Le programme eBPF sera enfin d√©clench√©. Voici un petit r√©sum√© de tout cela :\nIl y a √©videmment d\u0026rsquo;autres programmes que des shells qui appellent la fonction execve() de la libc comme systemd pour le d√©marrage des diff√©rents programmes d\u0026rsquo;un syst√®me Linux.\nAinsi nous allons cr√©er un programme tr√®s proche de celui qu\u0026rsquo;on avait cr√©√© avec le Tracepoint sys_enter_execve lors des articles d\u0026rsquo;initiation √† eBPF mais celui-ci sera attach√© au niveau utilisateur √† la fonction execve() de la libc.\nG√©n√©rons un programme Aya de type uProbe # Nous avons donc d√©j√† les r√©ponses aux deux questions :\nü§∑ Target to attach the (u|uret)probe? (e.g libc): ü§∑ Function name to attach the (u|uret)probe? (e.g getaddrinfo): Voyons comment cr√©er un programme eBPF Hello world pour ce point d\u0026rsquo;attache.\nTestons avec bpftrace # V√©rifions d\u0026rsquo;abord que √ßa fonctionne avec la ligne de commande bpftrace :\nsudo bpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;Hello execve\\n\u0026#34;); }\u0026#39; uprobe : le type de programme eBPF libc : le nom de la biblioth√®que execve : la fonction √† debugger { printf(\u0026quot;Hello execve\\n\u0026quot;); } : le code bpftrace √Ä chaque fois qu\u0026rsquo;on lance une commande sur un autre terminal, on voit bien Hello execve.\nMaintenant faisons-le avec Aya.\nG√©n√©ration et compilation du programme Aya # La commande cargo generate suivante permet ainsi de g√©nerer le programme eBPF :\ncargo generate --name test-uprobe-2 \\ -d program_type=uprobe \\ -d uprobe_target=libc \\ -d uprobe_fn_name=execve \\ https://github.com/aya-rs/aya-template \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rPour trouver le nom des arguments (uprobe_target et uprobe_fn_name), vous pouvez regarder le fichier test.sh dans le repo aya-template. Maintenant compilons le et installons le dans le noyau Linux :\ncd test-uprobe-2/ RUST_LOG=info cargo run Test du programme # Sur un autre terminal, lancer un programme quelconque :\nls Sur le terminal cargo run vous verrez :\n[INFO test_uprobe] function execve called by libc Dans la partie pr√©c√©dente, on √©tait rest√© √† ce point concernant les uProbes. Regardons comment r√©cup√©rer les diff√©rentes arguments de la fonction execve(). Commen√ßons par le premier : le nom du binaire.\nR√©cup√©rons le nom du binaire # Testons avec bpftrace # Avant de modifier le code Aya, regardons comment on fait avec bpftrace. C\u0026rsquo;est un poil plus compliqu√© qu\u0026rsquo;un simple hello world.\nPour r√©cup√©rer le premier argument, on utilise arg0 :\nsudo bpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;%d\\n\u0026#34;, arg0); }\u0026#39; On r√©cup√®re l\u0026rsquo;adresse o√π se trouve le premi√®re argument. Comment le \u0026ldquo;convertir\u0026rdquo; en cha√Æne de caract√®res ? Il suffit d\u0026rsquo;utiliser la fonction str() :\nsudo bpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;%s\\n\u0026#34;, str(arg0)); }\u0026#39; Maintenant qu\u0026rsquo;on a le brouillon avec bpftrace, regardons comment l\u0026rsquo;impl√©menter avec Aya.\nModifions le code Aya # \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e Suite de l‚Äôarticle r√©serv√©e aux membres premium ‚ú®\nL‚Äôarticle complet est accessible uniquement aux membres premium.\nDevenir membre premium, c‚Äôest simple : il suffit de faire un petit don üíñ\nEn √©change, vous aurez pendant 1 an (offre early bird) :\nAcc√®s √† tous les articles complets d√®s leur publication Lecture anticip√©e avant la mise en ligne publique Participation au soutien de ce blog ind√©pendant Acc√®s exclusif √† mes photos de vacances √† Duba√Ø Votre don permet de :\nMe rendre moins d√©pendant des grandes plateformes M‚Äôencourager √† cr√©er plus de contenu technique Lever le paywall plus rapidement pour tous üëâ Devenir membre premium d√®s maintenant\n","date":"15 septembre 2025","externalUrl":null,"permalink":"/ebpf-another-type/uprobe/example-2-tr/","section":"Ebpf-Another-Types","summary":"Sondons la fonction \u003ccode\u003eexecve\u003c/code\u003e dans la libc avec un programme eBPF de type uProve et avec Aya","title":"Sondons une biblioth√®que avec une uProbe","type":"ebpf-another-type"},{"content":"","date":"15 septembre 2025","externalUrl":null,"permalink":"/categories/teaser/","section":"Categories","summary":"","title":"Teaser","type":"categories"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/en/series/lets-learn-another-ebpf-program/","section":"Series","summary":"","title":"Let‚Äôs Learn Another EBPF Program","type":"series"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/series/apprenons-un-autre-programme-ebpf/","section":"Series","summary":"","title":"Apprenons Un Autre Programme EBPF","type":"series"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/tags/bpftrace/","section":"Tags","summary":"","title":"Bpftrace","type":"tags"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/categories/introduction/","section":"Categories","summary":"","title":"Introduction","type":"categories"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/tags/kprobe/","section":"Tags","summary":"","title":"Kprobe","type":"tags"},{"content":"Je d√©bute la programmation en eBPF avec Aya. L‚Äôid√©e de cette s√©rie d‚Äôarticles est d\u0026rsquo;apprendre un nouveau type de programme eBPF et de l\u0026rsquo;exp√©rimenter avec le framework Rust Aya.\nAujourd\u0026rsquo;hui, nous allons nous plonger dans les uProbes et les uRetProbes : des programmes eBPF qui sondent les fonctions de l\u0026rsquo;espace utilisateur sans laisser de trace.\nVous allez voir que cela peut √™tre tr√®s int√©ressant pour du profilage, du debug ou m√™me de la r√©tro-ing√©nierie.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Si tu ne connais pas eBPF, je te conseille de lire les deux premi√®res parties de ma s√©rie S‚Äôinitier √† eBPF avec Aya. Cela couvre les bases et t\u0026rsquo;aidera pour la suite de l\u0026rsquo;article. Qu\u0026rsquo;est-ce qu\u0026rsquo;une u‚Ä¢Ret‚Ä¢Probe ? # En anglais, une probe peut se traduire par une sonde pour examiner ou explorer quelque chose. En eBPF, il y en a de plusieurs types : kProbe, kRetProbe, uProbe, uRetProbe et USDT.\nkProbe : la sonde pour le kernel # Si tu consultes la documentation d\u0026rsquo;eBPF, il n\u0026rsquo;y a pas de section consacr√©e aux programmes de type uProbe ou uRetProbe. Mais il y en a une d√©di√©e √† la kProbe :\nLa kProbe a pour but d\u0026rsquo;observer des fonctions du kernel Linux. Elle peut √™tre consid√©r√©e comme la probe parente. Toutes les autres probes sont en fait le m√™me type de programme BPF_PROG_TYPE_KPROBE mais c\u0026rsquo;est juste le point d\u0026rsquo;attache qui va d√©terminer comment le programme est ex√©cut√©.\nkRetProbe : retour sur la sonde kernel # La kRetProbe est simplement d√©di√©e √† l\u0026rsquo;observation du retour des fonctions du kernel Linux. Cette sonde permet ainsi de v√©rifier si l\u0026rsquo;appel de la fonction s\u0026rsquo;est bien termin√©.\nNous avons vu bri√®vement kProbe et kRetProbe qui pourraient faire l\u0026rsquo;objet d\u0026rsquo;autres articles. Parlons maintenant des probes qui nous int√©ressent aujourd\u0026rsquo;hui : uProbe et uRetProbe.\nuProbe : la sonde pour les utilisateurs # Contrairement aux kProbes qui sont d√©di√©es √† observer les fonctions du kernel Linux, les uProbes sont d√©di√©es aux fonctions de l\u0026rsquo;espace utilisateur : User-space Probes. Par exemple, on pourrait s\u0026rsquo;en servir pour compter le nombre d\u0026rsquo;appels aux fonctions malloc et free dans un programme C.\nuProbe permet √©galement de r√©cup√©rer le contenu des arguments de la fonction observ√©e. Ainsi on pourrait regarder la quantit√© de m√©moire allou√©e √† chaque malloc ou v√©rifier que free lib√®re r√©ellement des bons pointeurs.\nAinsi les uProbes pourrait s\u0026rsquo;int√©grer √† une CI pour automatiser des v√©rifications de s√©curit√©, faciliter le debogage ou aider au diagnostic m√©moire.\n\u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rFree Medical icons\r√áa peut para√Ætre paradoxal de vouloir tracer un code utilisateur depuis l\u0026rsquo;espace noyau. Cependant cela a le m√©rite d\u0026rsquo;√™tre non intrusif car il n\u0026rsquo;y a pas besoin de modifier le programme. uRetProbe : retour sur la sonde utilisateur # De la m√™me mani√®re que la kRetProbe, uRetProbe a pour but d\u0026rsquo;√©tudier le retour de la fonction cible de l\u0026rsquo;espace utilisateur : User-space Return Probe. On peut donc d√©couvrir la valeur que retourne la fonction. Cela permet ainsi de debugger ou d\u0026rsquo;observer le comportement final de la fonction.\nMais il y a un autre int√©r√™t : en combinant les temps de l\u0026rsquo;uProbe et de l\u0026rsquo;uRetProbe, on peut r√©cup√©rer la dur√©e que met une fonction √† s\u0026rsquo;ex√©cuter assez facilement. Il est ainsi possible de profiler une fonction de son programme.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e file_type_sql On pourrait, par exemple, l\u0026rsquo;utiliser pour des requ√™tes SQL o√π on identifierait les requ√™tes les plus longues. Les uRetProbe et uProbes peuvent √™tre utilis√©es pour d√©bugger et comprendre un programme dont tu n\u0026rsquo;as pas le code source. √áa peut donc √™tre un bel outil de r√©tro-ing√©nierie (reverse engineering).\nPar contre, elles sont limit√©es aux programmes dont le langage est compil√© : C/C++, Rust, Go, etc. Si on a un programme d√©velopp√© avec un autre langage, USDT pourrait vous convenir. Parlons-en.\nUSDT : le tracepoint de l\u0026rsquo;espace utilisateur # USDT veut dire User Statically-Defined Tracing. Comme son nom l\u0026rsquo;indique, elle est √©galement d√©di√©e aux programmes de l\u0026rsquo;espace utilisateur mais il faut rajouter dans le code des sondes usdt pour les utiliser. USDT est, en fait, d√©riv√©e de l\u0026rsquo;uProbe.\nPar contre, elle est beaucoup plus pr√©cise que l\u0026rsquo;uProbe. En effet, la sonde uProbe est cantonn√©e au d√©but de fonction alors que la sonde usdt peut √™tre mise √† n\u0026rsquo;importe quel endroit dans le code.\nVoici un exemple de code Python :\ndef benchmark_module(): loop = 0 for _ in range(100000): pyusdt.trace_start_loop(loop) calculate_pi(1000) pyusdt.trace_stop_loop(loop) loop += 1 Avec ce code, on peut avoir la dur√©e pour calculer les 1000 d√©cimales de œÄ.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rAu moment de l\u0026rsquo;√©criture, le framework Aya ne g√®re pas encore les programmes de type USDT. Nous allons maintenant nous consacrer pour la suite de l\u0026rsquo;article aux uProbes et uRetProbes. Parlons d\u0026rsquo;abord un peu de leur histoire.\nOrigin story # uTrace l\u0026rsquo;anc√™tre # Vouloir tracer des fonctions de l\u0026rsquo;espace utilisateur depuis le noyau Linux ne date pas de l\u0026rsquo;introduction d\u0026rsquo;eBPF. Par exemple, une (premi√®re ?) tentative est apparue en 2007 avec les uTraces :\nMais elles n\u0026rsquo;ont jamais √©t√© incluses dans le code principal du fait d\u0026rsquo;opposition de certains mainteneurs.\nHabemus uProbe # Il a fallu attendre 2012 pour que le consensus finisse par arriver et les uProbes ont √©t√© introduites lors de la version 3.5 du noyau Linux :\n√Ä l\u0026rsquo;√©poque, les uProbes √©taient limit√©s par rapport √† celles qu\u0026rsquo;on conna√Æt aujourd\u0026rsquo;hui.\nAinsi, elles ont ensuite √©t√© am√©lior√©es avec la version 3.14 (sortie en 2014, la m√™me ann√©e que l\u0026rsquo;introduction d\u0026rsquo;eBPF) :\nCe patch a permis de r√©cup√©rer un nombre plus important de donn√©es comme la valeur de retour d\u0026rsquo;une fonction.\nLes uProbes sont alors devenues pleinement exploitables alors qu\u0026rsquo;eBPF n\u0026rsquo;√©tait pas encore sortie. Voyons quand son int√©gration s\u0026rsquo;est faite.\nuProbe avec eBPF # D\u0026rsquo;apr√®s la documentation d\u0026rsquo;eBPF, kProbe est apparue en 2015 dans la version 4.1 du noyau Linux. C\u0026rsquo;est Alexei Starovoitov, l\u0026rsquo;un des cr√©ateurs d\u0026rsquo;eBPF, qui l\u0026rsquo;a initi√© :\nComme une uProbe est une kProbe avec un point d\u0026rsquo;attache diff√©rent, on pouvait commencer √† d√©velopper des uProbes avec eBPF √† partir du 2 avril 2015.\nCependant, il fallait encore attendre que les frameworks eBPF de l\u0026rsquo;√©poque puissent le g√©rer.\nAinsi on pouvait d√©j√† l\u0026rsquo;utiliser en 2016 avec BCC comme l\u0026rsquo;atteste le tutoriel de Brendan Gregg :\nOn peut voir √©galement son issue sur GitHub datant d\u0026rsquo;octobre 2015 : Pour finir, voici une petite frise chronologique de l\u0026rsquo;histoire des uProbes :\n\u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rFree Medical icons\rLes uRetProbes ont √©t√© introduites de fa√ßon conjointe aux uProbes. Maintenant qu\u0026rsquo;uProbe a plus de 10 ans d\u0026rsquo;existence, on peut se poser une question bien l√©gitime : est-elle encore utilis√©e et par quel projet ?\nQuels projets utilisent u‚Ä¢Ret‚Ä¢Probe ? # Pour d√©fier le lieu commun : \u0026ldquo;eBPF c\u0026rsquo;est utilis√© que par 3 grosses bo√Ætes\u0026rdquo;, j\u0026rsquo;ai fait une petite recherche des outils qui utilisaient r√©ellement les uProbes et que donc vous l\u0026rsquo;utilisiez peut-√™tre sans le savoir\u0026hellip;\nPixie : where is my mind? # Le projet Pixie utilise uProbe notamment pour tracer les connexions TLS :\nD\u0026rsquo;ailleurs il y a un article de Douglas Mendez pour capturer le traffic HTTPs avec Aya.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rLe Projet Pixie est un outil d\u0026rsquo;observabilit√© pour les applications qui sont sur Kubernetes. Parca : l\u0026rsquo;hiver vient ! # Le projet Parca utilise √©galement les uProbes.\nLe projet Parca est un outil de profilage \u0026ldquo;en continue\u0026rdquo; c\u0026rsquo;est √† dire de fa√ßon syst√©matique. Inspektor Gadget : h√© l√†, qui va l√†? # Le projet Inspektor Gadget a cr√©√© des outils bas√©s sur des uProbes et sur des sondes USDT depuis 2024 :\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rLe projet Inspektor Gadget fournit des outils (des gadgets) et un framework pour collecter les donn√©es et l\u0026rsquo;inspection du syst√®me sur Kubernetes. Bonus Track # Pour finir la pr√©sentation, je vous partage quelques liens bien sympathiques que j\u0026rsquo;ai trouv√© lors de mes recherches sur les uProbes :\nUtilisation des uprobes sans eBPF par Brendan Gregg en 2015 : L\u0026rsquo;excellent article de blog de Julia Evans sur tous les syst√®mes de tracing sous Linux. Vous pouvez √©galement lire son zine : Si les uProbes ne vous conviennent pas, peut-√™tre que les bpftimes d\u0026rsquo;Eunomia peuvent vous int√©resser : Maintenant qu\u0026rsquo;on a pr√©sent√© uProbe et uRetProbe, voyons comment d√©buter son d√©veloppement avec Aya.\nComment d√©buter son programme Aya ? # Quand on d√©marre le d√©veloppement d\u0026rsquo;un nouveau programme eBPF, la premi√®re difficult√© est de r√©ussir √† le d√©marrer. Pour cela, il a besoin d\u0026rsquo;un √©v√©nement d√©clencheur (event-driven). Dans cet √©pisode, cet √©v√©nement sera donc le passage d\u0026rsquo;une uProbe ou d\u0026rsquo;une uRetProbe dans le noyau Linux.\nAya nous facilite la t√¢che. Quand on lance la commande :\ncargo generate https://github.com/aya-rs/aya-template Tu devras r√©pondre √† deux questions importantes qui permettront de d√©finir cet √©v√©nement :\nü§∑ Target to attach the (u|uret)probe? (e.g libc): ü§∑ Function name to attach the (u|uret)probe? (e.g getaddrinfo): Voyons comment y r√©pondre.\nCible pour attacher l\u0026rsquo;u‚Ä¢Ret‚Ä¢Probe # La premi√®re question demande le nom d\u0026rsquo;une biblioth√®que (comme la libc) ou d\u0026rsquo;un binaire. La question aurait pu √™tre pos√©e autrement : quel fichier tu veux debugger ou tracer ?\nIl faut voir √ßa comme un filtre :\nSi tu choisis libc, le programme eBPF ne pourra d√©marrer que si un programme de la libc est ex√©cut√© Si tu choisis un binaire, il ne pourra d√©marrer que si le binaire est ex√©cut√©. Mais cela n\u0026rsquo;est pas suffisant pour d√©marrer le programme eBPF. Il faut √™tre plus pr√©cis : donner le nom d\u0026rsquo;une fonction.\nNom de la fonction pour attacher l\u0026rsquo;u‚Ä¢Ret‚Ä¢Probe # La seconde question demande ainsi la fonction du binaire ou de la biblioth√®que que tu veux d√©bugger.\nPar exemple :\nsi tu choisis le nom d\u0026rsquo;une fonction d\u0026rsquo;un programme C, le programme eBPF sera lanc√© √† chaque fois qu\u0026rsquo;il passe par cette fonction. si tu choisis une fonction de la libc, il ne sera lanc√© lorsqu\u0026rsquo;un programme appellera cette fonction de la libc. Si cela vous parait un peu trop th√©orique, nous allons finir le chapitre en parlant d\u0026rsquo;un outil bien sympathique qui va nous permettre d\u0026rsquo;illustrer cela.\nS\u0026rsquo;initier √† eBPF avec bpftrace # Le projet bpftrace permet de cr√©er rapidement la plupart des types de programme eBPF d√©di√©s aux tracings dont notamment uProbe et uRetProbe mais √©galement USDT, kProbe et kRetProbe (Voir la prise en charge ici).\nN\u0026rsquo;h√©sitez pas √† l\u0026rsquo;installer, il est probablement packag√© pour votre distribution Linux favorite.\nLe projet s\u0026rsquo;est fortement inspir√© de DTrace, un outil de tracing cr√©√© √† l\u0026rsquo;origine pour les unix comme Solaris, FreeBSD ou NetBSD au d√©but des ann√©es 2000. Tr√®ve de bavardage, prenons un exemple :\nsudo bpftrace -e \\ \u0026#39;uretprobe:/bin/bash:readline { printf(\u0026#34;%s\\n\u0026#34;, str(retval)); }\u0026#39; Que veut dire cela ?\nuretprobe : le type de programme eBPF /bin/bash : le binaire cible readline : le nom de la fonction { printf(\u0026quot;%s\\n\u0026quot;, str(retval)); } : le code du programme bpftrace (il affiche la valeur retour de la fonction) Cette commande cr√©e ainsi un programme eBPF de type uRetProbe avec comme point d\u0026rsquo;attache la fonction readline du binaire bash.\nSi vous avez vraiment lanc√© la commande, vous allez voir que cette cr√©ation est quasi imm√©diate ! V√©rifions qu\u0026rsquo;il fonctionne bien.\nD√©marrez un autre terminal et lancez quelques commandes de ton choix. Voici un exemple de ce que vous pourrez voir sur le terminal bpftrace :\nAttaching 1 probe... ls -lrth hello man woman Vous voyez toutes les commandes que vous avez tap√© sur le terminal !\nbpftrace peut ainsi √™tre un bon moyen de prototyper un programme uProbe ou uRetProbe avant de le g√©n√©rer avec Aya.\nEt si je veux observer une autre fonction que readline dans le programme bash ? Comment faire ? Le premier reflexe serait d\u0026rsquo;aller dans le code de bash et de chercher une autre fonction mais il y a plus simple et plus s√ªr :\nbpftrace -l \u0026#39;uretprobe:/bin/bash:*\u0026#39; Cette commande va te lister toutes les fonctions disponibles dans bash.\nOn peut ainsi voir qu\u0026rsquo;on peut d√©bugger 1670 fonctions dans bash : bpftrace -l 'uretprobe:/bin/bash:*' | wc -l Ainsi bpftrace va nous permetre pour la suite de v√©rifier la faisabilit√© avant de cr√©er le programme en Rust avec Aya.\nDans cet √©pisode, on a vu les bases des uProbes et des uRetProbes : √† quoi elles servent, leur histoire, qui les utilise et comment trouver le bon point d\u0026rsquo;accroche. Nous avons √©galement vu bpftrace, un outil qui permet de cr√©er des probes rapidement.\nNous allons maintenant passer √† la pratique dans l\u0026rsquo;√©pisode suivant : on va cr√©er un petit programme Go et on va le faire r√©agir avec des programmes eBPF de type uProbe et uRetProbe avec Aya.\n","date":"8 septembre 2025","externalUrl":null,"permalink":"/ebpf-another-type/uprobe/intro/","section":"Ebpf-Another-Types","summary":"D√©couverte des uProbes et uRetProbes eBPF avec Aya","title":"L‚Äôobservabilit√© pour tous les d√©veloppeurs avec les uProbes","type":"ebpf-another-type"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/tags/usdt/","section":"Tags","summary":"","title":"Usdt","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"}]