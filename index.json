[{"content":"","date":"24 novembre 2025","externalUrl":null,"permalink":"/ebpf-another-type/","section":"Ebpf-Another-Types","summary":"","title":"Ebpf-Another-Types","type":"ebpf-another-type"},{"content":"","date":"24 novembre 2025","externalUrl":null,"permalink":"/","section":"Le blog de Little Jo","summary":"","title":"Le blog de Little Jo","type":"page"},{"content":"","date":"24 novembre 2025","externalUrl":null,"permalink":"/series/apprenons-xdp-avec-aya/","section":"Series","summary":"","title":"Apprenons XDP Avec Aya","type":"series"},{"content":"Nous avons vu ce qu\u0026rsquo;était un programme XDP dans la première partie : cela peut être un moyen de limiter les attaques par déni de service distribué.\nDans cette partie, je vous propose de créer un programme XDP qui va limiter les attaques par SYN flood. On va faire cela avec le framework Rust Aya.\nSuivez le guide !\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rlab\rJe suppose que vous êtes déjà dans un environnement pour développer avec Aya. Si ce n\u0026rsquo;est pas le cas, vous pouvez utiliser le lab Killercoda :\nCréons un petit tcpdump avec XDP # Avant de faire cela, nous allons déjà expliquer comment on analyse un segment TCP avec XDP et ainsi récupérer les paquets SYN. Au fait, vous vous rappelez comment fonctionne TCP ?\nLes connexions TCP # TCP est l\u0026rsquo;acronyme de Transmission Control Protocol. C\u0026rsquo;est probablement le protocole réseau le plus utilisé par les protocoles applicatifs : HTTP, SSH, etc. Difficile de faire l\u0026rsquo;impasse pour des articles sur du réseau. Cependant c\u0026rsquo;est probablement le plus complexe si on compare à UDP ou à ICMP.\nAvant le téléchargement des données utiles, il y a une phase de connexion (3-way handshake) permettant d\u0026rsquo;établir un canal fiable.\nQu\u0026rsquo;est-ce que le SYN Flood ? # SYN est le premier segment TCP qui sert à initier une connexion TCP. Quand un serveur reçoit un SYN, il doit renvoyer un SYN-ACK pour accuser de réception. Une fois cela, le client doit confirmer par un ACK et le téléchargement des données peut enfin opérer.\nSupposons qu\u0026rsquo;un client envoie une connexion SYN mais ne répond jamais, que se passe-t-il ?\nLe serveur envoie un SYN-ACK en réponse puis réessaie 5 fois (valeur par défaut) Le serveur ferme enfin la connexion incomplète Supposons qu\u0026rsquo;un client innonde de plein de connexions SYN mais ne répond jamais, que se passe-t-il ?\nLe serveur garde alors plein de connexions \u0026ldquo;en attente\u0026rdquo; (dont certain probablement légitime) Le serveur continue de renvoyer les SYN-ACK jusqu\u0026rsquo;à saturer ses ressources mémoire C\u0026rsquo;est ça le principe d\u0026rsquo;une attaque SYN Flood.\nDans cet article, pour contrer cette attaque, on va compter le nombre de SYN par IP et s\u0026rsquo;il y en a trop on bloque temporairement ces segments pour cette IP.\nComment voir les détails des segments # Si ce n\u0026rsquo;est pas déjà fait, recréons l\u0026rsquo;environnement de développement\ngit clone https://github.com/littlejo/eunomia.dev cd eunomia.dev/docs/tutorials/42-xdp-loadbalancer/ ./setup.sh Démarrons un petit serveur web au niveau du namespace lb :\nip netns exec lb python3 -m http.server 8080 Sur l\u0026rsquo;interface veth6, nous verrons les paquets TCP qui sont envoyés par le client (comme SYN) ; Sur l\u0026rsquo;interface veth7, nous verrons les paquets TCP qui sont envoyés par le serveur (comme SYN-ACK). Nous devons donc installer le programme eBPF sur veth6.\nGénérons le programme Aya :\ncargo generate --name antiddos-xdp \\ -d program_type=xdp \\ -d default_iface=veth6 \\ https://github.com/aya-rs/aya-template cd antiddos-xdp En prévision, nous allons utiliser des crates supplémentaires :\naya-ebpf-bindings pour les bindings supplémentaires eBPF network-types pour les structures Rust des en-têtes de niveau 1, 2 et 3 blog-xdp, la crate de ce blog, pour ne pas copier/coller des fonctions helpers précédemment écrites On va donc modifier le fichier antiddos-xdp-ebpf/Cargo.toml et rajouter dans la section dependencies :\naya-ebpf-bindings = \u0026#34;0.1.1\u0026#34; network-types = \u0026#34;0.1.0\u0026#34; blog-xdp = { git = \u0026#34;https://github.com/littlejo/blog-xdp\u0026#34; } Vérifions que le programme généré fonctionne bien :\nOn va déjà construire le binaire :\ncargo build Puis on va installer dans le namespace cible où se trouve l\u0026rsquo;interface veth6 :\nip netns exec lb cargo run Comme le namespace n\u0026rsquo;a pas accès à Internet, il faut commencer par télécharger les crates pour les compiler au niveau du serveur puis installer le programme eBPF au niveau du namespace. On va maintenant récupérer uniquement les paquets TCP dans le programme eBPF. On va modifier le fichier antiddos-xdp-ebpf/src/main.rs. On se retrouve avec un code similaire au code de la partie précédente :\nuse network_types::{ eth::{EthHdr, EtherType}, ip::{Ipv4Hdr, IpProto}, tcp::TcpHdr, }; use blog_xdp::helper::ptr_at; fn try_antiddos_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0)?; match unsafe { (*ethhdr).ether_type() } { Ok(EtherType::Ipv4) =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } let ipv4hdr: *const Ipv4Hdr = ptr_at(\u0026amp;ctx, EthHdr::LEN)? ; match unsafe { (*ipv4hdr).proto } { IpProto::Tcp =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } let tcphdr: *const TcpHdr = ptr_at(\u0026amp;ctx, EthHdr::LEN + Ipv4Hdr::LEN)? ; let src_addr = unsafe { (*ipv4hdr).src_addr }; let dst_addr = unsafe { (*ipv4hdr).dst_addr }; info!(\u0026amp;ctx, \u0026#34;src:{:i} =\u0026gt; dst:{:i}\u0026#34;, src_addr, dst_addr); Ok(xdp_action::XDP_PASS) } On peut tester que ça fonctionne :\nip netns exec lb cargo run Verifions avec cette commande pour tester le programme XDP :\ncurl 10.0.0.10:8080 Au niveau de cargo, on voit alors plusieurs paquets passés :\n[INFO antiddos_xdp] src:10.0.0.1 =\u0026gt; dst:10.0.0.10 [INFO antiddos_xdp] src:10.0.0.1 =\u0026gt; dst:10.0.0.10 [INFO antiddos_xdp] src:10.0.0.1 =\u0026gt; dst:10.0.0.10 [INFO antiddos_xdp] src:10.0.0.1 =\u0026gt; dst:10.0.0.10 [INFO antiddos_xdp] src:10.0.0.1 =\u0026gt; dst:10.0.0.10 [INFO antiddos_xdp] src:10.0.0.1 =\u0026gt; dst:10.0.0.10 Ce que j\u0026rsquo;expliquais au début, quand on lance une connexion TCP, il n\u0026rsquo;y a pas qu\u0026rsquo;un paquet mais plusieurs paquets.\nOn voit seulement les paquets qui sont envoyés par le client (ceux en ingress).\nSi on veut voir les paquets qui sont envoyés par le serveur, il faut installer le programme sur l\u0026rsquo;interface veth7. C\u0026rsquo;est tout simple, en surchargeant la variable iface :\ncargo run -- --iface veth7 Pour afficher un peu plus de détails sur la nature des paquets, regardons maintenant l\u0026rsquo;en-tête du segment TCP :\nPour les puristes, le schéma est un peu simplifié.\nVoyons brièvement à quoi servent les principales données :\nSRC/DST PORT : les ports de TCP SEQUENCE/ACK NUMBER : pour le suivi des connexions BITFIELD : c\u0026rsquo;est là où on définit la nature du segment (SYN, ACK, etc) WINDOW : pour le contrôle de flux (utile pour les gros fichiers) CHECKSUM : pour l\u0026rsquo;intégrité du segment Comme pour UDP, on peut donc facilement récupérer les éléments en regardant la documentation de la crate network-types :\nPour récupérer la nature du segment, il y a même des fonctions pour nous aider :\nPour reproduire un petit tcpdump, ajoutons cela par exemple :\nlet src_port = u16::from_be_bytes(unsafe { (*tcphdr).source }); let dst_port = u16::from_be_bytes(unsafe { (*tcphdr).dest }); let seq = u32::from_be_bytes(unsafe {(*tcphdr).seq}); let ack_seq = u32::from_be_bytes(unsafe {(*tcphdr).ack_seq}); let syn = unsafe {(*tcphdr).syn()}; let ack = unsafe {(*tcphdr).ack()}; let psh = unsafe {(*tcphdr).psh()}; let fin = unsafe {(*tcphdr).fin()}; info!(\u0026amp;ctx, \u0026#34;seq: {}, ack_seq: {}, syn: {}, ack: {}, data: {}, fin: {}, src: {:i}:{}, dst: {:i}:{}\u0026#34;, seq, ack_seq, syn, ack, psh, fin, src_addr, src_port, dst_addr, dst_port); Installons ce programme sur les deux interfaces réseaux :\nip netns exec lb cargo run cargo run -- --iface veth7 Lançons une connexion :\ncurl 10.0.0.10:8080 Au niveau de veth6, on voit alors les détails des différents segments :\n[INFO antiddos_xdp] seq: 2481734691, ack_seq: 0, syn: 1, ack: 0, data: 0, fin: 0, src: 10.0.0.1:47632, dst: 10.0.0.10:8080 [INFO antiddos_xdp] seq: 2481734692, ack_seq: 161636304, syn: 0, ack: 1, data: 0, fin: 0, src: 10.0.0.1:47632, dst: 10.0.0.10:8080 [INFO antiddos_xdp] seq: 2481734692, ack_seq: 161636304, syn: 0, ack: 1, data: 1, fin: 0, src: 10.0.0.1:47632, dst: 10.0.0.10:8080 [INFO antiddos_xdp] seq: 2481734769, ack_seq: 161636460, syn: 0, ack: 1, data: 0, fin: 0, src: 10.0.0.1:47632, dst: 10.0.0.10:8080 [INFO antiddos_xdp] seq: 2481734769, ack_seq: 161637894, syn: 0, ack: 1, data: 0, fin: 0, src: 10.0.0.1:47632, dst: 10.0.0.10:8080 [INFO antiddos_xdp] seq: 2481734769, ack_seq: 161637894, syn: 0, ack: 1, data: 0, fin: 1, src: 10.0.0.1:47632, dst: 10.0.0.10:8080 [INFO antiddos_xdp] seq: 2481734770, ack_seq: 161637895, syn: 0, ack: 1, data: 0, fin: 0, src: 10.0.0.1:47632, dst: 10.0.0.10:8080 Au niveau de veth7 :\n[INFO antiddos_xdp] seq: 161636303, ack_seq: 2481734692, syn: 1, ack: 1, data: 0, fin: 0, src: 10.0.0.10:8080, dst: 10.0.0.1:47632, [INFO antiddos_xdp] seq: 161636304, ack_seq: 2481734769, syn: 0, ack: 1, data: 0, fin: 0, src: 10.0.0.10:8080, dst: 10.0.0.1:47632, [INFO antiddos_xdp] seq: 161636304, ack_seq: 2481734769, syn: 0, ack: 1, data: 1, fin: 0, src: 10.0.0.10:8080, dst: 10.0.0.1:47632, [INFO antiddos_xdp] seq: 161636460, ack_seq: 2481734769, syn: 0, ack: 1, data: 1, fin: 0, src: 10.0.0.10:8080, dst: 10.0.0.1:47632, [INFO antiddos_xdp] seq: 161637894, ack_seq: 2481734769, syn: 0, ack: 1, data: 0, fin: 1, src: 10.0.0.10:8080, dst: 10.0.0.1:47632, [INFO antiddos_xdp] seq: 161637895, ack_seq: 2481734770, syn: 0, ack: 1, data: 0, fin: 0, src: 10.0.0.10:8080, dst: 10.0.0.1:47632, Maintenant qu\u0026rsquo;on a vu tous les détails d\u0026rsquo;un segment TCP, on va maintenant s\u0026rsquo;occuper uniquement des segments de type SYN :\nmatch unsafe { (*tcphdr).syn() } { 1 =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } Si on a affaire à un SYN, on continue le traitement sinon on laisse passer le paquet.\nComme nous n\u0026rsquo;allons plus toucher à cette partie du code, nous allons créer une fonction :\n#[inline(always)] fn filter_tcp_syn_src(ctx: \u0026amp;XdpContext) -\u0026gt; Option\u0026lt;[u8; 4]\u0026gt; { let ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0).ok()?; match unsafe { (*ethhdr).ether_type() } { Ok(EtherType::Ipv4) =\u0026gt; {} _ =\u0026gt; return None, } let ipv4hdr: *const Ipv4Hdr = ptr_at(\u0026amp;ctx, EthHdr::LEN).ok()? ; match unsafe { (*ipv4hdr).proto } { IpProto::Tcp =\u0026gt; {} _ =\u0026gt; return None, } let tcphdr: *const TcpHdr = ptr_at(\u0026amp;ctx, EthHdr::LEN + Ipv4Hdr::LEN).ok()? ; match unsafe { (*tcphdr).syn() } { 1 =\u0026gt; {} _ =\u0026gt; return None, } let src_addr = unsafe { (*ipv4hdr).src_addr }; Some(src_addr) } fn try_antiddos_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let src_addr = match filter_tcp_syn_src(\u0026amp;ctx) { Some(x) =\u0026gt; x, None =\u0026gt; return Ok(xdp_action::XDP_PASS), }; info!(ctx, \u0026#34;{}\u0026#34;, src_addr); Ok(xdp_action::XDP_PASS) } Nous récupérons uniquement l\u0026rsquo;IP source de cette fonction pour potentiellement la bloquer.\nCela va nous permettre de nous concentrer sur le code pour empêcher l\u0026rsquo;attaque.\nEssayons d\u0026rsquo;atténuer les attaques SYN flood # Token Bucket # Il y a différentes options pour atténuer les DDoS. Je vais parler de l\u0026rsquo;algorithme du seau à jetons (token bucket). C\u0026rsquo;est pas mal utilisé comme algorithme (par exemple nginx avec limit_req).\nPour comprendre cet algorithme, nous allons faire une petite analogie :\nUn village impose des restrictions alimentaires :\nChaque foyer doit faire la queue pour obtenir des paniers Le village ne peut pas stocker plus de 5 paniers à la fois par foyer Si le foyer a récupéré tous ses paniers, il doit attendre le lendemain pour en avoir de nouveaux Si le foyer n\u0026rsquo;a pas pris de panier depuis quelques jours, il peut en récupérer plusieurs jusqu\u0026rsquo;à la limite de 5 paniers. Cette méthode va ainsi limiter les abus tout en étant flexible en permettant de ne pas faire la queue tous les jours.\nEn appliquant cette idée à la protection contre les attaques SYN Flood, on obtient :\nChaque IP doit faire la queue pour envoyer un paquet SYN à un serveur Le serveur ne peut pas recevoir plus de 5 paquets SYN à la fois par IP Si l\u0026rsquo;IP a déjà envoyé tous ses paquets SYN, elle sera bloquée temporairement et devra attendre un peu pour pouvoir envoyer de nouveaux Si l\u0026rsquo;IP n\u0026rsquo;a pas envoyé de paquets SYN depuis quelques temps, il peut en envoyer plusieurs jusqu\u0026rsquo;à la limite de 5. Bon c\u0026rsquo;est bien beau mais comment on fait concrètement en eBPF ?\nComment l\u0026rsquo;implémenter dans eBPF ? # Nous allons créer une map eBPF: BUCKET {ip =\u0026gt; TOKEN}. Si l\u0026rsquo;IP n\u0026rsquo;est pas dans BUCKET, il va être initialisé au nombre maximal (qui est à 5 dans l\u0026rsquo;analogie). À chaque fois qu\u0026rsquo;on reçoit un SYN, on diminue de 1. Si le bucket est vide, on arrête le paquet.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Pour ceux qui ne savent pas ce qu\u0026rsquo;est une map eBPF : en simplifiant, on peut la voir comme une variable globale persistante à un programme eBPF. À chaque fois que le programme XDP est lancé, il peut accéder et modifier cette variable.\nPour en savoir plus, je te conseille de lire la troisième partie de ma série S’initier à eBPF avec Aya.\nL\u0026rsquo;algorithme n\u0026rsquo;est pas complet car toutes les IPs finiraient par être bloquée, il faut rajouter des jetons. La solution intuitive serait de créer un programme utilisateur qui remplit la map eBPF de 1 régulièrement. Mais c\u0026rsquo;est un peu risqué si par exemple le programme plante.\nUne astuce serait de créer une autre map eBPF : LAST_TS : {ip =\u0026gt; ts}. Il contient le moment où on a remplit le BUCKET pour la dernière fois. Ainsi dans le programme eBPF, on peut calculer la durée qui s\u0026rsquo;est écoulée et rattraper éventuellement le retard en rajoutant les jetons. Supposons qu\u0026rsquo;on est censé donner un jeton par seconde, si le dernier remplissage date d\u0026rsquo;il y a 5 secondes, on rajoute 5 jetons dans la limite de la taille du seau.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Pour des questions de performance, on devrait probablement créer une unique map {ip =\u0026gt; {num =\u0026gt; token, last_fill =\u0026gt; ts }. Mais je trouve cela plus simple en séparant en deux maps. Repassons au code # Décrémentation de la map Bucket # On va déjà créer la map qui contient les jetons, on utilise une map de type BPF_MAP_TYPE_LRU_HASH :\nElle permet de nettoyer automatiquement les entrées en cas de débordement, on limite le nombre d\u0026rsquo;IPs à 16 :\nuse aya_ebpf::macros::map; use aya_ebpf::maps::LruHashMap; #[map] pub static BUCKET: LruHashMap\u0026lt;[u8; 4], u64\u0026gt; = LruHashMap::with_max_entries(16, 0); Pour trouver le nombre de jetons du bucket, nous allons regarder si la map contient déjà cet IP :\nlet token = match unsafe { BUCKET.get(\u0026amp;src_addr)} { Some(x) =\u0026gt; *x, None =\u0026gt; 5, //Token max }; Le seau ne peut pas contenir plus de 5 jetons. Nous créerons une constante à la fin.\nOn va soustraire de 1 le nombre de jeton et on va remplir la map :\nlet token_final = token.saturating_sub(1); let _ = BUCKET.insert(\u0026amp;source_addr, \u0026amp;token_final, 0); \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e saturating_sub est une méthode core de Rust. Elle empêche que le nombre de jetons soit négatif. Pour un entier naturel ça serait bizarre. Si le nombre de jeton est nulle, on bloque le paquet :\nif token_final == 0 { info!(\u0026amp;ctx, \u0026#34;drop\u0026#34;); return Ok(xdp_action::XDP_DROP); } Sinon on affiche le nombre de token :\ninfo!(\u0026amp;ctx, \u0026#34;received a packet, token {}\u0026#34;, token_final); Pour ne rien oublier, voici le code principal :\nuse aya_ebpf::{macros::map, maps::LruHashMap}; #[map] pub static BUCKET: LruHashMap\u0026lt;[u8; 4], u64\u0026gt; = LruHashMap::with_max_entries(16, 0); fn try_antiddos_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let src_addr = match filter_tcp_syn_src(\u0026amp;ctx) { Some(x) =\u0026gt; x, None =\u0026gt; return Ok(xdp_action::XDP_PASS), }; let token = match unsafe { BUCKET.get(\u0026amp;src_addr)} { Some(x) =\u0026gt; *x, None =\u0026gt; 5, //Token max }; let token_final = token.saturating_sub(1); let _ = BUCKET.insert(\u0026amp;src_addr, \u0026amp;token_final, 0); if token_final == 0 { info!(\u0026amp;ctx, \u0026#34;drop\u0026#34;); return Ok(xdp_action::XDP_DROP); } info!(\u0026amp;ctx, \u0026#34;received a packet, token {}\u0026#34;, token_final); Ok(xdp_action::XDP_PASS) } \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Pour plus de renseignements sur la map, n\u0026rsquo;hésitez pas à lire la doc :\nVérifions :\nip netns exec lb cargo run Lançons 6 fois :\ncurl 10.0.0.10:8080 Sur le terminal de cargo run, on a le résultat escompté :\n[INFO antiddos_xdp] received a packet, token 4 [INFO antiddos_xdp] received a packet, token 3 [INFO antiddos_xdp] received a packet, token 2 [INFO antiddos_xdp] received a packet, token 1 [INFO antiddos_xdp] drop [INFO antiddos_xdp] drop [INFO antiddos_xdp] drop À la fin, comme curl n\u0026rsquo;arrive pas à se connecter au serveur, il doit retransmettre des SYN.\nCalcul du rajout des jetons # Le programme actuel ne peut que vider le seau et donc bloquer au final tous les flux. Passons maintenant au remplissage du seau. Pour cela, nous avons besoin d\u0026rsquo;une autre map LAST_TS qui va contenir, pour chaque IP, le timestamp du dernier remplissage :\nCréons la map :\n#[map] static LAST_TS: LruHashMap\u0026lt;[u8; 4], u64\u0026gt; = LruHashMap::with_max_entries(16, 0); De manière similaire que pour la map BUCKET, nous allons récupérer le timestamp de la map LAST_TS :\nlet ts = match unsafe { LAST_TS.get(\u0026amp;source_addr)} { Some(x) =\u0026gt; *x, None =\u0026gt; 0, }; Pour forcer la création de l\u0026rsquo;entrée dans la map, j\u0026rsquo;ai mis un timestamp de zéro si l\u0026rsquo;entrée n\u0026rsquo;existe pas.\nCalculons le nombre de jeton qu\u0026rsquo;il faut rajouter :\nlet t = unsafe {bpf_ktime_get_ns()}; let duration = t - ts; let token_add = duration / 1_000_000_000 ; La fonction bpf_ktime_get_ns() permet de calculer le temps depuis le démarrage du système :\nLes timestamps sont exprimés en nano seconde. On rajoute ici 1 jeton par seconde écoulée.\nS\u0026rsquo;il faut en rajouter, on met à jour la map :\nif token_add \u0026gt; 0 { let _ = LAST_TS.insert(\u0026amp;source_addr, \u0026amp;t, 0); } On calcule le nombre total de jeton dans le seau :\nlet token_final = min(token.saturating_sub(1) + token_add, 5); Avec la fonction min, on évite que le bucket peut contenir plus que 5 jetons.\nPour debugger :\ninfo!(\u0026amp;ctx, \u0026#34;token {}, duration {}, token_add {}\u0026#34;, token_final, duration, token_add); En améliorant le code avec des fonctions, cela donne :\nuse aya_ebpf_bindings::helpers::bpf_ktime_get_ns; use core::cmp::min; const TOKEN_BUCKET_SIZE: u64 = 5; const REFILL_INTERVAL_NS: u64 = 1_000_000_000; #[inline(always)] fn refill_tokens(src_addr: \u0026amp;[u8; 4]) -\u0026gt; u64 { let ts = match unsafe { LAST_TS.get(src_addr)} { Some(x) =\u0026gt; *x, None =\u0026gt; 0, }; let t = unsafe {bpf_ktime_get_ns()}; let duration = t - ts; let token_add = duration / REFILL_INTERVAL_NS ; if token_add \u0026gt; 0 { let _ = LAST_TS.insert(src_addr, \u0026amp;t, 0); } token_add } #[inline(always)] fn consume_token(ctx: \u0026amp;XdpContext, src_addr: \u0026amp;[u8; 4]) -\u0026gt; u64 { let token = match unsafe { BUCKET.get(src_addr)} { Some(x) =\u0026gt; *x, None =\u0026gt; TOKEN_BUCKET_SIZE, }; let token_add = refill_tokens(src_addr); let token_final = min(token.saturating_sub(1) + token_add, TOKEN_BUCKET_SIZE); let _ = BUCKET.insert(src_addr, \u0026amp;token_final, 0); info!(ctx, \u0026#34;token {}, token_add {}\u0026#34;, token_final, token_add); token_final } fn try_antiddos_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let src_addr = match filter_tcp_syn_src(\u0026amp;ctx) { Some(x) =\u0026gt; x, None =\u0026gt; return Ok(xdp_action::XDP_PASS), }; let token_final = consume_token(\u0026amp;ctx, \u0026amp;src_addr); if token_final == 0 { info!(\u0026amp;ctx, \u0026#34;drop\u0026#34;); return Ok(xdp_action::XDP_DROP); } Ok(xdp_action::XDP_PASS) } Testons le code maintenant :\nip netns exec lb cargo run En lançant successivement cette commande curl :\ncurl 10.0.0.10:8080 On obtient ce genre d\u0026rsquo;affichage :\n[INFO antiddos_xdp] token 5, token_add 456446 [INFO antiddos_xdp] token 5, token_add 5 [INFO antiddos_xdp] token 5, token_add 5 [INFO antiddos_xdp] token 4, token_add 0 [INFO antiddos_xdp] token 4, token_add 1 [INFO antiddos_xdp] token 3, token_add 0 [INFO antiddos_xdp] token 3, token_add 1 [INFO antiddos_xdp] token 2, token_add 0 [INFO antiddos_xdp] token 2, token_add 1 [INFO antiddos_xdp] token 1, token_add 0 [INFO antiddos_xdp] token 1, token_add 1 [INFO antiddos_xdp] drop [INFO antiddos_xdp] token 1, token_add 1 [INFO antiddos_xdp] token 5, token_add 11 La première fois, on a initialisé à 0 donc la durée est le timestamp. On doit ajouter 456446 jetons mais comme le seau ne peut contenir que 5 jetons on a 5 jetons.\nLimite du programme # Si tu testes avec des outils comme hping qui peuvent générer aléatoirement des IPs, le programme ne pourra pas faire grand chose contre cela. Ces outils génèrent des paquets qui n\u0026rsquo;ont pas de cohérence, il vaut mieux le détecter et arrêter le paquet. Ainsi pour des DDoS massifs, un filtrage avec des règles dynamiques, comme Cloudflare le fait serait beaucoup plus efficace.\nCet épisode est maintenant terminé ! Nous avons vu les bases des connexions TCP et des pistes pour atténuer des DDoS.\nJusqu\u0026rsquo;à maintenant, nous avons soit observé soit bloqué le paquet mais nous n\u0026rsquo;avons pas encore vu comment modifier le paquet.\nDans le prochain épisode, nous allons voir cela en créant un petit load balancer XDP.\n","date":"24 novembre 2025","externalUrl":null,"permalink":"/ebpf-another-type/xdp/example-2/","section":"Ebpf-Another-Types","summary":"Regardons comment limiter le déni de service avec XDP","title":"Atténuons les attaques DDoS avec XDP","type":"ebpf-another-type"},{"content":"","date":"24 novembre 2025","externalUrl":null,"permalink":"/tags/aya/","section":"Tags","summary":"","title":"Aya","type":"tags"},{"content":"","date":"24 novembre 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"24 novembre 2025","externalUrl":null,"permalink":"/categories/development/","section":"Categories","summary":"","title":"Development","type":"categories"},{"content":"","date":"24 novembre 2025","externalUrl":null,"permalink":"/tags/ebpf/","section":"Tags","summary":"","title":"EBPF","type":"tags"},{"content":"","date":"24 novembre 2025","externalUrl":null,"permalink":"/categories/network/","section":"Categories","summary":"","title":"Network","type":"categories"},{"content":"","date":"24 novembre 2025","externalUrl":null,"permalink":"/tags/rust/","section":"Tags","summary":"","title":"Rust","type":"tags"},{"content":"","date":"24 novembre 2025","externalUrl":null,"permalink":"/categories/security/","section":"Categories","summary":"","title":"Security","type":"categories"},{"content":"","date":"24 novembre 2025","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"24 novembre 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"24 novembre 2025","externalUrl":null,"permalink":"/categories/tutorial/","section":"Categories","summary":"","title":"Tutorial","type":"categories"},{"content":"","date":"24 novembre 2025","externalUrl":null,"permalink":"/tags/xdp/","section":"Tags","summary":"","title":"Xdp","type":"tags"},{"content":"","date":"24 novembre 2025","externalUrl":null,"permalink":"/en/series/getting-started-with-xdp-in-aya/","section":"Series","summary":"","title":"Getting Started With XDP in Aya","type":"series"},{"content":"","date":"29 octobre 2025","externalUrl":null,"permalink":"/tetragon/","section":"Tetragons","summary":"","title":"Tetragons","type":"tetragon"},{"content":"Nous avons vu ce qu\u0026rsquo;était un programme XDP dans la première partie : cela peut être un moyen de filtrer un flux réseau.\nDans cette partie, je vous propose une petite balade dans les différentes en-têtes et de montrer comment on peut opérer le filtrage. Nous allons ainsi voir comment redévelopper xdp-filter avec le framework Rust Aya.\nSuivez le guide ! \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rlab\rJe suppose que vous êtes déjà dans un environnement pour développer avec Aya. Si ce n\u0026rsquo;est pas le cas, vous pouvez utiliser le lab Killercoda :\nCréons le hello world en XDP # Recréons l\u0026rsquo;environnement de développement # Comme nous l\u0026rsquo;avons vu dans la précédente partie, je vous propose d\u0026rsquo;installer des namespaces :\ngit clone https://github.com/littlejo/eunomia.dev cd eunomia.dev/docs/tutorials/42-xdp-loadbalancer/ ./setup.sh Rappelons ce qu\u0026rsquo;on a créé :\nCréons le programme \u0026ldquo;hello world\u0026rdquo; # Comme nous l\u0026rsquo;avons fait avec xdp-filter, nous allons installer le programme XDP sur veth0.\nGénérons déjà le programme Aya :\ncargo generate --name browser-xdp \\ -d program_type=xdp \\ -d default_iface=veth0 \\ https://github.com/aya-rs/aya-template Buildons et installons le programme \u0026ldquo;hello world\u0026rdquo; :\ncd browser-xdp/ cargo run Sur un autre terminal, testons le programme :\nip netns exec lb ping -c 2 10.0.0.1 Du côté du terminal cargo run, on voit bien deux paquets :\n[INFO browser_xdp] received a packet [INFO browser_xdp] received a packet Ainsi à chaque fois que l\u0026rsquo;interface reçoit un paquet, le programme XDP est lancé.\nMaintenant nous allons voir comment arrêter un paquet et quel type de paquet on a affaire.\nLes bases pour créer un programme XDP # Les actions XDP # Regardons d\u0026rsquo;abord le code généré par cargo.\nLe fichier le plus important est celui-là : browser-xdp-ebpf/src/main.rs c\u0026rsquo;est à dire le code côté noyau.\nGlobalement le code ressemble aux codes générés pour d\u0026rsquo;autres types de programmes eBPF comme les Tracepoints :\n#[xdp] pub fn browser_xdp(ctx: XdpContext) -\u0026gt; u32 { match try_browser_xdp(ctx) { Ok(ret) =\u0026gt; ret, Err(_) =\u0026gt; xdp_action::XDP_ABORTED, } } fn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { info!(\u0026amp;ctx, \u0026#34;received a packet\u0026#34;); Ok(xdp_action::XDP_PASS) } Cependant on peut remarquer une petite spécificité : xdp_action::*.\nCela permet de déterminer ce que fait le paquet une fois qu\u0026rsquo;il a fini de parcourir le programme eBPF.\nOn a 5 actions différentes :\nXDP_ABORTED : Arrête le paquet avec erreur XDP_DROP : Arrête le paquet silencieusement XDP_PASS : Laisse passer le paquet XDP_REDIRECT : Redirige le paquet vers une autre interface ou une socket AF_XDP attachée à une interface XDP_TX : Redirige le paquet vers la même interface Dans cet article, nous utiliserons uniquement XDP_PASS et XDP_DROP.\nLe contexte XDP et ses méthodes # Comme pour tous les autres programmes eBPF, pour aller au-delà du hello world, il faut comprendre comment jouer avec le contexte.\nRegardons la documentation :\nContrairement aux précédents types de programmes où on utilisait qu\u0026rsquo;une seule méthode, il y en a 4 différentes pour XDP :\ndata() retourne l\u0026rsquo;adresse mémoire du début du paquet réseau. data_end() retourne l\u0026rsquo;adresse mémoire de fin du paquet réseau. metadata() retourne l\u0026rsquo;adresse mémoire du début de la métadonnées de XDP lié au kernel linux ou au driver. metadata_end() retourne l\u0026rsquo;adresse mémoire de fin de la métadonnées. De la même manière que data_end(), Dans cet article, nous utiliserons uniquement les méthodes data() et data_end() pour récupérer les différentes en-têtes.\nComment récupérer les en-têtes ? # Rappelons le schéma suivant : data() se trouve au début de l\u0026rsquo;en-tête ethHdr data_end() se trouve à la fin du payload Comment récupérer l\u0026rsquo;en-tête ethernet (ethHdr) ? Elle se situe au tout début du paquet.\nlet ethhdr = ctx.data(); Pour récupérer l\u0026rsquo;en-tête suivante, il suffit de rajouter la longueur de l\u0026rsquo;en-tête ethernet, en pseudo-code Rust ça donnerait :\nlet ipv4hdr = ctx.data() + sizeof(ethhdr); Etc.\nConcentrons-nous sur l\u0026rsquo;en-tête ethernet. Comment récupérer ses éléments ? ctx.data() est de type usize. Un entier naturel qui représente une adresse mémoire. Il faut donc récupérer son contenu. Comment faire cela ?\nDe la même manière que *const u8 représente un pointeur vers une chaine de caractères, ici on doit faire la même chose pour l\u0026rsquo;en-tête ethernet.\nAinsi il faut convertir dans une structure qui représente l\u0026rsquo;en-tête de la trame Ethernet. On a plusieurs possibilités pour le faire comme aller voir le code C et le convertir en Rust ce qui est un bon exercice mais un peu fastidieux. Heureusement, comme Rust est désormais bien présent dans l\u0026rsquo;écosystème d\u0026rsquo;eBPF, il y a déjà une crate Rust qui nous a fait le travail : network-types.\nPour récupérer cette crate, on va modifier le fichier browser-xdp-ebpf/Cargo.toml et rajouter dans la section dependencies :\nnetwork-types = \u0026#34;0.1.0\u0026#34; On va ainsi pouvoir l\u0026rsquo;inclure dans le code principal (browser-xdp-ebpf/src/main.rs) :\nuse network_types::eth::EthHdr; [...] let ethhdr = ctx.data() as *const EthHdr; Maintenant qu\u0026rsquo;on a récupéré la structure de l\u0026rsquo;en-tête ethernet, nous pouvons récupérer les différents éléments qui composent l\u0026rsquo;en-tête :\nDST MAC : l\u0026rsquo;adresse MAC destination SRC MAC : l\u0026rsquo;adresse MAC source ETHERTYPE : détermine le protocole du niveau supérieur (Comme IPv4, IPv6, Arp pour citer les plus connus). Comment le faire avec Aya ? Regardons la documentation :\nAinsi pour récupérer l\u0026rsquo;adresse de destination, il suffit de coder :\nlet dst_addr = unsafe { (*ethhdr).dst_addr}; info!(\u0026amp;ctx, \u0026#34;dst_addr {:mac} \u0026#34;, dst_addr); Nous devons utiliser unsafe car nous déréférençons un pointeur brut.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e On peut remarquer que la macro info! nous permet de convertir des tableaux de 6 octets en une adresse MAC. Si vous préférez la notation en majuscule, il suffit d\u0026rsquo;écrire :MAC. Essayons maintenant. Voici le code principal modifié :\nuse network_types::eth::EthHdr; fn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let ethhdr = ctx.data() as *const EthHdr; let dst_addr = unsafe { (*ethhdr).dst_addr}; info!(\u0026amp;ctx, \u0026#34;dst_addr {:mac} \u0026#34;, dst_addr); info!(\u0026amp;ctx, \u0026#34;received a packet\u0026#34;); Ok(xdp_action::XDP_PASS) } Buildons le programme :\ncargo build La compilation fonctionne.\nInstallons le dans le noyau :\ncargo run On a alors l\u0026rsquo;erreur suivante :\nError: the BPF_PROG_LOAD syscall failed. Verifier output: 0: R1=ctx() R10=fp0 ; unsafe { (*self.ctx).data as usize } @ xdp.rs:16 0: (61) r1 = *(u32 *)(r1 +0) ; R1_w=pkt(r=0) ; let dst_addr = unsafe { (*ethhdr).dst_addr}; @ main.rs:20 1: (71) r0 = *(u8 *)(r1 +1) invalid access to packet, off=1 size=1, R1(id=0,off=1,r=0) R1 offset is outside of the packet verification time 65 usec stack depth 0 processed 2 insns (limit 1000000) max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0 Caused by: Permission denied (os error 13) Le verifier n\u0026rsquo;aime pas vraiment cette partie du code :\nlet ethhdr = ctx.data() as *const EthHdr; \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Quand on essaie d\u0026rsquo;installer un programme eBPF dans le noyau Linux, il y a un programme Linux (le verifier) qui fait des vérifications dans le code pour éviter qu\u0026rsquo;on casse la sécurité du noyau Linux. L\u0026rsquo;erreur peut se traduire en français par :\nAccès invalide au paquet. L\u0026#39;offset du registre 1 est en dehors du paquet Pas super clair. Essayons d\u0026rsquo;expliquer mieux. Quand on tente let ethhdr = ctx.data() as *const EthHdr;, Il y a un accès à la mémoire. Le verifier exige qu\u0026rsquo;on prouve que cet accès soit toujours dans le paquet (entre data() et data_end()).\nIl faut donc faire une vérification pour le rassurer avant cet accès :\nif ctx.data() + EthHdr::LEN \u0026gt; ctx.data_end() { return Ok(xdp_action::XDP_PASS); } On peut traduire par : si l\u0026rsquo;accès ne se trouve pas au niveau du paquet, le programme XDP ne traite pas le paquet : il le laisse continuer son chemin dans la pile réseau de noyau Linux.\nSinon on peut alors convertir en EthHdr :\nlet ethhdr = ctx.data() as *const EthHdr; Voici le code complet de la fonction principale :\nfn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let start = ctx.data() ; let end = ctx.data_end() ; if start + EthHdr::LEN \u0026gt; end { //Check for the verifier return Ok(xdp_action::XDP_PASS); } let ethhdr = start as *const EthHdr; let dst_addr = unsafe { (*ethhdr).dst_addr}; info!(\u0026amp;ctx, \u0026#34;dst_addr {:mac} \u0026#34;, dst_addr); info!(\u0026amp;ctx, \u0026#34;received a packet\u0026#34;); Ok(xdp_action::XDP_PASS) } Vérifions que ça marche :\ncargo run Lançons des ping. On récupère bien l\u0026rsquo;adresse mac :\n[INFO browser_xdp] dst_addr de:ad:be:ef:00:01 [INFO browser_xdp] received a packet [INFO browser_xdp] dst_addr de:ad:be:ef:00:01 [INFO browser_xdp] received a packet Maintenant qu\u0026rsquo;on a réussi à récupérer l\u0026rsquo;en-tête ethHdr, comment récupérer les autres en-têtes ? Il suffit de rajouter la longueur des en-têtes qui les précèdent.\nDe manière assez évidente, nous allons utiliser des méthodes très proches pour toutes les en-têtes. Il serait judicieux de créer une fonction. La voilà :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 use core::mem::size_of; #[inline(always)] fn ptr_at\u0026lt;T\u0026gt;(ctx: \u0026amp;XdpContext, offset: usize) -\u0026gt; Result\u0026lt;*const T, u16\u0026gt; { let start = ctx.data(); let end = ctx.data_end(); let len = size_of::\u0026lt;T\u0026gt;(); if start + offset + len \u0026gt; end { return Err(1); } Ok((start + offset) as *const T) } Quelques remarques sur la création de cette fonction :\n(L3) On inline la fonction pour des questions de performance (L4) \u0026lt;T\u0026gt; : permet de créer une fonction générique non dépendante de la structure l\u0026rsquo;offset permet de naviguer d\u0026rsquo;en-tête en en-tête (offset = 0 pour ethHdr) (L7) On a dû changer la méthode pour calculer la longueur de la structure avec un size_of pour que ça soit possible pour n\u0026rsquo;importe quelle structure Le code principal devient alors :\nfn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0)?; let dst_addr = unsafe { (*ethhdr).dst_addr}; info!(\u0026amp;ctx, \u0026#34;dst_addr {:mac} \u0026#34;, dst_addr); info!(\u0026amp;ctx, \u0026#34;received a packet\u0026#34;); Ok(xdp_action::XDP_PASS) } Maintenant qu\u0026rsquo;on a créé la fonction permettant de se balader dans les différentes en-têtes, regardons comment on fait pour bloquer ou laisser passer les différents paquets en fonction des en-têtes réseaux.\nVisite guidée des différentes en-têtes # Niveau 1 : Accès réseau # Ce qu\u0026rsquo;on peut filtrer # On l\u0026rsquo;a déjà vu pour le premier niveau : on peut notamment récupérer l\u0026rsquo;adresse MAC source, l\u0026rsquo;adresse MAC destination et l\u0026rsquo;EtherType. On peut ainsi filtrer en fonction de l\u0026rsquo;adresse MAC ou si on veut uniquement de l\u0026rsquo;IPv4 par exemple.\nOn va donc utiliser la fonction créée précédemment ptr_at() :\nlet ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0)?; Pour récupérer les adresses MAC et pour les afficher :\nlet dst_addr = unsafe { (*ethhdr).dst_addr }; let src_addr = unsafe { (*ethhdr).src_addr }; info!(\u0026amp;ctx, \u0026#34;src: {:mac} =\u0026gt; dst: {:mac}\u0026#34;, src_addr, dst_addr); Testons :\ncargo run Et pingons. regardons le résultat :\n[INFO browser_xdp] src: de:ad:be:ef:00:10 =\u0026gt; dst: de:ad:be:ef:00:01 [INFO browser_xdp] src: de:ad:be:ef:00:10 =\u0026gt; dst: de:ad:be:ef:00:01 Pour coder un peu plus propre, on peut créer une fonction :\n#[inline(always)] fn display_ethhdr(ctx: \u0026amp;XdpContext, ethhdr: *const EthHdr) { let dst_addr = unsafe { (*ethhdr).dst_addr }; let src_addr = unsafe { (*ethhdr).src_addr }; let ethertype = unsafe { (*ethhdr).ether_type }; info!(ctx, \u0026#34;EthHdr: src: {:mac} =\u0026gt; dst: {:mac} ({})\u0026#34;, src_addr, dst_addr, ethertype); } Filtrons # Ainsi pour filtrer une adresse MAC, on peut faire :\nlet mac: [u8; 6] = [0xde, 0xad, 0xbe, 0xef, 0x00, 0x10]; //de:ad:be:ef:00:10 if mac == src_addr { info!(\u0026amp;ctx, \u0026#34;drop\u0026#34;); return Ok(xdp_action::XDP_DROP); } \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Dans un \u0026ldquo;vrai\u0026rdquo; projet, on ne hard-coderait pas. On créerait une map eBPF qu\u0026rsquo;on remplirait dans l\u0026rsquo;espace utilisateur avec une liste d\u0026rsquo;adresses MAC à filtrer. On a déjà vu un cas similaire dans la section dédiée aux map eBPF de l\u0026rsquo;initiation. Testons :\ncargo run Pingons depuis lb : ça ne ping plus. Regardons le résultat au niveau d\u0026rsquo;Aya :\n[INFO browser_xdp] drop [INFO browser_xdp] drop Le programme repère bien le paquet et l\u0026rsquo;arrête.\nPingons depuis le namespace h2 :\nip netns exec h2 ping -c 2 10.0.0.1 Le ping laisse bien passer :\n[INFO browser_xdp] received ethhdr packet src: de:ad:be:ef:00:02 =\u0026gt; dst: de:ad:be:ef:00:01 [INFO browser_xdp] received ethhdr packet src: de:ad:be:ef:00:02 =\u0026gt; dst: de:ad:be:ef:00:01 Pour ressembler plus à xdp-filter, on peut créer cette fonction qui permet de distinguer si on veut empêcher la source ou la destination:\nenum Mode { Src, Dst, } #[inline(always)] fn drop_mac(ethhdr: *const EthHdr, mac: [u8; 6], mode: Mode) -\u0026gt; bool { let addr = match mode { Mode::Src =\u0026gt; unsafe {(*ethhdr).src_addr}, Mode::Dst =\u0026gt; unsafe {(*ethhdr).dst_addr}, }; mac == addr } Au niveau du code principal cela donne alors :\nfn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0)?; let mac: [u8; 6] = [0xde, 0xad, 0xbe, 0xef, 0x00, 0x10]; //de:ad:be:ef:00:10 display_ethhdr(\u0026amp;ctx, ethhdr); if drop_mac(ethhdr, mac, Mode::Src) { return Ok(xdp_action::XDP_DROP); } Ok(xdp_action::XDP_DROP); } Level up # L\u0026rsquo;Ethertype determine le protocole du paquet dans le niveau supérieur.\nAinsi pour le récupérer, on peut l\u0026rsquo;avoir de la manière suivante :\nlet ethertype = unsafe {(*ethhdr).ether_type} ; Mais il y a plus propre avec la méthode ether_type() qui vérifie si le numéro du protocole existe vraiment : Au lieu de connaître par cœur les numéros de protocole, la crate network-types nous simplifie avec le type EtherType :\nAinsi on filtre de cette manière :\nmatch unsafe { (*ethhdr).ether_type() } { Ok(EtherType::Ipv4) =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } Les flux autres que l\u0026rsquo;IPv4 (par exemple : IPv6, Arp) passent directement et ne sont plus analysés.\nNiveau 2 : Internet # Ce qu’on peut filtrer # On va donc supposer qu\u0026rsquo;on veut analyser uniquement les flux IPv4.\nDe la même manière qu\u0026rsquo;Ethernet, regardons ce qu\u0026rsquo;on peut récupérer comme données avec l\u0026rsquo;en-tête IPv4 : Pour la clareté, l\u0026rsquo;en-tête est représentée sur plusieurs lignes. Il y a nettement plus de choses à récupérer. ceux qu\u0026rsquo;on va utiliser pour cet article :\nPROTOCOL : le protocole du niveau supérieur (TCP ou UDP par exemple) SOURCE ADDRESS : l\u0026rsquo;adresse IP source DESTINATION ADDRESS : l\u0026rsquo;adresse IP destination Si vous trouvez que l\u0026rsquo;en-tête IPv4 est complexe, c\u0026rsquo;est une des raisons de la création d\u0026rsquo;IPv6 : son en-tête est un peu plus simple facilitant le traitement des paquets. Au niveau Rust, on peut récupérer ces en-têtes : Pour récupérer les en-têtes de l\u0026rsquo;IPv4, il suffit de décaler le pointeur à la longueur de la structure de l\u0026rsquo;en-tête Ethernet avec la fonction qu\u0026rsquo;on a créé :\nlet ipv4hdr: *const Ipv4Hdr = ptr_at(\u0026amp;ctx, EthHdr::LEN)? ; De la même manière que pour la couche inférieure on peut créer une fonction :\n#[inline(always)] fn display_iphdr(ctx: \u0026amp;XdpContext, iphdr: *const Ipv4Hdr) { let dst_addr = unsafe { (*iphdr).dst_addr }; let src_addr = unsafe { (*iphdr).src_addr }; let proto = unsafe { (*iphdr).proto }; info!(ctx, \u0026#34;Ipv4Hdr: src: {:i} =\u0026gt; dst: {:i} ({})\u0026#34;, src_addr, dst_addr, proto as u8); } \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Tout comme pour les adresses MAC, la macro info! nous simplifie la vie en convertissant un tableau de 4 octets en la notation d\u0026rsquo;IPv4 avec :i. Testons le code suivant :\nuse network_types::{eth::{EthHdr,EtherType}, ip::Ipv4Hdr, }; fn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0)?; match unsafe { (*ethhdr).ether_type() } { Ok(EtherType::Ipv4) =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } let ipv4hdr: *const Ipv4Hdr = ptr_at(\u0026amp;ctx, EthHdr::LEN)? ; let mac: [u8; 6] = [0xde, 0xad, 0xbe, 0xef, 0x00, 0x10]; //de:ad:be:ef:00:10 //display_ethhdr(\u0026amp;ctx, ethhdr); display_iphdr(\u0026amp;ctx, ipv4hdr); Ok(xdp_action::XDP_PASS) } Si on ping :\nip netns exec lb ping -c 2 10.0.0.1 Du côté de cargo run, cela donne :\n[INFO browser_xdp] Ipv4Hdr: src: 10.0.0.10 =\u0026gt; dst: 10.0.0.1 (1) [INFO browser_xdp] Ipv4Hdr: src: 10.0.0.10 =\u0026gt; dst: 10.0.0.1 (1) De la même manière que l\u0026rsquo;adresse Mac, pour empêcher l\u0026rsquo;ip du lb, on peut utiliser cette fonction:\n#[inline(always)] fn drop_ip(iphdr: *const Ipv4Hdr, ip: [u8; 4], mode: Mode) -\u0026gt; bool { let addr = match mode { Mode::Src =\u0026gt; unsafe {(*iphdr).src_addr}, Mode::Dst =\u0026gt; unsafe {(*iphdr).dst_addr}, }; ip == addr } Le code principal donne alors :\nfn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0)?; match unsafe { (*ethhdr).ether_type() } { Ok(EtherType::Ipv4) =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } let ipv4hdr: *const Ipv4Hdr = ptr_at(\u0026amp;ctx, EthHdr::LEN)? ; display_iphdr(\u0026amp;ctx, ipv4hdr); if drop_ip(ipv4hdr, [10, 0, 0, 10], Mode::Src) { return Ok(xdp_action::XDP_DROP); } Ok(xdp_action::XDP_PASS) } Le ping ne fonctionne plus :\nip netns exec lb ping -c 2 10.0.0.1 [INFO browser_xdp] Ipv4Hdr: src: 10.0.0.10 =\u0026gt; dst: 10.0.0.1 (1) [INFO browser_xdp] Ipv4Hdr: src: 10.0.0.10 =\u0026gt; dst: 10.0.0.1 (1) Le programme repère bien le paquet et l\u0026rsquo;arrête. Level up # Pour aller au niveau supérieur, il faut savoir quel protocole on veut regarder. Pour cela on utilise l\u0026rsquo;option proto. Il est de type IPProto qui est une énumération :\nNous allons regarder UDP pour la fin de l\u0026rsquo;article. Le principe est le même que pour l’Ethertype :\nmatch unsafe { (*ipv4hdr).proto } { IpProto::Udp =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } On peut facilement filtrer si on veut bloquer certains protocoles.\nNiveau 3 : Transport # Ce qu\u0026rsquo;on peut filtrer # Pour UDP, on peut ainsi récupérer l\u0026rsquo;en-tête de cette manière :\nlet udphdr: *const UdpHdr = ptr_at(\u0026amp;ctx, EthHdr::LEN + Ipv4Hdr::LEN)? ; Regardons maintenant l\u0026rsquo;en-tête du segment UDP :\nLa partie la plus intéressante à filtrer sont les ports.\nAu niveau Rust :\nLes ports ne sont pas des entiers mais des tableaux de 2 octets. Cela n\u0026rsquo;est pas pratique. Heureusement il y a les méthodes suivantes :\nOn peut filtrer au niveau du port UDP :\n#[inline(always)] fn drop_udp_port(udphdr: *const UdpHdr, port: u16, mode: Mode) -\u0026gt; bool { let packet_port = match mode { Mode::Src =\u0026gt; unsafe {(*udphdr).src_port()}, Mode::Dst =\u0026gt; unsafe {(*udphdr).dst_port()}, }; port == packet_port } Testons le code suivant :\nuse network_types::{eth::{EthHdr,EtherType}, ip::{Ipv4Hdr,IpProto}, udp::UdpHdr, }; fn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0)?; match unsafe { (*ethhdr).ether_type() } { Ok(EtherType::Ipv4) =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } let ipv4hdr: *const Ipv4Hdr = ptr_at(\u0026amp;ctx, EthHdr::LEN)? ; match unsafe { (*ipv4hdr).proto } { IpProto::Udp =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } let udphdr: *const UdpHdr = ptr_at(\u0026amp;ctx, EthHdr::LEN + Ipv4Hdr::LEN)? ; display_udphdr(\u0026amp;ctx, udphdr); if drop_udp_port(udphdr, 8888, Mode::Dst){ return Ok(xdp_action::XDP_DROP); } Ok(xdp_action::XDP_PASS) } Installons le programme XDP :\ncargo run Créons un serveur UDP avec netcat :\nnc -u 0.0.0.0 -l 8000 Créons un client udp maintenant :\nip netns exec lb netcat -u 10.0.0.1 8000 coucou Cette commande ouvre un client UDP et envoie le message coucou.\nDu côté sur le serveur UDP, on voit bien :\ncoucou Mais surtout, on voit bien du côté cargo run :\n[INFO browser_xdp] UdpHdr: src: 44024 =\u0026gt; dst: 8000 Testons maintenant avec un serveur UDP avec le port 8888 :\nnc -u 0.0.0.0 -l 8888 Créons un client udp maintenant :\nip netns exec lb netcat -u 10.0.0.1 8888 coucou Il ne s\u0026rsquo;affiche rien au niveau du serveur c\u0026rsquo;est normal le programme XDP l\u0026rsquo;a bloqué :\n[INFO browser_xdp] UdpHdr: src: 39540 =\u0026gt; dst: 8888 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rLes fonctions drop_mac(), drop_ip() et drop_udp_port() sont très proches il est tout à fait possible en Rust de les rendre générique pour qu\u0026rsquo;il y en ait qu\u0026rsquo;une. De même pour display_ethdr(), display_iphdr() et display_udphdr(). Vous pouvez voir le code plus générique au niveau de la crate dédiée au blog ici et là. Niveau 4 : Application # La crate network-types n\u0026rsquo;aide pas pour récupérer les en-têtes des protocoles applicatifs. En connaissant le port du niveau précédent, on peut facilement filtrer l\u0026rsquo;application. Si tu filtres le port 53 tu vas filtrer le DNS par exemple. Mais si tu veux filtrer une requête spécifique, c\u0026rsquo;est une autre affaire.\nC\u0026rsquo;est possible d\u0026rsquo;aller plus haut. Mais les en-têtes des applications peuvent être :\ntrop importantes pour la stack (limité à 512 octets), il faudrait obligatoirement passé par des maps eBPF ; chiffrées comme pour HTTPS ou SSH ce qui rend l\u0026rsquo;analyse impossible avec XDP. Cet épisode est maintenant terminé ! Nous avons vu les bases pour créer un firewall comme xdp-filter.\nCependant, nous n\u0026rsquo;avons pas vu comment faire pour qu\u0026rsquo;il soit un peu plus intelligent en évitant par exemple les DDoS.\nÇa tombe bien ! Dans le prochain épisode, nous allons créer un programme XDP qui va atténuer les dénis de service.\n","date":"29 octobre 2025","externalUrl":null,"permalink":"/ebpf-another-type/xdp/example-1/","section":"Ebpf-Another-Types","summary":"Regardons comment bloquer le flux selon certains critères (adresse mac, ip, protocole, port, etc.)","title":"Implémentons un petit firewall avec XDP","type":"ebpf-another-type"},{"content":"","date":"16 octobre 2025","externalUrl":null,"permalink":"/en/series/lets-learn-another-ebpf-program/","section":"Series","summary":"","title":"Let’s Learn Another EBPF Program","type":"series"},{"content":"","date":"16 octobre 2025","externalUrl":null,"permalink":"/series/apprenons-un-autre-programme-ebpf/","section":"Series","summary":"","title":"Apprenons Un Autre Programme EBPF","type":"series"},{"content":"","date":"16 octobre 2025","externalUrl":null,"permalink":"/categories/introduction/","section":"Categories","summary":"","title":"Introduction","type":"categories"},{"content":"Je débute la programmation en eBPF avec Aya. L’idée de cette série d’articles est d\u0026rsquo;apprendre un nouveau type de programme eBPF et de l\u0026rsquo;expérimenter avec le framework Rust Aya.\nAujourd\u0026rsquo;hui, nous allons nous plonger dans XDP : des programmes eBPF capables de filtrer ou rediriger des paquets réseau plus vite que son ombre.\nVous allez voir que cela peut être très intéressant pour créer un pare-feu efficace, capable de contrer les attaques en déni de service mais également pour load-balancer des millions de paquets réseaux.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Si tu ne connais pas eBPF, je te conseille de lire les deux premières parties de ma série S’initier à eBPF avec Aya. Cela couvre les bases et t\u0026rsquo;aidera pour la suite de l\u0026rsquo;article. Qu’est-ce qu’XDP ? # Comme vous devez vous en doûter, XDP est un type de programme eBPF orienté réseau. XDP est l\u0026rsquo;acronyme de eXpress Data Path qu\u0026rsquo;on pourrait traduire par voie rapide pour les données.\nPour bien comprendre la signification de cet acronyme, il faut avoir conscience de ce que parcourt un paquet réseau depuis la carte réseau jusqu\u0026rsquo;à une application comme un serveur Web. Traditionnellement il fait le parcours suivant sous Linux : XDP s\u0026rsquo;exécute directement au niveau du driver, permettant ainsi de réagir plus rapidement qu\u0026rsquo;un firewall applicatif. Cette rapidité est notamment cruciale contre les attaques par déni de service distribué (DDoS : Distributed Denial of Service attack).\nSi on veut être précis, XDP peut intervenir à 3 endroits différents selon la prise en charge de la carte réseau :\nAu niveau du firmware de la carte réseau (mode offloaded) mais seulement quelques modèles de carte réseaux prennent en charge cela Au niveau du driver réseau (mode native), le cas le plus courant pour des serveurs standards Au niveau de la pile réseau du noyau (mode generic), permettant ainsi de tester sur n\u0026rsquo;importe quel ordinateur (comme ton portable) N\u0026rsquo;hésitez pas à consulter cette page pour plus de précision.\nPar contre, XDP intervenant sur une couche réseau très basse, les données en sortie récupérées sont brutes et non transformées par la couche réseau de Linux ce qui le rend plus complexe à gérer pour certaines tâches (comme le suivi des connexions et des retransmissions TCP).\nPour en savoir plus, n\u0026rsquo;hésitez pas à consulter la documentation officielle :\nNous allons maintenant parler du contexte de la création de cette technologie.\nOrigin story # Les ancêtres de XDP # On n\u0026rsquo;a pas attendu XDP pour filtrer ou rediriger les paquets dans le noyau Linux.\nLe premier firewall a été implémenté dans Linux 1.1 en 1994, il se nommait ipfw et pour le configurer il y avait la ligne de commande ipfwadm. Il est inspiré du firewall créé pour FreeBSD. Il a été remplacé par ipchains dans Linux 2.2 en 1999 qui était plus complet et adapté à la nouvelle couche réseau du noyau.\nNetfilter : l\u0026rsquo;immortel # Pour la version 2.4 (2001) du noyau Linux, un tout nouveau pare-feu a été créé : Netfilter et sa ligne de commande iptables que tout ingénieur Linux réseau connaît très bien encore aujourd\u0026rsquo;hui. Netfilter traite les paquets réseaux à divers endroits de la pile réseau de Linux donc bien après le driver.\nDepuis cette version, Netfilter a évolué pour gérer les nouveautés comme IPv6, les cgroups.\n\u003c?xml version=\"1.0\" encoding=\"iso-8859-1\"?\u003e\rVous avez probablement entendu parler de nftables. Elle est juste une ligne de commande qui permet de mettre à jour plus efficacement qu\u0026rsquo;iptables les règles. Pour cela on a dû modifier l\u0026rsquo;\u0026ldquo;api\u0026rdquo; du noyau Linux. Mais le moteur derrière reste netfilter. Malgré ses qualités, Linux n\u0026rsquo;a jamais eu bonne presse pour le matériel réseau. Par exemple, la plupart des switchs et routeurs professionnels tournent sous d\u0026rsquo;autres systèmes d\u0026rsquo;exploitation. Est-ce qu\u0026rsquo;XDP pourrait inverser la tendance ?\nXDP : le successeur ? # En 2014, eBPF est sortie. Mais c\u0026rsquo;est deux ans plus tard, pour la version 4.8 du noyau Linux que XDP était enfin utilisable. Il a été développé conjointement par Brenden Blanco (PLUMgrid Inc) et Tom Herbert (Facebook).\nContrairement à d\u0026rsquo;autres types de programme eBPF, XDP ne peut s\u0026rsquo;utiliser uniquement avec eBPF. Un hook est placé au niveau du driver réseau permettant ainsi de démarrer son programme eBPF. Ainsi il fallait développer les drivers compatibles XDP pour que cela puisse fonctionner. Il fallait également que les frameworks de l\u0026rsquo;époque puissent gérer ce nouveau type de programme. Ainsi dès juillet 2016, avant même la sortie officiel du noyau Linux compatible avec XDP, il était possible de créer des programmes XDP avec BCC :\nDepuis, XDP a continué d\u0026rsquo;évoluer, on peut noter :\nen 2018, l\u0026rsquo;apparition de la socket AF_XDP (Address Family Express Data Path) qui permet d\u0026rsquo;exploiter XDP depuis l\u0026rsquo;espace utilisateur sans passer par la pile réseau. en 2022, la gestion des paquets importants (comme Jumbo packet, GRO ou BIG TCP) avec XDP Fragment. Aujourd\u0026rsquo;hui, XDP est considéré comme stable et utilisable en production.\n\u003c?xml version=\"1.0\" encoding=\"iso-8859-1\"?\u003e\rOn ne peut pas dire qu\u0026rsquo;XDP est un remplaçant de Netfilter. Par exemple, recréer une commande équivalente à iptables avec XDP serait un travail colossal. Le projet bpfilter est un projet qui vise à traduire les règles iptables en programmes eBPF n\u0026rsquo;utilise pas uniquement XDP. Pour finir, voici une petite frise chronologique de l\u0026rsquo;histoire de XDP :\nMaintenant qu\u0026rsquo;XDP est jugée stable, on peut se poser une question bien légitime : quels projets utilisent XDP ?\nQuels projets utilisent XDP ? # Pour défier le lieu commun : \u0026ldquo;eBPF c\u0026rsquo;est utilisé que par 3 grosses boîtes\u0026rdquo;, j\u0026rsquo;ai fait une petite recherche des outils qui utilisaient réellement XDP et que donc vous l\u0026rsquo;utilisiez peut-être sans le savoir\u0026hellip;\nKatran : le loadbalancer de Facebook # Le projet Katran développe un load balancer XDP de niveau 4. Il est utilisé par Facebook mais également par Netflix. Par ailleurs, Facebook a créé un firewall basé sur XDP pour empêcher le DDoS.\nCilium : les services externes de Kubernetes # Le projet Cilium fournit un plugin CNI pour Kubernetes et peut également remplacer kube-proxy. Selon certaines conditions, Cilium peut activer XDP pour les services de type NodePort, LoadBalancer et externalIPs, permettant ainsi d\u0026rsquo;être plus performant.\nCloudflare : pour empêcher le DDoS # En 2018, Cloudflare a publié un article expliquant comment il réduisait le DDoS avec XDP. Récemment Cloudflare a communiqué pour avoir déjoué un DDoS de 22,2 Tbit/s.\nEt bien d\u0026rsquo;autres # Il y a certainement d\u0026rsquo;autres projets moins connus qui utilisent XDP comme Surricata.\nNous allons maintenant voir les principales difficultés que l\u0026rsquo;on va rencontrer quand on va commencer à créer un programme XDP.\nComment débuter son programme XDP ? # Pour de nombreux programmes eBPF, la première difficulté est de trouver le point d\u0026rsquo;accroche. Pour XDP, c\u0026rsquo;est relativement simple : il suffit de connaître le nom de l\u0026rsquo;interface réseau où on veut accrocher le programme XDP.\nLa réelle difficulté réside plutôt dans la création d\u0026rsquo;un environnement réseau. La solution traditionnelle est de créer des VMs (avec Vagrant par exemple) et de les faire communiquer entre eux. Cette solution est tout à fait possible pour XDP mais ça me paraît un peu lourd à mettre en place (par exemple pour les labs).\nPour la suite, je vous propose une solution beaucoup plus légère : en utilisant les namespaces réseaux de Linux. Le même mécanisme qui est utilisé pour Docker.\nCréation d\u0026rsquo;un environnement pour XDP # \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rlab\rJe suppose que vous êtes sous Linux pour la démonstration. Si ce n\u0026rsquo;est pas le cas, vous pouvez utiliser le lab Killercoda :\nScript de création de l\u0026rsquo;environnement # On pourrait faire un tutoriel pour la création de namespaces réseaux mais comme ce n\u0026rsquo;est pas le sujet central et comme il y a déjà des scripts qu\u0026rsquo;on peut facilement trouver sur le net, je vous propose le script suivant :\ngit clone https://github.com/littlejo/eunomia.dev cd eunomia.dev/docs/tutorials/42-xdp-loadbalancer/ Pour créer les namespaces réseaux :\n./setup.sh \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rJ\u0026rsquo;ai dû installer le paquet net-tools sous Debian pour avoir accès à la commande arp qui est utilisée dans le script pour effectuer des vérifications de bon fonctionnement. Ce script va créer trois namespaces qui peuvent communiquer entre eux (lb, h2 et h3) via un bridge (br0) :\nip netns list lb (id: 23) h3 (id: 18) h2 (id: 15) Pour voir les IPs d\u0026rsquo;un namespace, on peut taper :\nip netns exec lb ip -brief -family inet addr lo UNKNOWN 127.0.0.1/8 veth6@if98 UP 10.0.0.10/24 Il faut voir ces namespaces un peu comme des containers à part qu\u0026rsquo;à l\u0026rsquo;intérieur des namespaces on a toutes les commandes de l\u0026rsquo;hôte ! On peut représenter de cette manière ces namespaces :\nVérification du bon fonctionnement # Bien que le script fait déjà les vérifications nécessaires, on va tout de même en faire quelques uns nous même pour montrer les possibilités de tests qu\u0026rsquo;on peut faire.\nOn peut ainsi pinger l\u0026rsquo;ip d\u0026rsquo;un namespace depuis l\u0026rsquo;hôte :\nping -c 3 10.0.0.10 Ça ping bien :\nPING 10.0.0.10 (10.0.0.10) 56(84) bytes of data. 64 bytes from 10.0.0.10: icmp_seq=1 ttl=64 time=0.060 ms 64 bytes from 10.0.0.10: icmp_seq=2 ttl=64 time=0.124 ms 64 bytes from 10.0.0.10: icmp_seq=3 ttl=64 time=0.122 ms --- 10.0.0.10 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2053ms rtt min/avg/max/mdev = 0.060/0.102/0.124/0.029 ms Pour tester la connexions à un serveur web dans un namespace, je peux le faire de cette manière dans le namespace h2 :\nip netns exec h2 python3 -m http.server 8080 Si je veux tester que depuis lb, je peux me connecter au serveur web, je tape sur un autre terminal :\nip netns exec lb curl http://10.0.0.2:8080 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e On pourra ainsi créer un petit load balancer dans le namespace lb et le rediriger vers le namespace h2 et h3. On a ainsi un environnement de test complet pour la suite des articles.\nNettoyage # Pour supprimer les namespaces et les interfaces réseaux, on peut redémarrer la machine ou juste taper :\n./teardown.sh Mon premier programme xdp # Nous allons maintenant créer un petit programme XDP dans l\u0026rsquo;environnement créé.\nxdp-tools est une suite d\u0026rsquo;outils pour créer et debugger des programmes XDP.\nPour l\u0026rsquo;installer sous Debian 13, j\u0026rsquo;ai installé le paquet :\napt install xdp-tools Si vous galérez pour l\u0026rsquo;installer j\u0026rsquo;ai créé un container pour cela (littlejo/xdp-tools). Tout est là. On va utiliser xdp-filter qui permet de créer des programmes xdp qui filtrent les paquets.\nOn va installer un programme xdp sur l\u0026rsquo;interface veth0 :\nxdp-filter load veth0 L\u0026rsquo;option load permet de charger le programme XDP.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Pour le décharger, il suffit d\u0026rsquo;utiliser l\u0026rsquo;option unload : xdp-filter unload veth0. Voilà ce qu\u0026rsquo;on a fait schématiquement :\nDepuis un autre terminal, on peut vérifier que le ping fonctionne :\nip netns exec lb ping -c 3 10.0.0.1 Vous pouvez également le voir :\nxdp-filter status Vous voyez qu\u0026rsquo;xdp a bien laissé passer 3 packets :\nCURRENT XDP-FILTER STATUS: Aggregate per-action statistics: XDP_ABORTED 0 pkts 0 KiB XDP_DROP 0 pkts 0 KiB XDP_PASS 3 pkts 0 KiB Loaded on interfaces: Enabled features xdpfilt_alw_all veth0 (native mode) tcp,udp,ipv6,ipv4,ethernet,allow Filtered ports: Mode Hit counter Filtered IP addresses: Mode Hit counter Filtered MAC addresses: Mode Hit counter Pour filtrer l\u0026rsquo;ip de lb :\nxdp-filter ip -m src 10.0.0.10 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Created by potrace 1.10, written by Peter Selinger 2001-2011 On peut supprimer la règle avec l\u0026rsquo;option -r : xdp-filter ip -m src -r 10.10.0.10 Avec cet exemple, il faut bien comprendre que les programmes XDP fonctionnent uniquement à l\u0026rsquo;arrivée de l\u0026rsquo;interface (ingress). Ainsi l\u0026rsquo;IP source est 10.0.0.10 et l\u0026rsquo;IP destination est toujours 10.0.0.1.\nSi on avait voulu empêcher lb de pinger en créant un programme XDP sur l\u0026rsquo;interface jumelle veth1, on aurait dû lancer la commande suivante :\nxdp-filter ip -m dst 10.0.0.10 En effet, l\u0026rsquo;ip source est maintenant l\u0026rsquo;IP de l\u0026rsquo;interface veth0 et l\u0026rsquo;IP destination est l\u0026rsquo;ip où envoie le echo reply c\u0026rsquo;est à dire 10.0.0.10.\nVérifiez tout de même que le ping ne fonctionne plus :\nip netns exec lb ping -c 3 10.0.0.1 Mais qu\u0026rsquo;on peut toujours pinger depuis un autre namespace :\nip netns exec h2 ping -c 3 10.0.0.1 On peut le voir avec xdp-filter status :\nCURRENT XDP-FILTER STATUS: Aggregate per-action statistics: XDP_ABORTED 0 pkts 0 KiB XDP_DROP 5 pkts 0 KiB XDP_PASS 16 pkts 1 KiB Loaded on interfaces: Enabled features xdpfilt_alw_all veth0 (native mode) tcp,udp,ipv6,ipv4,ethernet,allow Filtered ports: Mode Hit counter Filtered IP addresses: Mode Hit counter 10.0.0.10 src 5 Filtered MAC addresses: Mode Hit counter \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rDans le prochain épisode, nous allons montrer comment recréer la commande xdp-filter avec Aya. Anatomie d\u0026rsquo;un paquet réseau # Maintenant qu\u0026rsquo;on a réussi à créer des programmes XDP avec xdp-filter, une autre difficulté qui va apparaître assez rapidement quand on va essayer de réellement développer un programme XDP, c\u0026rsquo;est les connaissances en réseau. Comme je l\u0026rsquo;écrivais au début de l\u0026rsquo;article, avec XDP on récupère des données bruts du paquet, il faut réussir à l\u0026rsquo;analyser en comprenant comment est architecturé un paquet réseau.\nAinsi un paquet réseau a deux parties :\nLe messager (les en-têtes) : les adresses IP, MAC, le protocole, le port utilisé, etc. La partie intéressante pour l\u0026rsquo;ingénieur réseau. Le contenu du message (payload) : la partie intéressante pour l\u0026rsquo;utilisateur. Comment sont structurés ses en-têtes ? Par les différentes couches du modèle TCP/IP. Ça vous dit quelques choses ? Moi j\u0026rsquo;avais (presque) tout oublié.\nModèle TCP/IP # Le modèle TCP/IP a 4 couches :\nAccès réseau : Filaire (Ethernet) ou sans fil (Wifi) Internet : IPv4, IPv6, ICMP, etc Transport : TCP et UDP Application : HTTP, SSH, DNS, etc XDP intervient dès la réception de la couche 1. Le paquet encapsule les différentes couches. Ainsi le paquet sera structuré de la manière suivante :\nl\u0026rsquo;en-tête accès réseau (on verra uniquement l\u0026rsquo;en-tête ethernet : ethernet header (ethhdr)), il va permettre de savoir si on est en IPv4 ou en IPv6 l\u0026rsquo;en-tête internet (par exemple : internet protocol header (iphdr)), il va permettre de savoir si on est en UDP, TCP ou ICMP l\u0026rsquo;en-tête transport (par exemple : transmission control protocol header (tcphdr)), il va permettre de savoir sur quel port on est par exemple. l\u0026rsquo;en-tête applicative est beaucoup moins standard, nous n\u0026rsquo;irons pas jusque là. Voici par exemple les différentes en-têtes pour une requête DNS :\nAinsi pour créer un programme XDP, il faut se balader sur les différentes en-têtes du paquet et récupérer un élément particulier de l\u0026rsquo;en-tête.\nL\u0026rsquo;en-tête d\u0026rsquo;UDP est composée des éléments suivants :\nPort source : depuis quel port le paquet est envoyé (un port variable définit par l\u0026rsquo;application) Port destination : à quel port le paquet doit être envoyé (par exemple le port 53 pour le DNS) Longueur : longueur total du segment UDP (en-tête + payload) Checksum : vérification de l\u0026rsquo;intégrité du paquet. Une fois qu\u0026rsquo;on a récupéré l\u0026rsquo;élément cible, nous pourrons décider par exemple si nous bloquons l\u0026rsquo;accès au paquet.\nDans cet épisode, on a vu les bases d\u0026rsquo;XDP : à quoi cela sert, son histoire, qui l\u0026rsquo;utilise et les pré-requis pour débuter un programme XDP.\nTout cela vous paraît abstrait ? Nous allons maintenant passer à la pratique dans l\u0026rsquo;épisode suivant : on va créer un petit firewall XDP avec Aya !\n","date":"16 octobre 2025","externalUrl":null,"permalink":"/ebpf-another-type/xdp/intro/","section":"Ebpf-Another-Types","summary":"Découverte de XDP avec Aya","title":"XDP, le firewall ultra rapide de Linux","type":"ebpf-another-type"},{"content":"","date":"23 septembre 2025","externalUrl":null,"permalink":"/series/apprenons-uprobe-avec-ebpf-et-aya/","section":"Series","summary":"","title":"Apprenons UProbe Avec EBPF Et Aya","type":"series"},{"content":"Nous avons vu ce qu\u0026rsquo;était un programme de type uProbe dans la première partie. Cela peut être ainsi un moyen de profiler un programme.\nLe but de cet article est donc de regarder le temps que met une fonction d\u0026rsquo;un programme écrit en Rust à s\u0026rsquo;exécuter.\nCela permettra également de voir la différence avec un programme écrit en Go pour la récupération des points d\u0026rsquo;attache des programmes eBPF de type uProbe.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rJe suppose que vous êtes déjà dans un environnement pour développer avec Aya et que vous avez installé bpftrace.\nSi ce n\u0026rsquo;est pas le cas, vous pouvez utiliser le lab Killercoda :\nPrésentation du programme Rust pour tester les uProbes # Calculer les décimales de 𝛑 # Avant de créer le programme eBPF, nous allons donc déjà récupérer un petit programme en Rust.\nPour que ça soit un peu plus inventif qu\u0026rsquo;un programme hello world, j\u0026rsquo;ai choisi un programme qui affiche une estimation du nombre 𝛑. En faisant varier le nombre de décimal, on peut facilement changer la durée d\u0026rsquo;exécution de la fonction.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Le nombre 𝛑 (Pi) est un nombre qui permet, par exemple, de calculer le périmètre d\u0026rsquo;un cercle. Ce nombre a la particularité d\u0026rsquo;avoir une infinité de décimales ce qui rend leur calcul complexe. En 2022, on en a déterminé les 100 mille milliards premières décimales. Voici les commandes pour le récupérer et le compiler :\ngit clone https://github.com/littlejo/pi_digits_rust cd pi_digits_rust cargo build Pour tester le binaire généré, on peut alors lancer la commande suivante :\n./target/debug/pi_digits_pure_rust 10 #Pour avoir 10 décimales de Pi Ce qui répond :\n3.1415926536 On a bien 10 décimales.\nLe but de cet article est de récupérer le temps que met la fonction dédiée au calcul des décimales de Pi (pi_times_10n_rounded()).\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rVous pouvez tester pour un autre programme compilé comme C/C++, Go, Zig ou V de votre choix pour comparer. Comment va-t-on procéder ? # Pour cela nous allons utiliser :\nun programme de type uProbe pour mesurer le temps à l\u0026rsquo;arrivée de la fonction un programme de type uRetProbe pour mesurer le temps à la sortie de la fonction Ainsi en soustrayant le temps d\u0026rsquo;entrée du temps de sortie, on va trouver la durée totale pour calculer les décimales de 𝛑.\nAvant cela, il faut d\u0026rsquo;abord trouver le point d\u0026rsquo;attache pour ce programme écrit en Rust pour ces deux programmes eBPF.\nTrouver le point d\u0026rsquo;attache # Maintenant qu\u0026rsquo;on a créé et compilé le petit programme, il faut trouver comment déclencher le programme eBPF de type uProbe ou uRetProbe. Lorsqu\u0026rsquo;on utilise cargo generate pour le repo aya, il faut répondre à deux questions : où se trouve le nom du binaire et quelle fonction observée. Voyons cela en détail.\nNom du binaire # 🤷 Target to attach the (u|uret)probe? (e.g libc): Pour garantir la portabilité du programme eBPF, il faut répondre le chemin absolu du binaire. Par exemple je l\u0026rsquo;ai créé là : /home/cloud_user/pi_digits/target/debug/pi_digits_pure_rust.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Comme le chemin est un peu long, pour la suite, le nom du binaire sera en chemin relatif pour une meilleur lisibilité de l\u0026rsquo;article : ./pi_digits_pure_rust) Nom de la fonction # 🤷 Function name to attach the (u|uret)probe? (e.g getaddrinfo): Que faut-il répondre ?\nOn l\u0026rsquo;a déjà vu : on peut utiliser la commande bpftrace, par exemple :\nbpftrace -l \\ \u0026#39;uprobe:./pi_digits_pure_rust:*pi_times*\u0026#39; On trouve alors :\nuprobe:./pi_digits_pure_rust:pi_times_10n_rounded La fonction est donc bien pi_times_10n_rounded.\nAstuces # Si vous êtes attentifs, dans la deuxième partie, on avait vu que, par défaut, le compilateur Go :\ninlinait les fonctions et donc on ne pouvait pas les voir On a dû rajouter l\u0026rsquo;option de compilation -l pour empêcher cela modifiait le nom de la fonction (mangle) On a dû rajouter l\u0026rsquo;option de compilation -N pour empêcher cela Rappelons ce qu\u0026rsquo;est un inline (ici avec le compilateur Go) via un schéma :\nRust fait également cela par défaut. Mais ce n\u0026rsquo;est pas au niveau global que je l\u0026rsquo;ai fait mais pour la fonction en particulier.\nJ\u0026rsquo;ai ainsi dû rajouter deux attributs dans le code devant la fonction cible :\n#[no_mangle] #[inline(never)] pub fn pi_times_10n_rounded(n: usize) -\u0026gt; num_bigint::BigInt { //[...] } #[no_mangle] : ne pas modifier le nom de la fonction #[inline(never)] : ne jamais inliner la fonction Maintenant qu\u0026rsquo;on a défini le point d\u0026rsquo;attache. Nous allons pouvoir commencer à créer nos deux programmes eBPF.\nRécupérons le temps de lancement des programmes eBPF # Commençons simple en créant les deux programmes eBPF et en récupérant juste leur temps de lancement.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e Suite de l’article réservée aux membres premium ✨\nL’article complet est accessible uniquement aux membres premium.\nDevenir membre premium, c’est simple : il suffit de faire un petit don 💖\nEn échange, vous aurez pendant 1 an (offre early bird) :\nAccès à tous les articles complets dès leur publication Lecture anticipée avant la mise en ligne publique Participation au soutien de ce blog indépendant Accès exclusif à mes photos de vacances à Dubaï Votre don permet de :\nMe rendre moins dépendant des grandes plateformes M’encourager à créer plus de contenu technique Lever le paywall plus rapidement pour tous 👉 Devenir membre premium dès maintenant\n","date":"23 septembre 2025","externalUrl":null,"permalink":"/ebpf-another-type/uprobe/example-3-tr/","section":"Ebpf-Another-Types","summary":"","title":"Profilons un petit programme avec des uProbes","type":"ebpf-another-type"},{"content":"","date":"23 septembre 2025","externalUrl":null,"permalink":"/categories/teaser/","section":"Categories","summary":"","title":"Teaser","type":"categories"},{"content":"","date":"23 septembre 2025","externalUrl":null,"permalink":"/tags/uprobe/","section":"Tags","summary":"","title":"Uprobe","type":"tags"},{"content":"","date":"23 septembre 2025","externalUrl":null,"permalink":"/tags/uretprobe/","section":"Tags","summary":"","title":"Uretprobe","type":"tags"},{"content":"","date":"23 septembre 2025","externalUrl":null,"permalink":"/en/series/getting-started-with-ebpf-uprobes-in-aya/","section":"Series","summary":"","title":"Getting Started With EBPF UProbes in Aya","type":"series"},{"content":"Nous avons vu ce qu\u0026rsquo;était un programme de type uProbe dans la première partie : ça peut être un moyen de sonder une bibliothèque.\nNous allons vérifier cela avec un programme Aya qui va récupérer les différents arguments de la fonction execve() de la Libc.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rJe suppose que vous êtes déjà dans un environnement pour développer avec Aya et que vous avez installé bpftrace. Si ce n\u0026rsquo;est pas le cas, vous pouvez utiliser le lab Killercoda :\nQue va-t-on vraiment faire ? # Libc # Contrairement à la précédente partie où on a attaché notre programme eBPF à un programme, là nous l\u0026rsquo;attachons à une bibliothèque partagée.\nLa libc est la bibliothèque standard du C. Donc à chaque fois qu\u0026rsquo;un programme en C (ou en C++) est exécuté, potentiellement, un programme eBPF pourra être lancé.\n\u003c?xml version=\"1.0\" encoding=\"iso-8859-1\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rJe parle de libc tout au long du chapitre. Pour être plus précis, il faudrait parler de la glibc (GNU C Library) l\u0026rsquo;implémentation la plus répandue dans les distributions GNU/Linux (Comme Debian ou Red Hat). Mais il y a d\u0026rsquo;autres implémentations comme musl (notamment pour Alpine Linux) ou ulibc qui sont plus légères et adaptées pour les systèmes embarqués. La fonction execve # execve est un appel système (un syscall) du noyau Linux. Mais c\u0026rsquo;est aussi le nom d\u0026rsquo;une fonction de la libc qui fait appel à ce même syscall (un wrapper). Ainsi, à chaque fois que la fonction execve() de la libc sera appelée, notre programme eBPF de type uProbe sera lancé.\nLes arguments de la fonction execve # Nous devons également récupérer les différents arguments de la fonction execve().\nPour trouver ses arguments, on peut évidemment regarder dans le code source de la libc. Mais il y a plus simple :\nman execve La partie qui nous intéresse est la suivante :\nint execve(const char *pathname, char *const _Nullable argv[], char *const _Nullable envp[]); On voit que la fonction a trois arguments :\npathname: le nom de la commande avec le chemin complet (exemple /bin/bash). Il est de type const char * (équivalent en Rust à *const u8). argv: un tableau d\u0026rsquo;arguments de la commande. Il est de type char *const _Nullable[] (équivalent en Rust à *const *const u8) argv[0] : le nom de la commande argv[1] : la première option etc. envp : un tableau de variables d\u0026rsquo;environnement de la commande. Il est de type char *const _Nullable[] (équivalent en Rust à *const *const u8). \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e _Nullable indique simplement que la valeur peut être NULL. Comment déclencher le programme eBPF ? # Prenons un exemple simple. Si tu lances une commande dans un terminal par exemple ls, que va-t-il se passer ?\nGrâce à la variable d\u0026rsquo;environnement PATH, le shell (par exemple le bash) va trouver le bon chemin pour trouver où se trouve le binaire ls : /usr/bin/ls Pour exécuter le binaire, le shell va alors appeler la fonction execve() de la libc : execve(\u0026#34;/usr/bin/ls\u0026#34;, [\u0026#34;ls\u0026#34;], [\u0026#34;PATH=/bin:/usr/bin\u0026#34;, ...]) Le programme eBPF sera enfin déclenché. Voici un petit résumé de tout cela :\nIl y a évidemment d\u0026rsquo;autres programmes que des shells qui appellent la fonction execve() de la libc comme systemd pour le démarrage des différents programmes d\u0026rsquo;un système Linux.\nAinsi nous allons créer un programme très proche de celui qu\u0026rsquo;on avait créé avec le Tracepoint sys_enter_execve lors des articles d\u0026rsquo;initiation à eBPF mais celui-ci sera attaché au niveau utilisateur à la fonction execve() de la libc.\nGénérons un programme Aya de type uProbe # Nous avons donc déjà les réponses aux deux questions :\n🤷 Target to attach the (u|uret)probe? (e.g libc): 🤷 Function name to attach the (u|uret)probe? (e.g getaddrinfo): Voyons comment créer un programme eBPF hello world pour ce point d\u0026rsquo;attache.\nTestons avec bpftrace # Vérifions d\u0026rsquo;abord que ça fonctionne avec la ligne de commande bpftrace :\nsudo bpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;Hello execve\\n\u0026#34;); }\u0026#39; uprobe : le type de programme eBPF libc : le nom de la bibliothèque execve : la fonction à debugger { printf(\u0026quot;Hello execve\\n\u0026quot;); } : le code bpftrace À chaque fois qu\u0026rsquo;on lance une commande sur un autre terminal, on voit bien Hello execve.\nMaintenant faisons-le avec Aya.\nGénération et compilation du programme Aya # La commande cargo generate suivante permet ainsi de génerer le programme eBPF :\ncargo generate --name test-uprobe-2 \\ -d program_type=uprobe \\ -d uprobe_target=libc \\ -d uprobe_fn_name=execve \\ https://github.com/aya-rs/aya-template \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rPour trouver le nom des arguments (uprobe_target et uprobe_fn_name), vous pouvez regarder le fichier test.sh dans le repo aya-template. Maintenant compilons le et installons le dans le noyau Linux :\ncd test-uprobe-2/ RUST_LOG=info cargo run Test du programme # Sur un autre terminal, lancer un programme quelconque :\nls Sur le terminal cargo run vous verrez :\n[INFO test_uprobe] function execve called by libc Dans la partie précédente, on était resté à ce point concernant les uProbes. Regardons comment récupérer les différentes arguments de la fonction execve(). Commençons par le premier : le nom du binaire.\nRécupérons le nom du binaire # Testons avec bpftrace # Avant de modifier le code Aya, regardons comment on fait avec bpftrace. C\u0026rsquo;est un poil plus compliqué qu\u0026rsquo;un simple hello world.\nPour récupérer le premier argument, on utilise arg0 :\nsudo bpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;%d\\n\u0026#34;, arg0); }\u0026#39; On récupère l\u0026rsquo;adresse où se trouve le première argument. Comment le \u0026ldquo;convertir\u0026rdquo; en chaîne de caractères ? Il suffit d\u0026rsquo;utiliser la fonction str() :\nsudo bpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;%s\\n\u0026#34;, str(arg0)); }\u0026#39; Maintenant qu\u0026rsquo;on a le brouillon avec bpftrace, regardons comment l\u0026rsquo;implémenter avec Aya.\nModifions le code Aya # Nous devons modifier la fonction suivante du fichier test-uprobe-2-ebpf/src/main.rs:\nfn try_test_uprobe_2(ctx: ProbeContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { info!(\u0026amp;ctx, \u0026#34;function execve called by libc\u0026#34;); Ok(0) } Il faut donc chercher à manipuler la variable ctx. Voici la documentation :\nIl n\u0026rsquo;y a qu\u0026rsquo;une méthode qui nous intéresse :\nLe premier élément est le nom du binaire qui est exécuté.\nIl faut donc rajouter un truc comme ça :\nlet arg0: *const u8 = ctx.arg(0).ok_or(1u32)?; \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rOn utilise le type *const u8 car le premier argument est de type const char * en C (cf man execve) Pour \u0026ldquo;convertir\u0026rdquo; ce pointeur en chaîne de caractère on va le faire de façon similaire qu\u0026rsquo;on avait fait avec les Tracepoints dans l\u0026rsquo;article d\u0026rsquo;initiation à la création de programme eBPF avec Aya.\nAinsi on se retrouve avec le code suivant :\nfn try_test_uprobe_2(ctx: ProbeContext) -\u0026gt; Result\u0026lt;u32, i64\u0026gt; { let arg0: *const u8 = ctx.arg(0).ok_or(1u32)?; let mut buf = [0u8; 128]; let filename = unsafe { let filename_bytes = bpf_probe_read_user_str_bytes(arg0, \u0026amp;mut buf)?; from_utf8_unchecked(filename_bytes) }; info!(\u0026amp;ctx, \u0026#34;function execve called by libc {}\u0026#34;, filename); Ok(0) } À l\u0026rsquo;époque ce n\u0026rsquo;était pas très clair dans mon esprit.\nExpliquons en détail ce code :\nla fonction helper bpf_probe_read_user_str_bytes() permet de lire l\u0026rsquo;adresse mémoire depuis l\u0026rsquo;espace utilisateur et de récupérer son contenu avec un slice d\u0026rsquo;octets. On a besoin d\u0026rsquo;un buffer pour cela. from_utf8_unchecked() permet de convertir un slice d\u0026rsquo;octets en un \u0026amp;str (la version sans vérification car sinon le verifier eBPF n\u0026rsquo;accepte pas) Pour finir, voici un petit schéma qui explique comment récupérer une chaine de caractères depuis l\u0026rsquo;espace utilisateur :\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Notez le nom de la fonction bpf_probe_read_user_str_bytes qui prend tout son sens pour une uProbe. Testons maintenant la modification # Vérifions que le code fonctionne toujours :\nRUST_LOG=info cargo run Sur un autre terminal, lançons une commande quelconque :\nls Sur le terminal cargo run vous verrez :\n[INFO test_uprobe_2] function execve called by libc /usr/bin/ls Nous étions resté à ce niveau là pour les articles d\u0026rsquo;initiation à eBPF avec Aya. Mais nous aurions également pu aller plus loin en récupérant les options de la commande et ses variables d\u0026rsquo;environnement. Voyons comment le faire.\nRécupérons les options de la commande # Testons avec bpftrace # Avant de le faire avec Aya, nous allons regarder comment le faire avec bpftrace. Pour récupérer le deuxième argument, on doit utiliser arg1. Comme arg1 est un pointeur de pointeur. On ne peut pas utiliser directement la fonction str(). Il faut déréférencer arg1 pour avoir un seul pointeur. Pour cela, il suffit d\u0026rsquo;utiliser *.\nCe qui nous fait :\nbpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;%s\\n\u0026#34;, str(*arg1)); }\u0026#39; On récupère alors le premier élément du tableau qui est le nom de la commande. Il faut donc se déplacer dans le tableau si on veut récupérer les différentes options. Chaque élément a une taille de 8 octets (uniquement valable en 64 bits).\nPour aller au deuxième élément du tableau, c\u0026rsquo;est à dire à la première option, il suffit de se déplacer de 8 octets (en ajoutant 8) :\nbpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;%s\\n\u0026#34;, str(*(arg1+8))); }\u0026#39; Vous allez voir que la difficulté va être sensiblement la même en Rust.\nModifions le code Aya # Avec Aya, pour récupérer le deuxième argument, il faut rajouter ce bout de code :\nlet argv: *const *const u8 = ctx.arg(1).ok_or(1u32)?; Comment récupérer la nième option de la commande ? Il faut utiliser la fonction add pour pouvoir décaler son pointeur vers la bonne adresse mémoire :\nPar exemple, pour récupérer la première option, on va décaler de 1 :\nlet argv1 = argv.add(1); \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rContrairement à bpftrace où il faut décaler du nombre d\u0026rsquo;octets (8 en 64 bits car 8x8=64 bits). La fonction add() permet de se déplacer d\u0026rsquo;addresse mémoire de 1 par 1 sans tenir compte de l\u0026rsquo;architecture. Par contre argv1 est encore de structure *const *const u8. Il faut maintenant déréférencer pour obtenir *const u8.\nIl y a une fonction toute prête pour cela :\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e La fonction helper bpf_probe_read_user permet de lire le contenu stocké dans le pointeur depuis l\u0026rsquo;espace utilisateur et de renvoyer une copie de sa valeur. On a donc :\nlet argv1_deref: *const u8 = bpf_probe_read_user(argv1)?; Maintenant que argv1_deref est de structure *const u8, il faut le transformer en \u0026amp;str. On se retrouve alors avec un code similaire à la récupération du nom du binaire. Ça serait probablement utile de créer une fonction pour un projet \u0026ldquo;sérieux\u0026rdquo;.\nVoici le code complet pour récupérer la première option :\nlet argv: *const *const u8 = ctx.arg(1).ok_or(0u32)?; //arg1 let mut buf = [0u8; 16]; let argname = unsafe { let argv1 = argv.add(1); //arg1+8 let argv1_deref: *const u8 = bpf_probe_read_user(argv1)?; //*(arg1+8) let argname_bytes = bpf_probe_read_user_str_bytes(argv1_deref, \u0026amp;mut buf)?; from_utf8_unchecked(argname_bytes) //str(*(arg1+8)) }; info!(\u0026amp;ctx, \u0026#34;function execve called by libc {}\u0026#34;, argname); //printf(\u0026#34;%s\\n\u0026#34;, str(*(arg1+8))); \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e En commentaire j\u0026rsquo;ai mis le code équivalent avec bpftrace. Testons maintenant la modification # Vérifions que le code fonctionne toujours :\nRUST_LOG=info cargo run Sur un autre terminal, lançons une commande avec une option :\nls -lrt Sur le terminal cargo run vous verrez :\n[INFO test_uprobe_2] function execve called by libc /usr/bin/ls [INFO test_uprobe_2] function execve called by libc -lrt C\u0026rsquo;est le comportement qu\u0026rsquo;on voulait.\nSi on lance une commande sans option que se passe-t-il ?\nman Sur le terminal cargo run vous ne verrez que :\n[INFO test_uprobe_2] function execve called by libc /usr/bin/man Que s\u0026rsquo;est-il passé ?\nCette partie du code ne s\u0026rsquo;est pas affichée :\ninfo!(\u0026amp;ctx, \u0026#34;function execve called by libc {}\u0026#34;, argname); Comme la commande n\u0026rsquo;a pas d\u0026rsquo;argument, cette partie du code est partie en erreur :\nlet argname = unsafe { let argv1 = argv.add(1); //arg1+8 let argv1_deref: *const u8 = bpf_probe_read_user(argv1)?; //*(arg1+8) let argname_bytes = bpf_probe_read_user_str_bytes(argv1_deref, \u0026amp;mut buf)?; from_utf8_unchecked(argname_bytes) //str(*(arg1+8)) }; Et donc le programme est parti en erreur et n\u0026rsquo;a jamais parcouru le dernier info.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rLa récupération des variables d\u0026rsquo;environnement de la commande est très similaire vu qu\u0026rsquo;il est du même type que pour les arguments. Cet épisode est maintenant terminé ! Nous avons vu comment récupérer les arguments d\u0026rsquo;une fonction d\u0026rsquo;un programme en C notamment pour des chaînes de caractères et des tableaux de chaînes de caractère et comment les afficher.\nDans le prochain épisode, nous allons voir comment profiler une fonction d\u0026rsquo;un programme.\n","date":"23 septembre 2025","externalUrl":null,"permalink":"/ebpf-another-type/uprobe/example-2/","section":"Ebpf-Another-Types","summary":"Sondons la fonction \u003ccode\u003eexecve\u003c/code\u003e dans la libc avec un programme eBPF de type uProve et avec Aya","title":"Sondons une bibliothèque avec une uProbe","type":"ebpf-another-type"},{"content":"","date":"15 septembre 2025","externalUrl":null,"permalink":"/tags/go/","section":"Tags","summary":"","title":"Go","type":"tags"},{"content":"Nous avons vu ce qu\u0026rsquo;était un programme de type uProbe dans la première partie : un moyen de sonder les fonctions de vos programmes.\nDans cette partie, nous allons d\u0026rsquo;abord créer un programme très simple en Go et nous allons le faire réagir avec deux programmes eBPF :\nLe premier de type uProbe Le deuxième de type uRetProbe \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rJe suppose que vous êtes déjà dans un environnement pour développer avec Aya et que vous avez installé le compilateur go et bpftrace. Si ce n\u0026rsquo;est pas le cas, vous pouvez utiliser le lab Killercoda :\nCréons un programme pour tester les uProbes # Un code tout simple # Pour changer du Rust, nous allons créer un petit programme en Go :\n// hello.go package main import \u0026#34;fmt\u0026#34; func hello() int { fmt.Println(\u0026#34;Hello, world!\u0026#34;) return 3 } func main() { ret := hello() fmt.Println(\u0026#34;Returned:\u0026#34;, ret) } \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rVous pouvez tester pour un autre programme compilé comme C/C++ ou Rust si vous préférez. Comment va-t-on activer des uProbes ? # Le but de l\u0026rsquo;article est d\u0026rsquo;activer :\nun programme eBPF de type uProbe à chaque fois que l\u0026rsquo;on rentre dans la fonction hello() : un programme eBPF de type uRetProbe à chaque fois que l\u0026rsquo;on sort de la fonction hello() : Maintenant qu\u0026rsquo;on a vu les tenants et les aboutissants de l\u0026rsquo;article, passons à la compilation du programme.\nCompilons le programme # Pour le compiler, il suffit de taper :\ngo build -gcflags=\u0026#34;all=-N -l\u0026#34; -o hello hello.go On peut remarquer qu\u0026rsquo;on a ajouté une option -gcflags=\u0026quot;all=-N -l\u0026quot;. Normalement, on n\u0026rsquo;a pas besoin d\u0026rsquo;utiliser cette option pour compiler un programme Go :\ngo build -o hello hello.go Cela fonctionne également. Mais alors pourquoi utiliser cette option ?\n-gcflags veut dire go compiler flags ce sont des options passées au compilateur Go. all permet de dire que les options s\u0026rsquo;appliquent à tous les packages compilés. Les options spécifiées au compilateur Go sont :\n-N : par défaut, le compilateur modifie (mangle) le nom de la fonction. Cette option permet de désactiver cette modification. En anglais, to mangle peut se traduire par modifier, mutiler ou même défigurer. En informatique, name mangling se traduit par décoration de nom. On a complètement gommé le côté péjoratif du terme ! -l : par défaut, le compilateur inline les fonctions c\u0026rsquo;est à dire qu\u0026rsquo;elle intègre directement le contenu de la fonction dans le code appelant permettant ainsi aux programmes d\u0026rsquo;être plus performants. Cette option permet de désactiver cet inline. Ainsi ces options vont nous permettre de garder les fonctions et de les rendre lisible, ce qui va nous simplifier pour trouver le point d\u0026rsquo;attache pour notre programme eBPF.\nComment trouver le point d\u0026rsquo;attache ? # Maintenant qu\u0026rsquo;on a créé et compilé le petit programme, il faut trouver comment déclencher le programme eBPF de type uProbe ou uRetProbe. Lorsqu\u0026rsquo;on utilise cargo generate pour le repo aya, il faut répondre à deux questions : où se trouve le nom du binaire et quelle fonction observée. Voyons cela en détail.\nNom du binaire # 🤷 Target to attach the (u|uret)probe? (e.g libc): Pour garantir la portabilité du programme eBPF, il faut répondre le chemin absolu du binaire. Par exemple je l\u0026rsquo;ai créé là : /home/cloud_user/hello.\nNom de la fonction # Une fois que tu as répondu à la première question, il reste une seconde question :\n🤷 Function name to attach the (u|uret)probe? (e.g getaddrinfo): Que faut-il répondre ? On serait tenté de répondre hello vu qu\u0026rsquo;on a mis l\u0026rsquo;option -N qui désactive la décoration de nom lors de la compilation.\nMais c\u0026rsquo;est un peu plus compliqué. Le compilateur Go modifie tout de même légèrement le nom de la fonction pendant l\u0026rsquo;étape de compilation.\nNous l\u0026rsquo;avons vu dans le précédent épisode pour trouver toutes les fonctions d\u0026rsquo;un binaire, il suffit d\u0026rsquo;utiliser bpftrace :\nbpftrace -l \u0026#39;uprobe:/home/cloud_user/hello:*\u0026#39; l\u0026rsquo;option -l permet de lister toutes les probes disponibles uprobe : le type de programme eBPF /home/cloud_user/hello : l\u0026rsquo;emplacement du binaire * : le joker (0 ou plusieurs caractères) Le format d\u0026rsquo;affichage est alors :\nuprobe:/home/cloud_user/hello:[fonction1] uprobe:/home/cloud_user/hello:[fonction2] uprobe:/home/cloud_user/hello:[fonction3] uprobe:/home/cloud_user/hello:[fonction4] etc C\u0026rsquo;est pas de bol : le nom de la fonction est le même que le nom de mon fichier\u0026hellip; On ne peut pas faire de | grep hello. Comment s\u0026rsquo;en sortir ? avec awk, cut ou pire une regex ? Faisons simple :\nbpftrace -l \u0026#39;uprobe:/home/cloud_user/hello:*hello*\u0026#39; Et ça va vous répondre :\nuprobe:/home/cloud_user/hello:main.hello Ainsi le nom réel de la fonction est main.hello\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Si vous ne pouvez pas installer bpftrace, vous pouvez utiliser la commande nm. Elle permet de voir tous les symboles qui sont présents dans un fichier binaire. Maintenant qu\u0026rsquo;on a la réponse aux deux questions, nous pouvons créer nos programmes eBPF.\nCommençons par le programme de type uProbe.\nCréons un programme eBPF de type uProbe # Testons avec bpftrace # Avant de foncer tête baissée sur un programme Aya, vérifions que ça fonctionne bien avec bpftrace, le programme qui crée en une ligne de commande un programme eBPF. Ça tombe bien : on a déjà trouvé le début dans la section précédente :\nuprobe:/home/cloud_user/hello:main.hello Il reste plus qu\u0026rsquo;à compléter par un hello world :\nsudo bpftrace -e \\ \u0026#39;uprobe:/home/cloud_user/hello:main.hello { printf(\u0026#34;Hello go\\n\u0026#34;); }\u0026#39; Historiquement, il fallait avoir les droits root pour installer un programme eBPF dans le noyau. Avec un Linux moderne, un utilisateur non root peut installer un programme eBPF avec juste quelques capacités supplémentaires comme CAP_BPF. Cependant bpftrace ne gère pas cela : il faut être en root. Dans un autre terminal, lançons alors le programme hello (sans les droits root) :\n./hello Sur le terminal où est lancé bpftrace, vous voyez Hello go à chaque fois que vous lancez le programme hello.\nVerifions qu\u0026rsquo;on peut créer un programme similaire avec Aya.\nGénération du programme Aya # Définissons déjà les différentes réponses pour le point d\u0026rsquo;attache dans des variables, pour mon cas ça sera :\ntarget=/home/cloud_user/hello fn_name=main.hello Lançons maintenant la commande pour générer le programme Aya :\ncargo generate --name test-uprobe \\ -d program_type=uprobe \\ -d uprobe_target=$target \\ -d uprobe_fn_name=$fn_name \\ https://github.com/aya-rs/aya-template Sans les options qu\u0026rsquo;on lui a indiqué, cargo generate fonctionnerait en mode interactif : on devrait répondre à des questions.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rPour trouver le nom des arguments (uprobe_target et uprobe_fn_name), vous pouvez regarder le fichier test.sh dans le repo aya-template. Vous aurez la sortie suivante :\n🔧 program_type: \u0026#34;uprobe\u0026#34; (value from CLI) 🔧 uprobe_target: \u0026#34;/home/cloud_user/hello\u0026#34; (value from CLI) 🔧 uprobe_fn_name: \u0026#34;main.hello\u0026#34; (value from CLI) 🔧 Destination: /home/cloud_user/test-uprobe ... 🔧 project-name: test-uprobe ... 🔧 Generating template ... [ 1/23] Done: .gitignore [ 2/23] Done: Cargo.toml [ 3/23] Done: LICENSE-APACHE [ 4/23] Done: LICENSE-GPL2 [ 5/23] Done: LICENSE-MIT [ 6/23] Done: README.md [ 7/23] Ignored: pre-script.rhai [ 8/23] Done: rustfmt.toml [ 9/23] Done: test-uprobe/Cargo.toml [10/23] Done: test-uprobe/build.rs [11/23] Done: test-uprobe/src/main.rs [12/23] Done: test-uprobe/src [13/23] Done: test-uprobe [14/23] Done: test-uprobe-common/Cargo.toml [15/23] Done: test-uprobe-common/src/lib.rs [16/23] Done: test-uprobe-common/src [17/23] Done: test-uprobe-common [18/23] Done: test-uprobe-ebpf/Cargo.toml [19/23] Done: test-uprobe-ebpf/build.rs [20/23] Done: test-uprobe-ebpf/src/lib.rs [21/23] Done: test-uprobe-ebpf/src/main.rs [22/23] Done: test-uprobe-ebpf/src [23/23] Done: test-uprobe-ebpf 🔧 Initializing a fresh Git repository ✨ Done! New project created /home/cloud_user/test-uprobe Compilation et installation dans le noyau # Maintenant qu\u0026rsquo;on a généré le programme, il faut compiler le programme et l\u0026rsquo;installer dans le noyau linux :\ncd test-uprobe/ RUST_LOG=info cargo run Pour simplifier, j\u0026rsquo;ai fait la compilation et l\u0026rsquo;installation du programme eBPF en root. Cela va prendre un peu de temps la première fois :\nUpdating crates.io index Locking 103 packages to latest compatible versions Adding which v6.0.3 (available: v8.0.0) Downloaded anstyle v1.0.11 Downloaded cfg-if v1.0.1 Downloaded anyhow v1.0.98 Downloaded either v1.15.0 Downloaded cargo_metadata v0.19.2 Downloaded version_check v0.9.5 Downloaded which v6.0.3 Downloaded socket2 v0.6.0 Downloaded mio v1.0.4 [...] warning: test-uprobe@0.1.0: Finished `release` profile [optimized] target(s) in 19.59s Finished `dev` profile [unoptimized + debuginfo] target(s) in 50.16s Running `/root/build-cache/debug/test-uprobe` Waiting for Ctrl-C... Testons maintenant # Laisser le programme Aya tourné et sur un autre terminal, lancer le programme que vous voulez examiner. Pour mon cas :\n./hello Sur le terminal où on a lancé la commande cargo run, Vous devriez voir la sortie suivante à chaque fois que vous lancez le programme :\n[INFO test_uprobe] function main.hello called by /home/cloud_user/hello Vous voyez que la difficulté est la même qu\u0026rsquo;avec bpftrace mais que le temps de compilation est beaucoup plus long.\nCréons un programme eBPF de type uRetProbe # Nous avons vu un exemple de programme eBPF de type uProbe où on n\u0026rsquo;avait pas à modifier le code généré. Nous allons maintenant complexifier légèrement avec un programme eBPF de type uRetProbe et nous allons récupérer la valeur de retour.\nTestons avec bpftrace # Le code bpftrace est alors légèrement modifié :\nsudo bpftrace -e \\ \u0026#39;uretprobe:/home/cloud_user/hello:main.hello { printf(\u0026#34;retval=%d\\n\u0026#34;, retval); }\u0026#39; uprobe est donc remplacé par uretprobe on a rajouté la variable de retour : retval Lancer le programme hello dans un autre terminal et vous verrez dans le terminal bpftrace :\nretval=3 Regardons comment produire le programme équivalent en Aya.\nGénération du programme Aya # La génération du code se fait de manière similaire qu\u0026rsquo;avec une uProbe :\ntarget=/home/cloud_user/hello fn_name=main.hello cargo generate --name test-uretprobe \\ -d program_type=uretprobe \\ -d uprobe_target=$target \\ -d uprobe_fn_name=$fn_name \\ https://github.com/aya-rs/aya-template Compilation et installation # De la même manière on va compiler et installer le programme eBPF :\ncd test-uretprobe/ RUST_LOG=info cargo run À la sortie de chaque fonction hello(), le programme eBPF affiche bien :\n[INFO test_uretprobe] function main.hello called by /home/cloud_user/hello Jusqu\u0026rsquo;à présent, nous avons fait un peu près la même chose que pour l\u0026rsquo;uProbe. Regardons maintenant comment récupérer la valeur de retour 3.\nModification du code # Il faut modifier le fichier test-uretprobe-ebpf/src/main.rs : le code de l\u0026rsquo;espace noyau. En particulier ce bout de code :\nfn try_test_uretprobe(ctx: RetProbeContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { info!(\u0026amp;ctx, \u0026#34;function main.hello called by /home/cloud_user/hello\u0026#34;); Ok(0) } Il faut voir comment utiliser la structure RetProbeContext pour afficher le code retour.\nRegardons la documentation :\nIl faut donc utiliser la méthode ret(). On va rajouter un truc comme ça :\nlet retval: u32 = ctx.ret().ok_or(1u32)?; \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Si la fonction n\u0026rsquo;a pas de retour on affiche 1u32 (entier non signé de 32 bits) car la signature de la fonction est Result\u0026lt;u32, u32\u0026gt;. Il faut également modifier la macro Aya info! pour afficher cette valeur.\nCe qui donne au final :\nfn try_test_uretprobe(ctx: RetProbeContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let retval: u32 = ctx.ret().ok_or(1u32)?; info!(\u0026amp;ctx, \u0026#34;retval={}\u0026#34;, retval); Ok(0) } Testons maintenant # Appliquons les modifications :\nRUST_LOG=info cargo run Lançons la commande hello dans un autre terminal :\n./hello Et du côté du programme Aya, on a l\u0026rsquo;affichage suivant :\n[INFO test_uretprobe] retval=3 Ce qui est cohérent avec ce qu\u0026rsquo;on avait trouvé avec bpftrace.\nCet épisode est maintenant terminé ! Nous avons vu les bases pour faire réagir un programme eBPF de type uProbe et uRetProbe lors du lancement d\u0026rsquo;un programme Go.\nCependant, nous n\u0026rsquo;avons pas encore exploré comment récupérer les arguments d\u0026rsquo;une fonction.\nÇa tombe bien ! Dans le prochain épisode, nous allons sonder une bibliothèque bien connue en récupérant les arguments de fonction et en les traitant !\n","date":"15 septembre 2025","externalUrl":null,"permalink":"/ebpf-another-type/uprobe/example-1/","section":"Ebpf-Another-Types","summary":"Observons un petit programme Go avec des programmes eBPF de type u•Ret•Probe et avec Aya","title":"Observons une fonction simple de ton programme avec des uProbes","type":"ebpf-another-type"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/tags/bpftrace/","section":"Tags","summary":"","title":"Bpftrace","type":"tags"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/tags/kprobe/","section":"Tags","summary":"","title":"Kprobe","type":"tags"},{"content":"Je débute la programmation en eBPF avec Aya. L’idée de cette série d’articles est d\u0026rsquo;apprendre un nouveau type de programme eBPF et de l\u0026rsquo;expérimenter avec le framework Rust Aya.\nAujourd\u0026rsquo;hui, nous allons nous plonger dans les uProbes et les uRetProbes : des programmes eBPF qui sondent les fonctions de l\u0026rsquo;espace utilisateur sans laisser de trace.\nVous allez voir que cela peut être très intéressant pour du profilage, du debug ou même de la rétro-ingénierie.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Si tu ne connais pas eBPF, je te conseille de lire les deux premières parties de ma série S’initier à eBPF avec Aya. Cela couvre les bases et t\u0026rsquo;aidera pour la suite de l\u0026rsquo;article. Qu\u0026rsquo;est-ce qu\u0026rsquo;une u•Ret•Probe ? # En anglais, une probe peut se traduire par une sonde pour examiner ou explorer quelque chose. En eBPF, il y en a de plusieurs types : kProbe, kRetProbe, uProbe, uRetProbe et USDT.\nkProbe : la sonde pour le kernel # Si tu consultes la documentation d\u0026rsquo;eBPF, il n\u0026rsquo;y a pas de section consacrée aux programmes de type uProbe ou uRetProbe. Mais il y en a une dédiée à la kProbe :\nLa kProbe a pour but d\u0026rsquo;observer des fonctions du kernel Linux. Elle peut être considérée comme la probe parente. Toutes les autres probes sont en fait le même type de programme BPF_PROG_TYPE_KPROBE mais c\u0026rsquo;est juste le point d\u0026rsquo;attache qui va déterminer comment le programme est exécuté.\nkRetProbe : retour sur la sonde kernel # La kRetProbe est simplement dédiée à l\u0026rsquo;observation du retour des fonctions du kernel Linux. Cette sonde permet ainsi de vérifier si l\u0026rsquo;appel de la fonction s\u0026rsquo;est bien terminé.\nNous avons vu brièvement kProbe et kRetProbe qui pourraient faire l\u0026rsquo;objet d\u0026rsquo;autres articles. Parlons maintenant des probes qui nous intéressent aujourd\u0026rsquo;hui : uProbe et uRetProbe.\nuProbe : la sonde pour les utilisateurs # Contrairement aux kProbes qui sont dédiées à observer les fonctions du kernel Linux, les uProbes sont dédiées aux fonctions de l\u0026rsquo;espace utilisateur : User-space Probes. Par exemple, on pourrait s\u0026rsquo;en servir pour compter le nombre d\u0026rsquo;appels aux fonctions malloc et free dans un programme C.\nuProbe permet également de récupérer le contenu des arguments de la fonction observée. Ainsi on pourrait regarder la quantité de mémoire allouée à chaque malloc ou vérifier que free libère réellement des bons pointeurs.\nAinsi les uProbes pourrait s\u0026rsquo;intégrer à une CI pour automatiser des vérifications de sécurité, faciliter le debogage ou aider au diagnostic mémoire.\n\u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rFree Medical icons\rÇa peut paraître paradoxal de vouloir tracer un code utilisateur depuis l\u0026rsquo;espace noyau. Cependant cela a le mérite d\u0026rsquo;être non intrusif car il n\u0026rsquo;y a pas besoin de modifier le programme. uRetProbe : retour sur la sonde utilisateur # De la même manière que la kRetProbe, uRetProbe a pour but d\u0026rsquo;étudier le retour de la fonction cible de l\u0026rsquo;espace utilisateur : User-space Return Probe. On peut donc découvrir la valeur que retourne la fonction. Cela permet ainsi de debugger ou d\u0026rsquo;observer le comportement final de la fonction.\nMais il y a un autre intérêt : en combinant les temps de l\u0026rsquo;uProbe et de l\u0026rsquo;uRetProbe, on peut récupérer la durée que met une fonction à s\u0026rsquo;exécuter assez facilement. Il est ainsi possible de profiler une fonction de son programme.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e file_type_sql On pourrait, par exemple, l\u0026rsquo;utiliser pour des requêtes SQL où on identifierait les requêtes les plus longues. Les uRetProbe et uProbes peuvent être utilisées pour débugger et comprendre un programme dont tu n\u0026rsquo;as pas le code source. Ça peut donc être un bel outil de rétro-ingénierie (reverse engineering).\nPar contre, elles sont limitées aux programmes dont le langage est compilé : C/C++, Rust, Go, etc. Si on a un programme développé avec un autre langage, USDT pourrait vous convenir. Parlons-en.\nUSDT : le tracepoint de l\u0026rsquo;espace utilisateur # USDT veut dire User Statically-Defined Tracing. Comme son nom l\u0026rsquo;indique, elle est également dédiée aux programmes de l\u0026rsquo;espace utilisateur mais il faut rajouter dans le code des sondes usdt pour les utiliser. USDT est, en fait, dérivée de l\u0026rsquo;uProbe.\nPar contre, elle est beaucoup plus précise que l\u0026rsquo;uProbe. En effet, la sonde uProbe est cantonnée au début de fonction alors que la sonde usdt peut être mise à n\u0026rsquo;importe quel endroit dans le code.\nVoici un exemple de code Python :\ndef benchmark_module(): loop = 0 for _ in range(100000): pyusdt.trace_start_loop(loop) calculate_pi(1000) pyusdt.trace_stop_loop(loop) loop += 1 Avec ce code, on peut avoir la durée pour calculer les 1000 décimales de π.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rAu moment de l\u0026rsquo;écriture, le framework Aya ne gère pas encore les programmes de type USDT. Nous allons maintenant nous consacrer pour la suite de l\u0026rsquo;article aux uProbes et uRetProbes. Parlons d\u0026rsquo;abord un peu de leur histoire.\nOrigin story # uTrace l\u0026rsquo;ancêtre # Vouloir tracer des fonctions de l\u0026rsquo;espace utilisateur depuis le noyau Linux ne date pas de l\u0026rsquo;introduction d\u0026rsquo;eBPF. Par exemple, une (première ?) tentative est apparue en 2007 avec les uTraces :\nMais elles n\u0026rsquo;ont jamais été incluses dans le code principal du fait d\u0026rsquo;opposition de certains mainteneurs.\nHabemus uProbe # Il a fallu attendre 2012 pour que le consensus finisse par arriver et les uProbes ont été introduites lors de la version 3.5 du noyau Linux :\nÀ l\u0026rsquo;époque, les uProbes étaient limités par rapport à celles qu\u0026rsquo;on connaît aujourd\u0026rsquo;hui.\nAinsi, elles ont ensuite été améliorées avec la version 3.14 (sortie en 2014, la même année que l\u0026rsquo;introduction d\u0026rsquo;eBPF) :\nCe patch a permis de récupérer un nombre plus important de données comme la valeur de retour d\u0026rsquo;une fonction.\nLes uProbes sont alors devenues pleinement exploitables alors qu\u0026rsquo;eBPF n\u0026rsquo;était pas encore sortie. Voyons quand son intégration s\u0026rsquo;est faite.\nuProbe avec eBPF # D\u0026rsquo;après la documentation d\u0026rsquo;eBPF, kProbe est apparue en 2015 dans la version 4.1 du noyau Linux. C\u0026rsquo;est Alexei Starovoitov, l\u0026rsquo;un des créateurs d\u0026rsquo;eBPF, qui l\u0026rsquo;a initié :\nComme une uProbe est une kProbe avec un point d\u0026rsquo;attache différent, on pouvait commencer à développer des uProbes avec eBPF à partir du 2 avril 2015.\nCependant, il fallait encore attendre que les frameworks eBPF de l\u0026rsquo;époque puissent le gérer.\nAinsi on pouvait déjà l\u0026rsquo;utiliser en 2016 avec BCC comme l\u0026rsquo;atteste le tutoriel de Brendan Gregg :\nOn peut voir également son issue sur GitHub datant d\u0026rsquo;octobre 2015 : Pour finir, voici une petite frise chronologique de l\u0026rsquo;histoire des uProbes :\n\u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rFree Medical icons\rLes uRetProbes ont été introduites de façon conjointe aux uProbes. Maintenant qu\u0026rsquo;uProbe a plus de 10 ans d\u0026rsquo;existence, on peut se poser une question bien légitime : est-elle encore utilisée et par quel projet ?\nQuels projets utilisent u•Ret•Probe ? # Pour défier le lieu commun : \u0026ldquo;eBPF c\u0026rsquo;est utilisé que par 3 grosses boîtes\u0026rdquo;, j\u0026rsquo;ai fait une petite recherche des outils qui utilisaient réellement les uProbes et que donc vous l\u0026rsquo;utilisiez peut-être sans le savoir\u0026hellip;\nPixie : where is my mind? # Le projet Pixie utilise uProbe notamment pour tracer les connexions TLS :\nD\u0026rsquo;ailleurs il y a un article de Douglas Mendez pour capturer le traffic HTTPs avec Aya.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rLe Projet Pixie est un outil d\u0026rsquo;observabilité pour les applications qui sont sur Kubernetes. Parca : l\u0026rsquo;hiver vient ! # Le projet Parca utilise également les uProbes.\nLe projet Parca est un outil de profilage \u0026ldquo;en continue\u0026rdquo; c\u0026rsquo;est à dire de façon systématique. Inspektor Gadget : hé là, qui va là? # Le projet Inspektor Gadget a créé des outils basés sur des uProbes et sur des sondes USDT depuis 2024 :\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rLe projet Inspektor Gadget fournit des outils (des gadgets) et un framework pour collecter les données et l\u0026rsquo;inspection du système sur Kubernetes. Bonus Track # Pour finir la présentation, je vous partage quelques liens bien sympathiques que j\u0026rsquo;ai trouvé lors de mes recherches sur les uProbes :\nUtilisation des uprobes sans eBPF par Brendan Gregg en 2015 : L\u0026rsquo;excellent article de blog de Julia Evans sur tous les systèmes de tracing sous Linux. Vous pouvez également lire son zine : Si les uProbes ne vous conviennent pas, peut-être que les bpftimes d\u0026rsquo;Eunomia peuvent vous intéresser : Maintenant qu\u0026rsquo;on a présenté uProbe et uRetProbe, voyons comment débuter son développement avec Aya.\nComment débuter son programme Aya ? # Quand on démarre le développement d\u0026rsquo;un nouveau programme eBPF, la première difficulté est de réussir à le démarrer. Pour cela, il a besoin d\u0026rsquo;un événement déclencheur (event-driven). Dans cet épisode, cet événement sera donc le passage d\u0026rsquo;une uProbe ou d\u0026rsquo;une uRetProbe dans le noyau Linux.\nAya nous facilite la tâche. Quand on lance la commande :\ncargo generate https://github.com/aya-rs/aya-template Tu devras répondre à deux questions importantes qui permettront de définir cet événement :\n🤷 Target to attach the (u|uret)probe? (e.g libc): 🤷 Function name to attach the (u|uret)probe? (e.g getaddrinfo): Voyons comment y répondre.\nCible pour attacher l\u0026rsquo;u•Ret•Probe # La première question demande le nom d\u0026rsquo;une bibliothèque (comme la libc) ou d\u0026rsquo;un binaire. La question aurait pu être posée autrement : quel fichier tu veux debugger ou tracer ?\nIl faut voir ça comme un filtre :\nSi tu choisis libc, le programme eBPF ne pourra démarrer que si un programme de la libc est exécuté Si tu choisis un binaire, il ne pourra démarrer que si le binaire est exécuté. Mais cela n\u0026rsquo;est pas suffisant pour démarrer le programme eBPF. Il faut être plus précis : donner le nom d\u0026rsquo;une fonction.\nNom de la fonction pour attacher l\u0026rsquo;u•Ret•Probe # La seconde question demande ainsi la fonction du binaire ou de la bibliothèque que tu veux débugger.\nPar exemple :\nsi tu choisis le nom d\u0026rsquo;une fonction d\u0026rsquo;un programme C, le programme eBPF sera lancé à chaque fois qu\u0026rsquo;il passe par cette fonction. si tu choisis une fonction de la libc, il ne sera lancé lorsqu\u0026rsquo;un programme appellera cette fonction de la libc. Si cela vous parait un peu trop théorique, nous allons finir le chapitre en parlant d\u0026rsquo;un outil bien sympathique qui va nous permettre d\u0026rsquo;illustrer cela.\nS\u0026rsquo;initier à eBPF avec bpftrace # Le projet bpftrace permet de créer rapidement la plupart des types de programme eBPF dédiés aux tracings dont notamment uProbe et uRetProbe mais également USDT, kProbe et kRetProbe (Voir la prise en charge ici).\nN\u0026rsquo;hésitez pas à l\u0026rsquo;installer, il est probablement packagé pour votre distribution Linux favorite.\nLe projet s\u0026rsquo;est fortement inspiré de DTrace, un outil de tracing créé à l\u0026rsquo;origine pour les unix comme Solaris, FreeBSD ou NetBSD au début des années 2000. Trève de bavardage, prenons un exemple :\nsudo bpftrace -e \\ \u0026#39;uretprobe:/bin/bash:readline { printf(\u0026#34;%s\\n\u0026#34;, str(retval)); }\u0026#39; Que veut dire cela ?\nuretprobe : le type de programme eBPF /bin/bash : le binaire cible readline : le nom de la fonction { printf(\u0026quot;%s\\n\u0026quot;, str(retval)); } : le code du programme bpftrace (il affiche la valeur retour de la fonction) Cette commande crée ainsi un programme eBPF de type uRetProbe avec comme point d\u0026rsquo;attache la fonction readline du binaire bash.\nSi vous avez vraiment lancé la commande, vous allez voir que cette création est quasi immédiate ! Vérifions qu\u0026rsquo;il fonctionne bien.\nDémarrez un autre terminal et lancez quelques commandes de ton choix. Voici un exemple de ce que vous pourrez voir sur le terminal bpftrace :\nAttaching 1 probe... ls -lrth hello man woman Vous voyez toutes les commandes que vous avez tapé sur le terminal !\nbpftrace peut ainsi être un bon moyen de prototyper un programme uProbe ou uRetProbe avant de le générer avec Aya.\nEt si je veux observer une autre fonction que readline dans le programme bash ? Comment faire ? Le premier reflexe serait d\u0026rsquo;aller dans le code de bash et de chercher une autre fonction mais il y a plus simple et plus sûr :\nbpftrace -l \u0026#39;uretprobe:/bin/bash:*\u0026#39; Cette commande va te lister toutes les fonctions disponibles dans bash.\nOn peut ainsi voir qu\u0026rsquo;on peut débugger 1670 fonctions dans bash : bpftrace -l 'uretprobe:/bin/bash:*' | wc -l Ainsi bpftrace va nous permetre pour la suite de vérifier la faisabilité avant de créer le programme en Rust avec Aya.\nDans cet épisode, on a vu les bases des uProbes et des uRetProbes : à quoi elles servent, leur histoire, qui les utilise et comment trouver le bon point d\u0026rsquo;accroche. Nous avons également vu bpftrace, un outil qui permet de créer des probes rapidement.\nNous allons maintenant passer à la pratique dans l\u0026rsquo;épisode suivant : on va créer un petit programme Go et on va le faire réagir avec des programmes eBPF de type uProbe et uRetProbe avec Aya.\n","date":"8 septembre 2025","externalUrl":null,"permalink":"/ebpf-another-type/uprobe/intro/","section":"Ebpf-Another-Types","summary":"Découverte des uProbes et uRetProbes eBPF avec Aya","title":"L’observabilité pour tous les développeurs avec les uProbes","type":"ebpf-another-type"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/tags/usdt/","section":"Tags","summary":"","title":"Usdt","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"}]