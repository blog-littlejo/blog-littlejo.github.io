[{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/en/series/getting-started-with-ebpf-uprobes-in-aya/","section":"Series","summary":"","title":"Getting Started With EBPF UProbes in Aya","type":"series"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/en/series/lets-learn-another-ebpf-program/","section":"Series","summary":"","title":"Let‚Äôs Learn Another EBPF Program","type":"series"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/series/apprenons-uprobe-avec-ebpf-et-aya/","section":"Series","summary":"","title":"Apprenons UProbe Avec EBPF Et Aya","type":"series"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/tags/aya/","section":"Tags","summary":"","title":"Aya","type":"tags"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/categories/development/","section":"Categories","summary":"","title":"Development","type":"categories"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/tags/ebpf/","section":"Tags","summary":"","title":"EBPF","type":"tags"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/ebpf-another-type/","section":"Ebpf-Another-Types","summary":"","title":"Ebpf-Another-Types","type":"ebpf-another-type"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/tags/go/","section":"Tags","summary":"","title":"Go","type":"tags"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/","section":"Le blog de Little Jo","summary":"","title":"Le blog de Little Jo","type":"page"},{"content":"Nous avons vu ce qu\u0026rsquo;√©tait un programme de type uProbe dans la premi√®re partie : un moyen de sonder les fonctions de vos programmes.\nDans cette partie, nous allons d\u0026rsquo;abord cr√©er un programme tr√®s simple en Go et nous allons le faire r√©agir avec deux programmes eBPF :\nLe premier de type uProbe Le deuxi√®me de type uRetProbe \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rJe suppose que vous √™tes d√©j√† dans un environnement pour d√©velopper avec Aya et que vous avez install√© le compilateur go et bpftrace. Si ce n\u0026rsquo;est pas le cas, vous pouvez utiliser le lab Killercoda :\nCr√©ons un programme pour tester les uProbes # Un code tout simple # Pour changer du Rust, nous allons cr√©er un petit programme en Go :\n// hello.go package main import \u0026#34;fmt\u0026#34; func hello() int { fmt.Println(\u0026#34;Hello, world!\u0026#34;) return 3 } func main() { ret := hello() fmt.Println(\u0026#34;Returned:\u0026#34;, ret) } \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rVous pouvez tester pour un autre programme compil√© comme C/C++ ou Rust si vous pr√©f√©rez. Comment va-t-on activer des uProbes ? # Le but de l\u0026rsquo;article est d\u0026rsquo;activer :\nun programme eBPF de type uProbe √† chaque fois que l\u0026rsquo;on rentre dans la fonction hello() : un programme eBPF de type uRetProbe √† chaque fois que l\u0026rsquo;on sort de la fonction hello() : Maintenant qu\u0026rsquo;on a vu les tenants et les aboutissants de l\u0026rsquo;article, passons √† la compilation du programme.\nCompilons le programme # Pour le compiler, il suffit de taper :\ngo build -gcflags=\u0026#34;all=-N -l\u0026#34; -o hello hello.go On peut remarquer qu\u0026rsquo;on a ajout√© une option -gcflags=\u0026quot;all=-N -l\u0026quot;. Normalement, on n\u0026rsquo;a pas besoin d\u0026rsquo;utiliser cette option pour compiler un programme Go :\ngo build -o hello hello.go Cela fonctionne √©galement. Mais alors pourquoi utiliser cette option ?\n-gcflags veut dire go compiler flags ce sont des options pass√©es au compilateur Go. all permet de dire que les options s\u0026rsquo;appliquent √† tous les packages compil√©s. Les options sp√©cifi√©es au compilateur Go sont :\n-N : par d√©faut, le compilateur modifie (mangle) le nom de la fonction. Cette option permet de d√©sactiver cette modification. En anglais, to mangle peut se traduire par modifier, mutiler ou m√™me d√©figurer. En informatique, name mangling se traduit par d√©coration de nom. On a compl√®tement gomm√© le c√¥t√© p√©joratif du terme ! -l : par d√©faut, le compilateur inline les fonctions c\u0026rsquo;est √† dire qu\u0026rsquo;elle int√®gre directement le contenu de la fonction dans le code appelant permettant ainsi aux programmes d\u0026rsquo;√™tre plus performants. Cette option permet de d√©sactiver cet inline. Ainsi ces options vont nous permettre de garder les fonctions et de les rendre lisible, ce qui va nous simplifier pour trouver le point d\u0026rsquo;attache pour notre programme eBPF.\nComment trouver le point d\u0026rsquo;attache ? # Maintenant qu\u0026rsquo;on a cr√©√© et compil√© le petit programme, il faut trouver comment d√©clencher le programme eBPF de type uProbe ou uRetProbe. Lorsqu\u0026rsquo;on utilise cargo generate pour le repo aya, il faut r√©pondre √† deux questions : o√π se trouve le nom du binaire et quelle fonction observ√©e. Voyons cela en d√©tail.\nNom du binaire # ü§∑ Target to attach the (u|uret)probe? (e.g libc): Pour garantir la portabilit√© du programme eBPF, il faut r√©pondre le chemin absolu du binaire. Par exemple je l\u0026rsquo;ai cr√©√© l√† : /home/cloud_user/hello.\nNom de la fonction # Une fois que tu as r√©pondu √† la premi√®re question, il reste une seconde question :\nü§∑ Function name to attach the (u|uret)probe? (e.g getaddrinfo): Que faut-il r√©pondre ? On serait tent√© de r√©pondre hello vu qu\u0026rsquo;on a mis l\u0026rsquo;option -N qui d√©sactive la d√©coration de nom lors de la compilation.\nMais c\u0026rsquo;est un peu plus compliqu√©. Le compilateur Go modifie tout de m√™me l√©g√®rement le nom de la fonction pendant l\u0026rsquo;√©tape de compilation.\nNous l\u0026rsquo;avons vu dans le pr√©c√©dent √©pisode pour trouver toutes les fonctions d\u0026rsquo;un binaire, il suffit d\u0026rsquo;utiliser bpftrace :\nbpftrace -l \u0026#39;uprobe:/home/cloud_user/hello:*\u0026#39; l\u0026rsquo;option -l permet de lister toutes les probes disponibles uprobe : le type de programme eBPF /home/cloud_user/hello : l\u0026rsquo;emplacement du binaire * : le joker (0 ou plusieurs caract√®res) Le format d\u0026rsquo;affichage est alors :\nuprobe:/home/cloud_user/hello:[fonction1] uprobe:/home/cloud_user/hello:[fonction2] uprobe:/home/cloud_user/hello:[fonction3] uprobe:/home/cloud_user/hello:[fonction4] etc C\u0026rsquo;est pas de bol : le nom de la fonction est le m√™me que le nom de mon fichier\u0026hellip; On ne peut pas faire de | grep hello. Comment s\u0026rsquo;en sortir ? avec awk, cut ou pire une regex ? Faisons simple :\nbpftrace -l \u0026#39;uprobe:/home/cloud_user/hello:*hello*\u0026#39; Et √ßa va vous r√©pondre :\nuprobe:/home/cloud_user/hello:main.hello Ainsi le nom r√©el de la fonction est main.hello\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Si vous ne pouvez pas installer bpftrace, vous pouvez utiliser la commande nm. Elle permet de voir tous les symboles qui sont pr√©sents dans un fichier binaire. Maintenant qu\u0026rsquo;on a la r√©ponse aux deux questions, nous pouvons cr√©er nos programmes eBPF.\nCommen√ßons par le programme de type uProbe.\nCr√©ons un programme eBPF de type uProbe # \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e Suite de l‚Äôarticle r√©serv√©e aux membres premium ‚ú®\nL‚Äôarticle complet est accessible uniquement aux membres premium.\nDevenir membre premium, c‚Äôest simple : il suffit de faire un petit don üíñ\nEn √©change, vous aurez pendant 1 an (offre early bird) :\nAcc√®s √† tous les articles complets d√®s leur publication Lecture anticip√©e avant la mise en ligne publique Participation au soutien de ce blog ind√©pendant Acc√®s exclusif √† mes photos de vacances √† Duba√Ø Votre don permet de :\nMe rendre moins d√©pendant des grandes plateformes M‚Äôencourager √† cr√©er plus de contenu technique Lever le paywall plus rapidement pour tous üëâ Devenir membre premium d√®s maintenant\n","date":"8 septembre 2025","externalUrl":null,"permalink":"/ebpf-another-type/uprobe/example-1-tr/","section":"Ebpf-Another-Types","summary":"Observons un petit programme Go avec des programmes eBPF de type u‚Ä¢Ret‚Ä¢Probe et avec Aya","title":"Observons une fonction simple de ton programme avec des uProbes","type":"ebpf-another-type"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/tags/rust/","section":"Tags","summary":"","title":"Rust","type":"tags"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/categories/teaser/","section":"Categories","summary":"","title":"Teaser","type":"categories"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/categories/tutorial/","section":"Categories","summary":"","title":"Tutorial","type":"categories"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/tags/uprobe/","section":"Tags","summary":"","title":"Uprobe","type":"tags"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/tags/uretprobe/","section":"Tags","summary":"","title":"Uretprobe","type":"tags"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/series/apprenons-un-autre-programme-ebpf/","section":"Series","summary":"","title":"Apprenons Un Autre Programme EBPF","type":"series"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/tags/bpftrace/","section":"Tags","summary":"","title":"Bpftrace","type":"tags"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/categories/introduction/","section":"Categories","summary":"","title":"Introduction","type":"categories"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/tags/kprobe/","section":"Tags","summary":"","title":"Kprobe","type":"tags"},{"content":"Je d√©bute la programmation en eBPF avec Aya. L‚Äôid√©e de cette s√©rie d‚Äôarticles est d\u0026rsquo;apprendre un nouveau type de programme eBPF et de l\u0026rsquo;exp√©rimenter avec le framework Rust Aya.\nAujourd\u0026rsquo;hui, nous allons nous plonger dans les uProbes et les uRetProbes : des programmes eBPF qui sondent les fonctions de l\u0026rsquo;espace utilisateur sans laisser de trace.\nVous allez voir que cela peut √™tre tr√®s int√©ressant pour du profilage, du debug ou m√™me de la r√©tro-ing√©nierie.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Si tu ne connais pas eBPF, je te conseille de lire les deux premi√®res parties de ma s√©rie S‚Äôinitier √† eBPF avec Aya. Cela couvre les bases et t\u0026rsquo;aidera pour la suite de l\u0026rsquo;article. Qu\u0026rsquo;est-ce qu\u0026rsquo;une u‚Ä¢Ret‚Ä¢Probe ? # En anglais, une probe peut se traduire par une sonde pour examiner ou explorer quelque chose. En eBPF, il y en a de plusieurs types : kProbe, kRetProbe, uProbe, uRetProbe et USDT.\nkProbe : la sonde pour le kernel # Si tu consultes la documentation d\u0026rsquo;eBPF, il n\u0026rsquo;y a pas de section consacr√©e aux programmes de type uProbe ou uRetProbe. Mais il y en a une d√©di√©e √† la kProbe :\nLa kProbe a pour but d\u0026rsquo;observer des fonctions du kernel Linux. Elle peut √™tre consid√©r√©e comme la probe parente. Toutes les autres probes sont en fait le m√™me type de programme BPF_PROG_TYPE_KPROBE mais c\u0026rsquo;est juste le point d\u0026rsquo;attache qui va d√©terminer comment le programme est ex√©cut√©.\nkRetProbe : retour sur la sonde kernel # La kRetProbe est simplement d√©di√©e √† l\u0026rsquo;observation du retour des fonctions du kernel Linux. Cette sonde permet ainsi de v√©rifier si l\u0026rsquo;appel de la fonction s\u0026rsquo;est bien termin√©.\nNous avons vu bri√®vement kProbe et kRetProbe qui pourraient faire l\u0026rsquo;objet d\u0026rsquo;autres articles. Parlons maintenant des probes qui nous int√©ressent aujourd\u0026rsquo;hui : uProbe et uRetProbe.\nuProbe : la sonde pour les utilisateurs # Contrairement aux kProbes qui sont d√©di√©es √† observer les fonctions du kernel Linux, les uProbes sont d√©di√©es aux fonctions de l\u0026rsquo;espace utilisateur : User-space Probes. Par exemple, on pourrait s\u0026rsquo;en servir pour compter le nombre d\u0026rsquo;appels aux fonctions malloc et free dans un programme C.\nuProbe permet √©galement de r√©cup√©rer le contenu des arguments de la fonction observ√©e. Ainsi on pourrait regarder la quantit√© de m√©moire allou√©e √† chaque malloc ou v√©rifier que free lib√®re r√©ellement des bons pointeurs.\nAinsi les uProbes pourrait s\u0026rsquo;int√©grer √† une CI pour automatiser des v√©rifications de s√©curit√©, faciliter le debogage ou aider au diagnostic m√©moire.\n\u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rFree Medical icons\r√áa peut para√Ætre paradoxal de vouloir tracer un code utilisateur depuis l\u0026rsquo;espace noyau. Cependant cela a le m√©rite d\u0026rsquo;√™tre non intrusif car il n\u0026rsquo;y a pas besoin de modifier le programme. uRetProbe : retour sur la sonde utilisateur # De la m√™me mani√®re que la kRetProbe, uRetProbe a pour but d\u0026rsquo;√©tudier le retour de la fonction cible de l\u0026rsquo;espace utilisateur : User-space Return Probe. On peut donc d√©couvrir la valeur que retourne la fonction. Cela permet ainsi de debugger ou d\u0026rsquo;observer le comportement final de la fonction.\nMais il y a un autre int√©r√™t : en combinant les temps de l\u0026rsquo;uProbe et de l\u0026rsquo;uRetProbe, on peut r√©cup√©rer la dur√©e que met une fonction √† s\u0026rsquo;ex√©cuter assez facilement. Il est ainsi possible de profiler une fonction de son programme.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e file_type_sql On pourrait, par exemple, l\u0026rsquo;utiliser pour des requ√™tes SQL o√π on identifierait les requ√™tes les plus longues. Les uRetProbe et uProbes peuvent √™tre utilis√©es pour d√©bugger et comprendre un programme dont tu n\u0026rsquo;as pas le code source. √áa peut donc √™tre un bel outil de r√©tro-ing√©nierie (reverse engineering).\nPar contre, elles sont limit√©es aux programmes dont le langage est compil√© : C/C++, Rust, Go, etc. Si on a un programme d√©velopp√© avec un autre langage, USDT pourrait vous convenir. Parlons-en.\nUSDT : le tracepoint de l\u0026rsquo;espace utilisateur # USDT veut dire User Statically-Defined Tracing. Comme son nom l\u0026rsquo;indique, elle est √©galement d√©di√©e aux programmes de l\u0026rsquo;espace utilisateur mais il faut rajouter dans le code des sondes usdt pour les utiliser. USDT est, en fait, d√©riv√©e de l\u0026rsquo;uProbe.\nPar contre, elle est beaucoup plus pr√©cise que l\u0026rsquo;uProbe. En effet, la sonde uProbe est cantonn√©e au d√©but de fonction alors que la sonde usdt peut √™tre mise √† n\u0026rsquo;importe quel endroit dans le code.\nVoici un exemple de code Python :\ndef benchmark_module(): loop = 0 for _ in range(100000): pyusdt.trace_start_loop(loop) calculate_pi(1000) pyusdt.trace_stop_loop(loop) loop += 1 Avec ce code, on peut avoir la dur√©e pour calculer les 1000 d√©cimales de œÄ.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rAu moment de l\u0026rsquo;√©criture, le framework Aya ne g√®re pas encore les programmes de type USDT. Nous allons maintenant nous consacrer pour la suite de l\u0026rsquo;article aux uProbes et uRetProbes. Parlons d\u0026rsquo;abord un peu de leur histoire.\nOrigin story # uTrace l\u0026rsquo;anc√™tre # Vouloir tracer des fonctions de l\u0026rsquo;espace utilisateur depuis le noyau Linux ne date pas de l\u0026rsquo;introduction d\u0026rsquo;eBPF. Par exemple, une (premi√®re ?) tentative est apparue en 2007 avec les uTraces :\nMais elles n\u0026rsquo;ont jamais √©t√© incluses dans le code principal du fait d\u0026rsquo;opposition de certains mainteneurs.\nHabemus uProbe # Il a fallu attendre 2012 pour que le consensus finisse par arriver et les uProbes ont √©t√© introduites lors de la version 3.5 du noyau Linux :\n√Ä l\u0026rsquo;√©poque, les uProbes √©taient limit√©s par rapport √† celles qu\u0026rsquo;on conna√Æt aujourd\u0026rsquo;hui.\nAinsi, elles ont ensuite √©t√© am√©lior√©es avec la version 3.14 (sortie en 2014, la m√™me ann√©e que l\u0026rsquo;introduction d\u0026rsquo;eBPF) :\nCe patch a permis de r√©cup√©rer un nombre plus important de donn√©es comme la valeur de retour d\u0026rsquo;une fonction.\nLes uProbes sont alors devenues pleinement exploitables alors qu\u0026rsquo;eBPF n\u0026rsquo;√©tait pas encore sortie. Voyons quand son int√©gration s\u0026rsquo;est faite.\nuProbe avec eBPF # D\u0026rsquo;apr√®s la documentation d\u0026rsquo;eBPF, kProbe est apparue en 2015 dans la version 4.1 du noyau Linux. C\u0026rsquo;est Alexei Starovoitov, l\u0026rsquo;un des cr√©ateurs d\u0026rsquo;eBPF, qui l\u0026rsquo;a initi√© :\nComme une uProbe est une kProbe avec un point d\u0026rsquo;attache diff√©rent, on pouvait commencer √† d√©velopper des uProbes avec eBPF √† partir du 2 avril 2015.\nCependant, il fallait encore attendre que les frameworks eBPF de l\u0026rsquo;√©poque puissent le g√©rer.\nAinsi on pouvait d√©j√† l\u0026rsquo;utiliser en 2016 avec BCC comme l\u0026rsquo;atteste le tutoriel de Brendan Gregg :\nOn peut voir √©galement son issue sur GitHub datant d\u0026rsquo;octobre 2015 : Pour finir, voici une petite frise chronologique de l\u0026rsquo;histoire des uProbes :\n\u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rFree Medical icons\rLes uRetProbes ont √©t√© introduites de fa√ßon conjointe aux uProbes. Maintenant qu\u0026rsquo;uProbe a plus de 10 ans d\u0026rsquo;existence, on peut se poser une question bien l√©gitime : est-elle encore utilis√©e et par quel projet ?\nQuels projets utilisent u‚Ä¢Ret‚Ä¢Probe ? # Pour d√©fier le lieu commun : \u0026ldquo;eBPF c\u0026rsquo;est utilis√© que par 3 grosses bo√Ætes\u0026rdquo;, j\u0026rsquo;ai fait une petite recherche des outils qui utilisaient r√©ellement les uProbes et que donc vous l\u0026rsquo;utilisiez peut-√™tre sans le savoir\u0026hellip;\nPixie : where is my mind? # Le projet Pixie utilise uProbe notamment pour tracer les connexions TLS :\nD\u0026rsquo;ailleurs il y a un article de Douglas Mendez pour capturer le traffic HTTPs avec Aya.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rLe Projet Pixie est un outil d\u0026rsquo;observabilit√© pour les applications qui sont sur Kubernetes. Parca : l\u0026rsquo;hiver vient ! # Le projet Parca utilise √©galement les uProbes.\nLe projet Parca est un outil de profilage \u0026ldquo;en continue\u0026rdquo; c\u0026rsquo;est √† dire de fa√ßon syst√©matique. Inspektor Gadget : h√© l√†, qui va l√†? # Le projet Inspektor Gadget a cr√©√© des outils bas√©s sur des uProbes et sur des sondes USDT depuis 2024 :\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rLe projet Inspektor Gadget fournit des outils (des gadgets) et un framework pour collecter les donn√©es et l\u0026rsquo;inspection du syst√®me sur Kubernetes. Bonus Track # Pour finir la pr√©sentation, je vous partage quelques liens bien sympathiques que j\u0026rsquo;ai trouv√© lors de mes recherches sur les uProbes :\nUtilisation des uprobes sans eBPF par Brendan Gregg en 2015 : L\u0026rsquo;excellent article de blog de Julia Evans sur tous les syst√®mes de tracing sous Linux. Vous pouvez √©galement lire son zine : Si les uProbes ne vous conviennent pas, peut-√™tre que les bpftimes d\u0026rsquo;Eunomia peuvent vous int√©resser : Maintenant qu\u0026rsquo;on a pr√©sent√© uProbe et uRetProbe, voyons comment d√©buter son d√©veloppement avec Aya.\nComment d√©buter son programme Aya ? # Quand on d√©marre le d√©veloppement d\u0026rsquo;un nouveau programme eBPF, la premi√®re difficult√© est de r√©ussir √† le d√©marrer. Pour cela, il a besoin d\u0026rsquo;un √©v√©nement d√©clencheur (event-driven). Dans cet √©pisode, cet √©v√©nement sera donc le passage d\u0026rsquo;une uProbe ou d\u0026rsquo;une uRetProbe dans le noyau Linux.\nAya nous facilite la t√¢che. Quand on lance la commande :\ncargo generate https://github.com/aya-rs/aya-template Tu devras r√©pondre √† deux questions importantes qui permettront de d√©finir cet √©v√©nement :\nü§∑ Target to attach the (u|uret)probe? (e.g libc): ü§∑ Function name to attach the (u|uret)probe? (e.g getaddrinfo): Voyons comment y r√©pondre.\nCible pour attacher l\u0026rsquo;u‚Ä¢Ret‚Ä¢Probe # La premi√®re question demande le nom d\u0026rsquo;une biblioth√®que (comme la libc) ou d\u0026rsquo;un binaire. La question aurait pu √™tre pos√©e autrement : quel fichier tu veux debugger ou tracer ?\nIl faut voir √ßa comme un filtre :\nSi tu choisis libc, le programme eBPF ne pourra d√©marrer que si un programme de la libc est ex√©cut√© Si tu choisis un binaire, il ne pourra d√©marrer que si le binaire est ex√©cut√©. Mais cela n\u0026rsquo;est pas suffisant pour d√©marrer le programme eBPF. Il faut √™tre plus pr√©cis : donner le nom d\u0026rsquo;une fonction.\nNom de la fonction pour attacher l\u0026rsquo;u‚Ä¢Ret‚Ä¢Probe # La seconde question demande ainsi la fonction du binaire ou de la biblioth√®que que tu veux d√©bugger.\nPar exemple :\nsi tu choisis le nom d\u0026rsquo;une fonction d\u0026rsquo;un programme C, le programme eBPF sera lanc√© √† chaque fois qu\u0026rsquo;il passe par cette fonction. si tu choisis une fonction de la libc, il ne sera lanc√© lorsqu\u0026rsquo;un programme appellera cette fonction de la libc. Si cela vous parait un peu trop th√©orique, nous allons finir le chapitre en parlant d\u0026rsquo;un outil bien sympathique qui va nous permettre d\u0026rsquo;illustrer cela.\nS\u0026rsquo;initier √† eBPF avec bpftrace # Le projet bpftrace permet de cr√©er rapidement la plupart des types de programme eBPF d√©di√©s aux tracings dont notamment uProbe et uRetProbe mais √©galement USDT, kProbe et kRetProbe (Voir la prise en charge ici).\nN\u0026rsquo;h√©sitez pas √† l\u0026rsquo;installer, il est probablement packag√© pour votre distribution Linux favorite.\nLe projet s\u0026rsquo;est fortement inspir√© de DTrace, un outil de tracing cr√©√© √† l\u0026rsquo;origine pour les unix comme Solaris, FreeBSD ou NetBSD au d√©but des ann√©es 2000. Tr√®ve de bavardage, prenons un exemple :\nsudo bpftrace -e \\ \u0026#39;uretprobe:/bin/bash:readline { printf(\u0026#34;%s\\n\u0026#34;, str(retval)); }\u0026#39; Que veut dire cela ?\nuretprobe : le type de programme eBPF /bin/bash : le binaire cible readline : le nom de la fonction { printf(\u0026quot;%s\\n\u0026quot;, str(retval)); } : le code du programme bpftrace (il affiche la valeur retour de la fonction) Cette commande cr√©e ainsi un programme eBPF de type uRetProbe avec comme point d\u0026rsquo;attache la fonction readline du binaire bash.\nSi vous avez vraiment lanc√© la commande, vous allez voir que cette cr√©ation est quasi imm√©diate ! V√©rifions qu\u0026rsquo;il fonctionne bien.\nD√©marrez un autre terminal et lancez quelques commandes de ton choix. Voici un exemple de ce que vous pourrez voir sur le terminal bpftrace :\nAttaching 1 probe... ls -lrth hello man woman Vous voyez toutes les commandes que vous avez tap√© sur le terminal !\nbpftrace peut ainsi √™tre un bon moyen de prototyper un programme uProbe ou uRetProbe avant de le g√©n√©rer avec Aya.\nEt si je veux observer une autre fonction que readline dans le programme bash ? Comment faire ? Le premier reflexe serait d\u0026rsquo;aller dans le code de bash et de chercher une autre fonction mais il y a plus simple et plus s√ªr :\nbpftrace -l \u0026#39;uretprobe:/bin/bash:*\u0026#39; Cette commande va te lister toutes les fonctions disponibles dans bash.\nOn peut ainsi voir qu\u0026rsquo;on peut d√©bugger 1670 fonctions dans bash : bpftrace -l 'uretprobe:/bin/bash:*' | wc -l Ainsi bpftrace va nous permetre pour la suite de v√©rifier la faisabilit√© avant de cr√©er le programme en Rust avec Aya.\nDans cet √©pisode, on a vu les bases des uProbes et des uRetProbes : √† quoi elles servent, leur histoire, qui les utilise et comment trouver le bon point d\u0026rsquo;accroche. Nous avons √©galement vu bpftrace, un outil qui permet de cr√©er des probes rapidement.\nNous allons maintenant passer √† la pratique dans l\u0026rsquo;√©pisode suivant : on va cr√©er un petit programme Go et on va le faire r√©agir avec des programmes eBPF de type uProbe et uRetProbe avec Aya.\n","date":"8 septembre 2025","externalUrl":null,"permalink":"/ebpf-another-type/uprobe/intro/","section":"Ebpf-Another-Types","summary":"D√©couverte des uProbes et uRetProbes eBPF avec Aya","title":"L‚Äôobservabilit√© pour tous les d√©veloppeurs avec les uProbes","type":"ebpf-another-type"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/tags/usdt/","section":"Tags","summary":"","title":"Usdt","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"}]