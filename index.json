[{"content":"","date":"29 octobre 2025","externalUrl":null,"permalink":"/ebpf-another-type/","section":"Ebpf-Another-Types","summary":"","title":"Ebpf-Another-Types","type":"ebpf-another-type"},{"content":"","date":"29 octobre 2025","externalUrl":null,"permalink":"/","section":"Le blog de Little Jo","summary":"","title":"Le blog de Little Jo","type":"page"},{"content":"","date":"29 octobre 2025","externalUrl":null,"permalink":"/en/series/getting-started-with-xdp-in-aya/","section":"Series","summary":"","title":"Getting Started With XDP in Aya","type":"series"},{"content":"","date":"29 octobre 2025","externalUrl":null,"permalink":"/series/apprenons-xdp-avec-aya/","section":"Series","summary":"","title":"Apprenons XDP Avec Aya","type":"series"},{"content":"Nous avons vu ce qu\u0026rsquo;√©tait un programme XDP dans la premi√®re partie : cela peut √™tre un moyen de limiter les attaques par d√©ni de service distribu√©.\nDans cette partie, je vous propose de cr√©er un programme XDP qui va limiter les attaques par SYN flood. On va faire cela avec le framework Rust Aya.\nSuivez le guide !\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rlab\rJe suppose que vous √™tes d√©j√† dans un environnement pour d√©velopper avec Aya. Si ce n\u0026rsquo;est pas le cas, vous pouvez utiliser le lab Killercoda :\nCr√©ons un petit tcpdump avec XDP # Avant de faire cela, nous allons d√©j√† expliquer comment on analyse un segment TCP avec XDP et ainsi r√©cup√©rer les paquets SYN. Au fait, vous vous rappelez comment fonctionne TCP ?\nLes connexions TCP # TCP est l\u0026rsquo;acronyme de Transmission Control Protocol. C\u0026rsquo;est probablement le protocole r√©seau le plus utilis√© par les protocoles applicatifs : HTTP, SSH, etc. Difficile de faire l\u0026rsquo;impasse pour des articles sur du r√©seau. Cependant c\u0026rsquo;est probablement le plus complexe si on compare √† UDP ou √† ICMP.\nAvant le t√©l√©chargement des donn√©es utiles, il y a une phase de connexion (3-way handshake) permettant d\u0026rsquo;√©tablir un canal fiable.\nQu\u0026rsquo;est-ce que le SYN Flood ? # SYN est le premier segment TCP qui sert √† initier une connexion TCP. Quand un serveur re√ßoit un SYN, il doit renvoyer un SYN-ACK pour accuser de r√©ception. Une fois cela, le client doit confirmer par un ACK et le t√©l√©chargement des donn√©es peut enfin op√©rer.\nSupposons qu\u0026rsquo;un client envoie une connexion SYN mais ne r√©pond jamais, que se passe-t-il ?\nLe serveur envoie un SYN-ACK en r√©ponse puis r√©essaie 5 fois (valeur par d√©faut) Le serveur ferme enfin la connexion incompl√®te Supposons qu\u0026rsquo;un client innonde de plein de connexions SYN mais ne r√©pond jamais, que se passe-t-il ?\nLe serveur garde alors plein de connexions \u0026ldquo;en attente\u0026rdquo; (dont certain probablement l√©gitime) Le serveur continue de renvoyer les SYN-ACK jusqu\u0026rsquo;√† saturer ses ressources m√©moire C\u0026rsquo;est √ßa le principe d\u0026rsquo;une attaque SYN Flood.\nDans cet article, pour contrer cette attaque, on va compter le nombre de SYN par IP et s\u0026rsquo;il y en a trop on bloque temporairement ces segments pour cette IP.\nComment voir les d√©tails des segments # Si ce n\u0026rsquo;est pas d√©j√† fait, recr√©ons l\u0026rsquo;environnement de d√©veloppement\ngit clone https://github.com/littlejo/eunomia.dev cd eunomia.dev/docs/tutorials/42-xdp-loadbalancer/ ./setup.sh D√©marrons un petit serveur web au niveau du namespace lb :\nip netns exec lb python3 -m http.server 8080 Sur l\u0026rsquo;interface veth6, nous verrons les paquets TCP qui sont envoy√©s par le client (comme SYN) ; Sur l\u0026rsquo;interface veth7, nous verrons les paquets TCP qui sont envoy√©s par le serveur (comme SYN-ACK). Nous devons donc installer le programme eBPF sur veth6.\nG√©n√©rons le programme Aya :\ncargo generate --name antiddos-xdp \\ -d program_type=xdp \\ -d default_iface=veth6 \\ https://github.com/aya-rs/aya-template cd antiddos-xdp En pr√©vision, nous allons utiliser des crates suppl√©mentaires :\naya-ebpf-bindings pour les bindings suppl√©mentaires eBPF network-types pour les structures Rust des en-t√™tes de niveau 1, 2 et 3 blog-xdp, la crate de ce blog, pour ne pas copier/coller des fonctions helpers pr√©c√©demment √©crites On va donc modifier le fichier antiddos-xdp-ebpf/Cargo.toml et rajouter dans la section dependencies :\naya-ebpf-bindings = \u0026#34;0.1.1\u0026#34; network-types = \u0026#34;0.1.0\u0026#34; blog-xdp = { git = \u0026#34;https://github.com/littlejo/blog-xdp\u0026#34; } V√©rifions que le programme g√©n√©r√© fonctionne bien :\nOn va d√©j√† construire le binaire :\ncargo build Puis on va installer dans le namespace cible o√π se trouve l\u0026rsquo;interface veth6 :\nip netns exec lb cargo run Comme le namespace n\u0026rsquo;a pas acc√®s √† Internet, il faut commencer par t√©l√©charger les crates pour les compiler au niveau du serveur puis installer le programme eBPF au niveau du namespace. On va maintenant r√©cup√©rer uniquement les paquets TCP dans le programme eBPF. On va modifier le fichier antiddos-xdp-ebpf/src/main.rs. On se retrouve avec un code similaire au code de la partie pr√©c√©dente :\nuse network_types::{ eth::{EthHdr, EtherType}, ip::{Ipv4Hdr, IpProto}, tcp::TcpHdr, }; use blog_xdp::helper::ptr_at; fn try_antiddos_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0)?; match unsafe { (*ethhdr).ether_type() } { Ok(EtherType::Ipv4) =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } let ipv4hdr: *const Ipv4Hdr = ptr_at(\u0026amp;ctx, EthHdr::LEN)? ; match unsafe { (*ipv4hdr).proto } { IpProto::Tcp =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } let tcphdr: *const TcpHdr = ptr_at(\u0026amp;ctx, EthHdr::LEN + Ipv4Hdr::LEN)? ; let src_addr = unsafe { (*ipv4hdr).src_addr }; let dst_addr = unsafe { (*ipv4hdr).dst_addr }; info!(\u0026amp;ctx, \u0026#34;src:{:i} =\u0026gt; dst:{:i}\u0026#34;, src_addr, dst_addr); Ok(xdp_action::XDP_PASS) } On peut tester que √ßa fonctionne :\nip netns exec lb cargo run Verifions avec cette commande pour tester le programme XDP :\ncurl 10.0.0.10:8080 Au niveau de cargo, on voit alors plusieurs paquets pass√©s :\n[INFO antiddos_xdp] src:10.0.0.1 =\u0026gt; dst:10.0.0.10 [INFO antiddos_xdp] src:10.0.0.1 =\u0026gt; dst:10.0.0.10 [INFO antiddos_xdp] src:10.0.0.1 =\u0026gt; dst:10.0.0.10 [INFO antiddos_xdp] src:10.0.0.1 =\u0026gt; dst:10.0.0.10 [INFO antiddos_xdp] src:10.0.0.1 =\u0026gt; dst:10.0.0.10 [INFO antiddos_xdp] src:10.0.0.1 =\u0026gt; dst:10.0.0.10 Ce que j\u0026rsquo;expliquais au d√©but, quand on lance une connexion TCP, il n\u0026rsquo;y a pas qu\u0026rsquo;un paquet mais plusieurs paquets.\nOn voit seulement les paquets qui sont envoy√©s par le client (ceux en ingress).\nSi on veut voir les paquets qui sont envoy√©s par le serveur, il faut installer le programme sur l\u0026rsquo;interface veth7. C\u0026rsquo;est tout simple, en surchargeant la variable iface :\ncargo run -- --iface veth7 Pour afficher un peu plus de d√©tails sur la nature des paquets, regardons maintenant l\u0026rsquo;en-t√™te du segment TCP :\nPour les puristes, le sch√©ma est un peu simplifi√©.\nVoyons bri√®vement √† quoi servent les principales donn√©es :\nSRC/DST PORT : les ports de TCP SEQUENCE/ACK NUMBER : pour le suivi des connexions BITFIELD : c\u0026rsquo;est l√† o√π on d√©finit la nature du segment (SYN, ACK, etc) WINDOW : pour le contr√¥le de flux (utile pour les gros fichiers) CHECKSUM : pour l\u0026rsquo;int√©grit√© du segment Comme pour UDP, on peut donc facilement r√©cup√©rer les √©l√©ments en regardant la documentation de la crate network-types :\nPour r√©cup√©rer la nature du segment, il y a m√™me des fonctions pour nous aider :\nPour reproduire un petit tcpdump, ajoutons cela par exemple :\nlet src_port = u16::from_be_bytes(unsafe { (*tcphdr).source }); let dst_port = u16::from_be_bytes(unsafe { (*tcphdr).dest }); let seq = u32::from_be_bytes(unsafe {(*tcphdr).seq}); let ack_seq = u32::from_be_bytes(unsafe {(*tcphdr).ack_seq}); let syn = unsafe {(*tcphdr).syn()}; let ack = unsafe {(*tcphdr).ack()}; let psh = unsafe {(*tcphdr).psh()}; let fin = unsafe {(*tcphdr).fin()}; info!(\u0026amp;ctx, \u0026#34;seq: {}, ack_seq: {}, syn: {}, ack: {}, data: {}, fin: {}, src: {:i}:{}, dst: {:i}:{}\u0026#34;, seq, ack_seq, syn, ack, psh, fin, src_addr, src_port, dst_addr, dst_port); Installons ce programme sur les deux interfaces r√©seaux :\nip netns exec lb cargo run cargo run -- --iface veth7 Lan√ßons une connexion :\ncurl 10.0.0.10:8080 Au niveau de veth6, on voit alors les d√©tails des diff√©rents segments :\n[INFO antiddos_xdp] seq: 2481734691, ack_seq: 0, syn: 1, ack: 0, data: 0, fin: 0, src: 10.0.0.1:47632, dst: 10.0.0.10:8080 [INFO antiddos_xdp] seq: 2481734692, ack_seq: 161636304, syn: 0, ack: 1, data: 0, fin: 0, src: 10.0.0.1:47632, dst: 10.0.0.10:8080 [INFO antiddos_xdp] seq: 2481734692, ack_seq: 161636304, syn: 0, ack: 1, data: 1, fin: 0, src: 10.0.0.1:47632, dst: 10.0.0.10:8080 [INFO antiddos_xdp] seq: 2481734769, ack_seq: 161636460, syn: 0, ack: 1, data: 0, fin: 0, src: 10.0.0.1:47632, dst: 10.0.0.10:8080 [INFO antiddos_xdp] seq: 2481734769, ack_seq: 161637894, syn: 0, ack: 1, data: 0, fin: 0, src: 10.0.0.1:47632, dst: 10.0.0.10:8080 [INFO antiddos_xdp] seq: 2481734769, ack_seq: 161637894, syn: 0, ack: 1, data: 0, fin: 1, src: 10.0.0.1:47632, dst: 10.0.0.10:8080 [INFO antiddos_xdp] seq: 2481734770, ack_seq: 161637895, syn: 0, ack: 1, data: 0, fin: 0, src: 10.0.0.1:47632, dst: 10.0.0.10:8080 Au niveau de veth7 :\n[INFO antiddos_xdp] seq: 161636303, ack_seq: 2481734692, syn: 1, ack: 1, data: 0, fin: 0, src: 10.0.0.10:8080, dst: 10.0.0.1:47632, [INFO antiddos_xdp] seq: 161636304, ack_seq: 2481734769, syn: 0, ack: 1, data: 0, fin: 0, src: 10.0.0.10:8080, dst: 10.0.0.1:47632, [INFO antiddos_xdp] seq: 161636304, ack_seq: 2481734769, syn: 0, ack: 1, data: 1, fin: 0, src: 10.0.0.10:8080, dst: 10.0.0.1:47632, [INFO antiddos_xdp] seq: 161636460, ack_seq: 2481734769, syn: 0, ack: 1, data: 1, fin: 0, src: 10.0.0.10:8080, dst: 10.0.0.1:47632, [INFO antiddos_xdp] seq: 161637894, ack_seq: 2481734769, syn: 0, ack: 1, data: 0, fin: 1, src: 10.0.0.10:8080, dst: 10.0.0.1:47632, [INFO antiddos_xdp] seq: 161637895, ack_seq: 2481734770, syn: 0, ack: 1, data: 0, fin: 0, src: 10.0.0.10:8080, dst: 10.0.0.1:47632, Maintenant qu\u0026rsquo;on a vu tous les d√©tails d\u0026rsquo;un segment TCP, on va maintenant s\u0026rsquo;occuper uniquement des segments de type SYN :\nmatch unsafe { (*tcphdr).syn() } { 1 =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } Si on a affaire √† un SYN, on continue le traitement sinon on laisse passer le paquet.\nComme nous n\u0026rsquo;allons plus toucher √† cette partie du code, nous allons cr√©er une fonction :\n#[inline(always)] fn filter_tcp_syn_src(ctx: \u0026amp;XdpContext) -\u0026gt; Option\u0026lt;[u8; 4]\u0026gt; { let ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0).ok()?; match unsafe { (*ethhdr).ether_type() } { Ok(EtherType::Ipv4) =\u0026gt; {} _ =\u0026gt; return None, } let ipv4hdr: *const Ipv4Hdr = ptr_at(\u0026amp;ctx, EthHdr::LEN).ok()? ; match unsafe { (*ipv4hdr).proto } { IpProto::Tcp =\u0026gt; {} _ =\u0026gt; return None, } let tcphdr: *const TcpHdr = ptr_at(\u0026amp;ctx, EthHdr::LEN + Ipv4Hdr::LEN).ok()? ; match unsafe { (*tcphdr).syn() } { 1 =\u0026gt; {} _ =\u0026gt; return None, } let src_addr = unsafe { (*ipv4hdr).src_addr }; Some(src_addr) } fn try_antiddos_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let src_addr = match filter_tcp_syn_src(\u0026amp;ctx) { Some(x) =\u0026gt; x, None =\u0026gt; return Ok(xdp_action::XDP_PASS), }; info!(ctx, \u0026#34;{}\u0026#34;, src_addr); Ok(xdp_action::XDP_PASS) } Nous r√©cup√©rons uniquement l\u0026rsquo;IP source de cette fonction pour potentiellement la bloquer.\nCela va nous permettre de nous concentrer sur le code pour emp√™cher l\u0026rsquo;attaque.\nEssayons d\u0026rsquo;att√©nuer les attaques SYN flood # \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e Suite de l‚Äôarticle r√©serv√©e aux membres premium ‚ú®\nL‚Äôarticle complet est accessible uniquement aux membres premium.\nDevenir membre premium, c‚Äôest simple : il suffit de faire un petit don üíñ\nEn √©change, vous aurez pendant 1 an (offre early bird) :\nAcc√®s √† tous les articles complets d√®s leur publication Lecture anticip√©e avant la mise en ligne publique Participation au soutien de ce blog ind√©pendant Acc√®s exclusif √† mes photos de vacances √† Duba√Ø Votre don permet de :\nMe rendre moins d√©pendant des grandes plateformes M‚Äôencourager √† cr√©er plus de contenu technique Lever le paywall plus rapidement pour tous üëâ Devenir membre premium d√®s maintenant\n","date":"29 octobre 2025","externalUrl":null,"permalink":"/ebpf-another-type/xdp/example-2-tr/","section":"Ebpf-Another-Types","summary":"Regardons comment limiter le d√©ni de service avec XDP","title":"Att√©nuons les attaques DDoS avec XDP","type":"ebpf-another-type"},{"content":"","date":"29 octobre 2025","externalUrl":null,"permalink":"/tags/aya/","section":"Tags","summary":"","title":"Aya","type":"tags"},{"content":"","date":"29 octobre 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"29 octobre 2025","externalUrl":null,"permalink":"/categories/development/","section":"Categories","summary":"","title":"Development","type":"categories"},{"content":"","date":"29 octobre 2025","externalUrl":null,"permalink":"/tags/ebpf/","section":"Tags","summary":"","title":"EBPF","type":"tags"},{"content":"","date":"29 octobre 2025","externalUrl":null,"permalink":"/categories/network/","section":"Categories","summary":"","title":"Network","type":"categories"},{"content":"","date":"29 octobre 2025","externalUrl":null,"permalink":"/tags/rust/","section":"Tags","summary":"","title":"Rust","type":"tags"},{"content":"","date":"29 octobre 2025","externalUrl":null,"permalink":"/categories/security/","section":"Categories","summary":"","title":"Security","type":"categories"},{"content":"","date":"29 octobre 2025","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"29 octobre 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"29 octobre 2025","externalUrl":null,"permalink":"/categories/teaser/","section":"Categories","summary":"","title":"Teaser","type":"categories"},{"content":"","date":"29 octobre 2025","externalUrl":null,"permalink":"/categories/tutorial/","section":"Categories","summary":"","title":"Tutorial","type":"categories"},{"content":"","date":"29 octobre 2025","externalUrl":null,"permalink":"/tags/xdp/","section":"Tags","summary":"","title":"Xdp","type":"tags"},{"content":"Nous avons vu ce qu\u0026rsquo;√©tait un programme XDP dans la premi√®re partie : cela peut √™tre un moyen de filtrer un flux r√©seau.\nDans cette partie, je vous propose une petite balade dans les diff√©rentes en-t√™tes et de montrer comment on peut op√©rer le filtrage. Nous allons ainsi voir comment red√©velopper xdp-filter avec le framework Rust Aya.\nSuivez le guide ! \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rlab\rJe suppose que vous √™tes d√©j√† dans un environnement pour d√©velopper avec Aya. Si ce n\u0026rsquo;est pas le cas, vous pouvez utiliser le lab Killercoda :\nCr√©ons le hello world en XDP # Recr√©ons l\u0026rsquo;environnement de d√©veloppement # Comme nous l\u0026rsquo;avons vu dans la pr√©c√©dente partie, je vous propose d\u0026rsquo;installer des namespaces :\ngit clone https://github.com/littlejo/eunomia.dev cd eunomia.dev/docs/tutorials/42-xdp-loadbalancer/ ./setup.sh Rappelons ce qu\u0026rsquo;on a cr√©√© :\nCr√©ons le programme \u0026ldquo;hello world\u0026rdquo; # Comme nous l\u0026rsquo;avons fait avec xdp-filter, nous allons installer le programme XDP sur veth0.\nG√©n√©rons d√©j√† le programme Aya :\ncargo generate --name browser-xdp \\ -d program_type=xdp \\ -d default_iface=veth0 \\ https://github.com/aya-rs/aya-template Buildons et installons le programme \u0026ldquo;hello world\u0026rdquo; :\ncd browser-xdp/ cargo run Sur un autre terminal, testons le programme :\nip netns exec lb ping -c 2 10.0.0.1 Du c√¥t√© du terminal cargo run, on voit bien deux paquets :\n[INFO browser_xdp] received a packet [INFO browser_xdp] received a packet Ainsi √† chaque fois que l\u0026rsquo;interface re√ßoit un paquet, le programme XDP est lanc√©.\nMaintenant nous allons voir comment arr√™ter un paquet et quel type de paquet on a affaire.\nLes bases pour cr√©er un programme XDP # Les actions XDP # Regardons d\u0026rsquo;abord le code g√©n√©r√© par cargo.\nLe fichier le plus important est celui-l√† : browser-xdp-ebpf/src/main.rs c\u0026rsquo;est √† dire le code c√¥t√© noyau.\nGlobalement le code ressemble aux codes g√©n√©r√©s pour d\u0026rsquo;autres types de programmes eBPF comme les Tracepoints :\n#[xdp] pub fn browser_xdp(ctx: XdpContext) -\u0026gt; u32 { match try_browser_xdp(ctx) { Ok(ret) =\u0026gt; ret, Err(_) =\u0026gt; xdp_action::XDP_ABORTED, } } fn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { info!(\u0026amp;ctx, \u0026#34;received a packet\u0026#34;); Ok(xdp_action::XDP_PASS) } Cependant on peut remarquer une petite sp√©cificit√© : xdp_action::*.\nCela permet de d√©terminer ce que fait le paquet une fois qu\u0026rsquo;il a fini de parcourir le programme eBPF.\nOn a 5 actions diff√©rentes :\nXDP_ABORTED : Arr√™te le paquet avec erreur XDP_DROP : Arr√™te le paquet silencieusement XDP_PASS : Laisse passer le paquet XDP_REDIRECT : Redirige le paquet vers une autre interface ou une socket AF_XDP attach√©e √† une interface XDP_TX : Redirige le paquet vers la m√™me interface Dans cet article, nous utiliserons uniquement XDP_PASS et XDP_DROP.\nLe contexte XDP et ses m√©thodes # Comme pour tous les autres programmes eBPF, pour aller au-del√† du hello world, il faut comprendre comment jouer avec le contexte.\nRegardons la documentation :\nContrairement aux pr√©c√©dents types de programmes o√π on utilisait qu\u0026rsquo;une seule m√©thode, il y en a 4 diff√©rentes pour XDP :\ndata() retourne l\u0026rsquo;adresse m√©moire du d√©but du paquet r√©seau. data_end() retourne l\u0026rsquo;adresse m√©moire de fin du paquet r√©seau. metadata() retourne l\u0026rsquo;adresse m√©moire du d√©but de la m√©tadonn√©es de XDP li√© au kernel linux ou au driver. metadata_end() retourne l\u0026rsquo;adresse m√©moire de fin de la m√©tadonn√©es. De la m√™me mani√®re que data_end(), Dans cet article, nous utiliserons uniquement les m√©thodes data() et data_end() pour r√©cup√©rer les diff√©rentes en-t√™tes.\nComment r√©cup√©rer les en-t√™tes ? # Rappelons le sch√©ma suivant : data() se trouve au d√©but de l\u0026rsquo;en-t√™te ethHdr data_end() se trouve √† la fin du payload Comment r√©cup√©rer l\u0026rsquo;en-t√™te ethernet (ethHdr) ? Elle se situe au tout d√©but du paquet.\nlet ethhdr = ctx.data(); Pour r√©cup√©rer l\u0026rsquo;en-t√™te suivante, il suffit de rajouter la longueur de l\u0026rsquo;en-t√™te ethernet, en pseudo-code Rust √ßa donnerait :\nlet ipv4hdr = ctx.data() + sizeof(ethhdr); Etc.\nConcentrons-nous sur l\u0026rsquo;en-t√™te ethernet. Comment r√©cup√©rer ses √©l√©ments ? ctx.data() est de type usize. Un entier naturel qui repr√©sente une adresse m√©moire. Il faut donc r√©cup√©rer son contenu. Comment faire cela ?\nDe la m√™me mani√®re que *const u8 repr√©sente un pointeur vers une chaine de caract√®res, ici on doit faire la m√™me chose pour l\u0026rsquo;en-t√™te ethernet.\nAinsi il faut convertir dans une structure qui repr√©sente l\u0026rsquo;en-t√™te de la trame Ethernet. On a plusieurs possibilit√©s pour le faire comme aller voir le code C et le convertir en Rust ce qui est un bon exercice mais un peu fastidieux. Heureusement, comme Rust est d√©sormais bien pr√©sent dans l\u0026rsquo;√©cosyst√®me d\u0026rsquo;eBPF, il y a d√©j√† une crate Rust qui nous a fait le travail : network-types.\nPour r√©cup√©rer cette crate, on va modifier le fichier browser-xdp-ebpf/Cargo.toml et rajouter dans la section dependencies :\nnetwork-types = \u0026#34;0.1.0\u0026#34; On va ainsi pouvoir l\u0026rsquo;inclure dans le code principal (browser-xdp-ebpf/src/main.rs) :\nuse network_types::eth::EthHdr; [...] let ethhdr = ctx.data() as *const EthHdr; Maintenant qu\u0026rsquo;on a r√©cup√©r√© la structure de l\u0026rsquo;en-t√™te ethernet, nous pouvons r√©cup√©rer les diff√©rents √©l√©ments qui composent l\u0026rsquo;en-t√™te :\nDST MAC : l\u0026rsquo;adresse MAC destination SRC MAC : l\u0026rsquo;adresse MAC source ETHERTYPE : d√©termine le protocole du niveau sup√©rieur (Comme IPv4, IPv6, Arp pour citer les plus connus). Comment le faire avec Aya ? Regardons la documentation :\nAinsi pour r√©cup√©rer l\u0026rsquo;adresse de destination, il suffit de coder :\nlet dst_addr = unsafe { (*ethhdr).dst_addr}; info!(\u0026amp;ctx, \u0026#34;dst_addr {:mac} \u0026#34;, dst_addr); Nous devons utiliser unsafe car nous d√©r√©f√©ren√ßons un pointeur brut.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e On peut remarquer que la macro info! nous permet de convertir des tableaux de 6 octets en une adresse MAC. Si vous pr√©f√©rez la notation en majuscule, il suffit d\u0026rsquo;√©crire :MAC. Essayons maintenant. Voici le code principal modifi√© :\nuse network_types::eth::EthHdr; fn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let ethhdr = ctx.data() as *const EthHdr; let dst_addr = unsafe { (*ethhdr).dst_addr}; info!(\u0026amp;ctx, \u0026#34;dst_addr {:mac} \u0026#34;, dst_addr); info!(\u0026amp;ctx, \u0026#34;received a packet\u0026#34;); Ok(xdp_action::XDP_PASS) } Buildons le programme :\ncargo build La compilation fonctionne.\nInstallons le dans le noyau :\ncargo run On a alors l\u0026rsquo;erreur suivante :\nError: the BPF_PROG_LOAD syscall failed. Verifier output: 0: R1=ctx() R10=fp0 ; unsafe { (*self.ctx).data as usize } @ xdp.rs:16 0: (61) r1 = *(u32 *)(r1 +0) ; R1_w=pkt(r=0) ; let dst_addr = unsafe { (*ethhdr).dst_addr}; @ main.rs:20 1: (71) r0 = *(u8 *)(r1 +1) invalid access to packet, off=1 size=1, R1(id=0,off=1,r=0) R1 offset is outside of the packet verification time 65 usec stack depth 0 processed 2 insns (limit 1000000) max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0 Caused by: Permission denied (os error 13) Le verifier n\u0026rsquo;aime pas vraiment cette partie du code :\nlet ethhdr = ctx.data() as *const EthHdr; \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Quand on essaie d\u0026rsquo;installer un programme eBPF dans le noyau Linux, il y a un programme Linux (le verifier) qui fait des v√©rifications dans le code pour √©viter qu\u0026rsquo;on casse la s√©curit√© du noyau Linux. L\u0026rsquo;erreur peut se traduire en fran√ßais par :\nAcc√®s invalide au paquet. L\u0026#39;offset du registre 1 est en dehors du paquet Pas super clair. Essayons d\u0026rsquo;expliquer mieux. Quand on tente let ethhdr = ctx.data() as *const EthHdr;, Il y a un acc√®s √† la m√©moire. Le verifier exige qu\u0026rsquo;on prouve que cet acc√®s soit toujours dans le paquet (entre data() et data_end()).\nIl faut donc faire une v√©rification pour le rassurer avant cet acc√®s :\nif ctx.data() + EthHdr::LEN \u0026gt; ctx.data_end() { return Ok(xdp_action::XDP_PASS); } On peut traduire par : si l\u0026rsquo;acc√®s ne se trouve pas au niveau du paquet, le programme XDP ne traite pas le paquet : il le laisse continuer son chemin dans la pile r√©seau de noyau Linux.\nSinon on peut alors convertir en EthHdr :\nlet ethhdr = ctx.data() as *const EthHdr; Voici le code complet de la fonction principale :\nfn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let start = ctx.data() ; let end = ctx.data_end() ; if start + EthHdr::LEN \u0026gt; end { //Check for the verifier return Ok(xdp_action::XDP_PASS); } let ethhdr = start as *const EthHdr; let dst_addr = unsafe { (*ethhdr).dst_addr}; info!(\u0026amp;ctx, \u0026#34;dst_addr {:mac} \u0026#34;, dst_addr); info!(\u0026amp;ctx, \u0026#34;received a packet\u0026#34;); Ok(xdp_action::XDP_PASS) } V√©rifions que √ßa marche :\ncargo run Lan√ßons des ping. On r√©cup√®re bien l\u0026rsquo;adresse mac :\n[INFO browser_xdp] dst_addr de:ad:be:ef:00:01 [INFO browser_xdp] received a packet [INFO browser_xdp] dst_addr de:ad:be:ef:00:01 [INFO browser_xdp] received a packet Maintenant qu\u0026rsquo;on a r√©ussi √† r√©cup√©rer l\u0026rsquo;en-t√™te ethHdr, comment r√©cup√©rer les autres en-t√™tes ? Il suffit de rajouter la longueur des en-t√™tes qui les pr√©c√®dent.\nDe mani√®re assez √©vidente, nous allons utiliser des m√©thodes tr√®s proches pour toutes les en-t√™tes. Il serait judicieux de cr√©er une fonction. La voil√† :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 use core::mem::size_of; #[inline(always)] fn ptr_at\u0026lt;T\u0026gt;(ctx: \u0026amp;XdpContext, offset: usize) -\u0026gt; Result\u0026lt;*const T, u16\u0026gt; { let start = ctx.data(); let end = ctx.data_end(); let len = size_of::\u0026lt;T\u0026gt;(); if start + offset + len \u0026gt; end { return Err(1); } Ok((start + offset) as *const T) } Quelques remarques sur la cr√©ation de cette fonction :\n(L3) On inline la fonction pour des questions de performance (L4) \u0026lt;T\u0026gt; : permet de cr√©er une fonction g√©n√©rique non d√©pendante de la structure l\u0026rsquo;offset permet de naviguer d\u0026rsquo;en-t√™te en en-t√™te (offset = 0 pour ethHdr) (L7) On a d√ª changer la m√©thode pour calculer la longueur de la structure avec un size_of pour que √ßa soit possible pour n\u0026rsquo;importe quelle structure Le code principal devient alors :\nfn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0)?; let dst_addr = unsafe { (*ethhdr).dst_addr}; info!(\u0026amp;ctx, \u0026#34;dst_addr {:mac} \u0026#34;, dst_addr); info!(\u0026amp;ctx, \u0026#34;received a packet\u0026#34;); Ok(xdp_action::XDP_PASS) } Maintenant qu\u0026rsquo;on a cr√©√© la fonction permettant de se balader dans les diff√©rentes en-t√™tes, regardons comment on fait pour bloquer ou laisser passer les diff√©rents paquets en fonction des en-t√™tes r√©seaux.\nVisite guid√©e des diff√©rentes en-t√™tes # Niveau 1 : Acc√®s r√©seau # Ce qu\u0026rsquo;on peut filtrer # On l\u0026rsquo;a d√©j√† vu pour le premier niveau : on peut notamment r√©cup√©rer l\u0026rsquo;adresse MAC source, l\u0026rsquo;adresse MAC destination et l\u0026rsquo;EtherType. On peut ainsi filtrer en fonction de l\u0026rsquo;adresse MAC ou si on veut uniquement de l\u0026rsquo;IPv4 par exemple.\nOn va donc utiliser la fonction cr√©√©e pr√©c√©demment ptr_at() :\nlet ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0)?; Pour r√©cup√©rer les adresses MAC et pour les afficher :\nlet dst_addr = unsafe { (*ethhdr).dst_addr }; let src_addr = unsafe { (*ethhdr).src_addr }; info!(\u0026amp;ctx, \u0026#34;src: {:mac} =\u0026gt; dst: {:mac}\u0026#34;, src_addr, dst_addr); Testons :\ncargo run Et pingons. regardons le r√©sultat :\n[INFO browser_xdp] src: de:ad:be:ef:00:10 =\u0026gt; dst: de:ad:be:ef:00:01 [INFO browser_xdp] src: de:ad:be:ef:00:10 =\u0026gt; dst: de:ad:be:ef:00:01 Pour coder un peu plus propre, on peut cr√©er une fonction :\n#[inline(always)] fn display_ethhdr(ctx: \u0026amp;XdpContext, ethhdr: *const EthHdr) { let dst_addr = unsafe { (*ethhdr).dst_addr }; let src_addr = unsafe { (*ethhdr).src_addr }; let ethertype = unsafe { (*ethhdr).ether_type }; info!(ctx, \u0026#34;EthHdr: src: {:mac} =\u0026gt; dst: {:mac} ({})\u0026#34;, src_addr, dst_addr, ethertype); } Filtrons # Ainsi pour filtrer une adresse MAC, on peut faire :\nlet mac: [u8; 6] = [0xde, 0xad, 0xbe, 0xef, 0x00, 0x10]; //de:ad:be:ef:00:10 if mac == src_addr { info!(\u0026amp;ctx, \u0026#34;drop\u0026#34;); return Ok(xdp_action::XDP_DROP); } \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Dans un \u0026ldquo;vrai\u0026rdquo; projet, on ne hard-coderait pas. On cr√©erait une map eBPF qu\u0026rsquo;on remplirait dans l\u0026rsquo;espace utilisateur avec une liste d\u0026rsquo;adresses MAC √† filtrer. On a d√©j√† vu un cas similaire dans la section d√©di√©e aux map eBPF de l\u0026rsquo;initiation. Testons :\ncargo run Pingons depuis lb : √ßa ne ping plus. Regardons le r√©sultat au niveau d\u0026rsquo;Aya :\n[INFO browser_xdp] drop [INFO browser_xdp] drop Le programme rep√®re bien le paquet et l\u0026rsquo;arr√™te.\nPingons depuis le namespace h2 :\nip netns exec h2 ping -c 2 10.0.0.1 Le ping laisse bien passer :\n[INFO browser_xdp] received ethhdr packet src: de:ad:be:ef:00:02 =\u0026gt; dst: de:ad:be:ef:00:01 [INFO browser_xdp] received ethhdr packet src: de:ad:be:ef:00:02 =\u0026gt; dst: de:ad:be:ef:00:01 Pour ressembler plus √† xdp-filter, on peut cr√©er cette fonction qui permet de distinguer si on veut emp√™cher la source ou la destination:\nenum Mode { Src, Dst, } #[inline(always)] fn drop_mac(ethhdr: *const EthHdr, mac: [u8; 6], mode: Mode) -\u0026gt; bool { let addr = match mode { Mode::Src =\u0026gt; unsafe {(*ethhdr).src_addr}, Mode::Dst =\u0026gt; unsafe {(*ethhdr).dst_addr}, }; mac == addr } Au niveau du code principal cela donne alors :\nfn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0)?; let mac: [u8; 6] = [0xde, 0xad, 0xbe, 0xef, 0x00, 0x10]; //de:ad:be:ef:00:10 display_ethhdr(\u0026amp;ctx, ethhdr); if drop_mac(ethhdr, mac, Mode::Src) { return Ok(xdp_action::XDP_DROP); } Ok(xdp_action::XDP_DROP); } Level up # L\u0026rsquo;Ethertype determine le protocole du paquet dans le niveau sup√©rieur.\nAinsi pour le r√©cup√©rer, on peut l\u0026rsquo;avoir de la mani√®re suivante :\nlet ethertype = unsafe {(*ethhdr).ether_type} ; Mais il y a plus propre avec la m√©thode ether_type() qui v√©rifie si le num√©ro du protocole existe vraiment : Au lieu de conna√Ætre par c≈ìur les num√©ros de protocole, la crate network-types nous simplifie avec le type EtherType :\nAinsi on filtre de cette mani√®re :\nmatch unsafe { (*ethhdr).ether_type() } { Ok(EtherType::Ipv4) =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } Les flux autres que l\u0026rsquo;IPv4 (par exemple : IPv6, Arp) passent directement et ne sont plus analys√©s.\nNiveau 2 : Internet # Ce qu‚Äôon peut filtrer # On va donc supposer qu\u0026rsquo;on veut analyser uniquement les flux IPv4.\nDe la m√™me mani√®re qu\u0026rsquo;Ethernet, regardons ce qu\u0026rsquo;on peut r√©cup√©rer comme donn√©es avec l\u0026rsquo;en-t√™te IPv4 : Pour la claret√©, l\u0026rsquo;en-t√™te est repr√©sent√©e sur plusieurs lignes. Il y a nettement plus de choses √† r√©cup√©rer. ceux qu\u0026rsquo;on va utiliser pour cet article :\nPROTOCOL : le protocole du niveau sup√©rieur (TCP ou UDP par exemple) SOURCE ADDRESS : l\u0026rsquo;adresse IP source DESTINATION ADDRESS : l\u0026rsquo;adresse IP destination Si vous trouvez que l\u0026rsquo;en-t√™te IPv4 est complexe, c\u0026rsquo;est une des raisons de la cr√©ation d\u0026rsquo;IPv6 : son en-t√™te est un peu plus simple facilitant le traitement des paquets. Au niveau Rust, on peut r√©cup√©rer ces en-t√™tes : Pour r√©cup√©rer les en-t√™tes de l\u0026rsquo;IPv4, il suffit de d√©caler le pointeur √† la longueur de la structure de l\u0026rsquo;en-t√™te Ethernet avec la fonction qu\u0026rsquo;on a cr√©√© :\nlet ipv4hdr: *const Ipv4Hdr = ptr_at(\u0026amp;ctx, EthHdr::LEN)? ; De la m√™me mani√®re que pour la couche inf√©rieure on peut cr√©er une fonction :\n#[inline(always)] fn display_iphdr(ctx: \u0026amp;XdpContext, iphdr: *const Ipv4Hdr) { let dst_addr = unsafe { (*iphdr).dst_addr }; let src_addr = unsafe { (*iphdr).src_addr }; let proto = unsafe { (*iphdr).proto }; info!(ctx, \u0026#34;Ipv4Hdr: src: {:i} =\u0026gt; dst: {:i} ({})\u0026#34;, src_addr, dst_addr, proto as u8); } \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Tout comme pour les adresses MAC, la macro info! nous simplifie la vie en convertissant un tableau de 4 octets en la notation d\u0026rsquo;IPv4 avec :i. Testons le code suivant :\nuse network_types::{eth::{EthHdr,EtherType}, ip::Ipv4Hdr, }; fn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0)?; match unsafe { (*ethhdr).ether_type() } { Ok(EtherType::Ipv4) =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } let ipv4hdr: *const Ipv4Hdr = ptr_at(\u0026amp;ctx, EthHdr::LEN)? ; let mac: [u8; 6] = [0xde, 0xad, 0xbe, 0xef, 0x00, 0x10]; //de:ad:be:ef:00:10 //display_ethhdr(\u0026amp;ctx, ethhdr); display_iphdr(\u0026amp;ctx, ipv4hdr); Ok(xdp_action::XDP_PASS) } Si on ping :\nip netns exec lb ping -c 2 10.0.0.1 Du c√¥t√© de cargo run, cela donne :\n[INFO browser_xdp] Ipv4Hdr: src: 10.0.0.10 =\u0026gt; dst: 10.0.0.1 (1) [INFO browser_xdp] Ipv4Hdr: src: 10.0.0.10 =\u0026gt; dst: 10.0.0.1 (1) De la m√™me mani√®re que l\u0026rsquo;adresse Mac, pour emp√™cher l\u0026rsquo;ip du lb, on peut utiliser cette fonction:\n#[inline(always)] fn drop_ip(iphdr: *const Ipv4Hdr, ip: [u8; 4], mode: Mode) -\u0026gt; bool { let addr = match mode { Mode::Src =\u0026gt; unsafe {(*iphdr).src_addr}, Mode::Dst =\u0026gt; unsafe {(*iphdr).dst_addr}, }; ip == addr } Le code principal donne alors :\nfn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0)?; match unsafe { (*ethhdr).ether_type() } { Ok(EtherType::Ipv4) =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } let ipv4hdr: *const Ipv4Hdr = ptr_at(\u0026amp;ctx, EthHdr::LEN)? ; display_iphdr(\u0026amp;ctx, ipv4hdr); if drop_ip(ipv4hdr, [10, 0, 0, 10], Mode::Src) { return Ok(xdp_action::XDP_DROP); } Ok(xdp_action::XDP_PASS) } Le ping ne fonctionne plus :\nip netns exec lb ping -c 2 10.0.0.1 [INFO browser_xdp] Ipv4Hdr: src: 10.0.0.10 =\u0026gt; dst: 10.0.0.1 (1) [INFO browser_xdp] Ipv4Hdr: src: 10.0.0.10 =\u0026gt; dst: 10.0.0.1 (1) Le programme rep√®re bien le paquet et l\u0026rsquo;arr√™te. Level up # Pour aller au niveau sup√©rieur, il faut savoir quel protocole on veut regarder. Pour cela on utilise l\u0026rsquo;option proto. Il est de type IPProto qui est une √©num√©ration :\nNous allons regarder UDP pour la fin de l\u0026rsquo;article. Le principe est le m√™me que pour l‚ÄôEthertype :\nmatch unsafe { (*ipv4hdr).proto } { IpProto::Udp =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } On peut facilement filtrer si on veut bloquer certains protocoles.\nNiveau 3 : Transport # Ce qu\u0026rsquo;on peut filtrer # Pour UDP, on peut ainsi r√©cup√©rer l\u0026rsquo;en-t√™te de cette mani√®re :\nlet udphdr: *const UdpHdr = ptr_at(\u0026amp;ctx, EthHdr::LEN + Ipv4Hdr::LEN)? ; Regardons maintenant l\u0026rsquo;en-t√™te du segment UDP :\nLa partie la plus int√©ressante √† filtrer sont les ports.\nAu niveau Rust :\nLes ports ne sont pas des entiers mais des tableaux de 2 octets. Cela n\u0026rsquo;est pas pratique. Heureusement il y a les m√©thodes suivantes :\nOn peut filtrer au niveau du port UDP :\n#[inline(always)] fn drop_udp_port(udphdr: *const UdpHdr, port: u16, mode: Mode) -\u0026gt; bool { let packet_port = match mode { Mode::Src =\u0026gt; unsafe {(*udphdr).src_port()}, Mode::Dst =\u0026gt; unsafe {(*udphdr).dst_port()}, }; port == packet_port } Testons le code suivant :\nuse network_types::{eth::{EthHdr,EtherType}, ip::{Ipv4Hdr,IpProto}, udp::UdpHdr, }; fn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0)?; match unsafe { (*ethhdr).ether_type() } { Ok(EtherType::Ipv4) =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } let ipv4hdr: *const Ipv4Hdr = ptr_at(\u0026amp;ctx, EthHdr::LEN)? ; match unsafe { (*ipv4hdr).proto } { IpProto::Udp =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } let udphdr: *const UdpHdr = ptr_at(\u0026amp;ctx, EthHdr::LEN + Ipv4Hdr::LEN)? ; display_udphdr(\u0026amp;ctx, udphdr); if drop_udp_port(udphdr, 8888, Mode::Dst){ return Ok(xdp_action::XDP_DROP); } Ok(xdp_action::XDP_PASS) } Installons le programme XDP :\ncargo run Cr√©ons un serveur UDP avec netcat :\nnc -u 0.0.0.0 -l 8000 Cr√©ons un client udp maintenant :\nip netns exec lb netcat -u 10.0.0.1 8000 coucou Cette commande ouvre un client UDP et envoie le message coucou.\nDu c√¥t√© sur le serveur UDP, on voit bien :\ncoucou Mais surtout, on voit bien du c√¥t√© cargo run :\n[INFO browser_xdp] UdpHdr: src: 44024 =\u0026gt; dst: 8000 Testons maintenant avec un serveur UDP avec le port 8888 :\nnc -u 0.0.0.0 -l 8888 Cr√©ons un client udp maintenant :\nip netns exec lb netcat -u 10.0.0.1 8888 coucou Il ne s\u0026rsquo;affiche rien au niveau du serveur c\u0026rsquo;est normal le programme XDP l\u0026rsquo;a bloqu√© :\n[INFO browser_xdp] UdpHdr: src: 39540 =\u0026gt; dst: 8888 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rLes fonctions drop_mac(), drop_ip() et drop_udp_port() sont tr√®s proches il est tout √† fait possible en Rust de les rendre g√©n√©rique pour qu\u0026rsquo;il y en ait qu\u0026rsquo;une. De m√™me pour display_ethdr(), display_iphdr() et display_udphdr(). Vous pouvez voir le code plus g√©n√©rique au niveau de la crate d√©di√©e au blog ici et l√†. Niveau 4 : Application # La crate network-types n\u0026rsquo;aide pas pour r√©cup√©rer les en-t√™tes des protocoles applicatifs. En connaissant le port du niveau pr√©c√©dent, on peut facilement filtrer l\u0026rsquo;application. Si tu filtres le port 53 tu vas filtrer le DNS par exemple. Mais si tu veux filtrer une requ√™te sp√©cifique, c\u0026rsquo;est une autre affaire.\nC\u0026rsquo;est possible d\u0026rsquo;aller plus haut. Mais les en-t√™tes des applications peuvent √™tre :\ntrop importantes pour la stack (limit√© √† 512 octets), il faudrait obligatoirement pass√© par des maps eBPF ; chiffr√©es comme pour HTTPS ou SSH ce qui rend l\u0026rsquo;analyse impossible avec XDP. Cet √©pisode est maintenant termin√© ! Nous avons vu les bases pour cr√©er un firewall comme xdp-filter.\nCependant, nous n\u0026rsquo;avons pas vu comment faire pour qu\u0026rsquo;il soit un peu plus intelligent en √©vitant par exemple les DDoS.\n√áa tombe bien ! Dans le prochain √©pisode, nous allons cr√©er un programme XDP qui va att√©nuer les d√©nis de service.\n","date":"29 octobre 2025","externalUrl":null,"permalink":"/ebpf-another-type/xdp/example-1/","section":"Ebpf-Another-Types","summary":"Regardons comment bloquer le flux selon certains crit√®res (adresse mac, ip, protocole, port, etc.)","title":"Impl√©mentons un petit firewall avec XDP","type":"ebpf-another-type"},{"content":"","date":"27 octobre 2025","externalUrl":null,"permalink":"/tetragon/","section":"Tetragons","summary":"","title":"Tetragons","type":"tetragon"},{"content":"","date":"16 octobre 2025","externalUrl":null,"permalink":"/en/series/lets-learn-another-ebpf-program/","section":"Series","summary":"","title":"Let‚Äôs Learn Another EBPF Program","type":"series"},{"content":"","date":"16 octobre 2025","externalUrl":null,"permalink":"/series/apprenons-un-autre-programme-ebpf/","section":"Series","summary":"","title":"Apprenons Un Autre Programme EBPF","type":"series"},{"content":"","date":"16 octobre 2025","externalUrl":null,"permalink":"/categories/introduction/","section":"Categories","summary":"","title":"Introduction","type":"categories"},{"content":"Je d√©bute la programmation en eBPF avec Aya. L‚Äôid√©e de cette s√©rie d‚Äôarticles est d\u0026rsquo;apprendre un nouveau type de programme eBPF et de l\u0026rsquo;exp√©rimenter avec le framework Rust Aya.\nAujourd\u0026rsquo;hui, nous allons nous plonger dans XDP : des programmes eBPF capables de filtrer ou rediriger des paquets r√©seau plus vite que son ombre.\nVous allez voir que cela peut √™tre tr√®s int√©ressant pour cr√©er un pare-feu efficace, capable de contrer les attaques en d√©ni de service mais √©galement pour load-balancer des millions de paquets r√©seaux.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Si tu ne connais pas eBPF, je te conseille de lire les deux premi√®res parties de ma s√©rie S‚Äôinitier √† eBPF avec Aya. Cela couvre les bases et t\u0026rsquo;aidera pour la suite de l\u0026rsquo;article. Qu‚Äôest-ce qu‚ÄôXDP ? # Comme vous devez vous en do√ªter, XDP est un type de programme eBPF orient√© r√©seau. XDP est l\u0026rsquo;acronyme de eXpress Data Path qu\u0026rsquo;on pourrait traduire par voie rapide pour les donn√©es.\nPour bien comprendre la signification de cet acronyme, il faut avoir conscience de ce que parcourt un paquet r√©seau depuis la carte r√©seau jusqu\u0026rsquo;√† une application comme un serveur Web. Traditionnellement il fait le parcours suivant sous Linux : XDP s\u0026rsquo;ex√©cute directement au niveau du driver, permettant ainsi de r√©agir plus rapidement qu\u0026rsquo;un firewall applicatif. Cette rapidit√© est notamment cruciale contre les attaques par d√©ni de service distribu√© (DDoS : Distributed Denial of Service attack).\nSi on veut √™tre pr√©cis, XDP peut intervenir √† 3 endroits diff√©rents selon la prise en charge de la carte r√©seau :\nAu niveau du firmware de la carte r√©seau (mode offloaded) mais seulement quelques mod√®les de carte r√©seaux prennent en charge cela Au niveau du driver r√©seau (mode native), le cas le plus courant pour des serveurs standards Au niveau de la pile r√©seau du noyau (mode generic), permettant ainsi de tester sur n\u0026rsquo;importe quel ordinateur (comme ton portable) N\u0026rsquo;h√©sitez pas √† consulter cette page pour plus de pr√©cision.\nPar contre, XDP intervenant sur une couche r√©seau tr√®s basse, les donn√©es en sortie r√©cup√©r√©es sont brutes et non transform√©es par la couche r√©seau de Linux ce qui le rend plus complexe √† g√©rer pour certaines t√¢ches (comme le suivi des connexions et des retransmissions TCP).\nPour en savoir plus, n\u0026rsquo;h√©sitez pas √† consulter la documentation officielle :\nNous allons maintenant parler du contexte de la cr√©ation de cette technologie.\nOrigin story # Les anc√™tres de XDP # On n\u0026rsquo;a pas attendu XDP pour filtrer ou rediriger les paquets dans le noyau Linux.\nLe premier firewall a √©t√© impl√©ment√© dans Linux 1.1 en 1994, il se nommait ipfw et pour le configurer il y avait la ligne de commande ipfwadm. Il est inspir√© du firewall cr√©√© pour FreeBSD. Il a √©t√© remplac√© par ipchains dans Linux 2.2 en 1999 qui √©tait plus complet et adapt√© √† la nouvelle couche r√©seau du noyau.\nNetfilter : l\u0026rsquo;immortel # Pour la version 2.4 (2001) du noyau Linux, un tout nouveau pare-feu a √©t√© cr√©√© : Netfilter et sa ligne de commande iptables que tout ing√©nieur Linux r√©seau conna√Æt tr√®s bien encore aujourd\u0026rsquo;hui. Netfilter traite les paquets r√©seaux √† divers endroits de la pile r√©seau de Linux donc bien apr√®s le driver.\nDepuis cette version, Netfilter a √©volu√© pour g√©rer les nouveaut√©s comme IPv6, les cgroups.\n\u003c?xml version=\"1.0\" encoding=\"iso-8859-1\"?\u003e\rVous avez probablement entendu parler de nftables. Elle est juste une ligne de commande qui permet de mettre √† jour plus efficacement qu\u0026rsquo;iptables les r√®gles. Pour cela on a d√ª modifier l\u0026rsquo;\u0026ldquo;api\u0026rdquo; du noyau Linux. Mais le moteur derri√®re reste netfilter. Malgr√© ses qualit√©s, Linux n\u0026rsquo;a jamais eu bonne presse pour le mat√©riel r√©seau. Par exemple, la plupart des switchs et routeurs professionnels tournent sous d\u0026rsquo;autres syst√®mes d\u0026rsquo;exploitation. Est-ce qu\u0026rsquo;XDP pourrait inverser la tendance ?\nXDP : le successeur ? # En 2014, eBPF est sortie. Mais c\u0026rsquo;est deux ans plus tard, pour la version 4.8 du noyau Linux que XDP √©tait enfin utilisable. Il a √©t√© d√©velopp√© conjointement par Brenden Blanco (PLUMgrid Inc) et Tom Herbert (Facebook).\nContrairement √† d\u0026rsquo;autres types de programme eBPF, XDP ne peut s\u0026rsquo;utiliser uniquement avec eBPF. Un hook est plac√© au niveau du driver r√©seau permettant ainsi de d√©marrer son programme eBPF. Ainsi il fallait d√©velopper les drivers compatibles XDP pour que cela puisse fonctionner. Il fallait √©galement que les frameworks de l\u0026rsquo;√©poque puissent g√©rer ce nouveau type de programme. Ainsi d√®s juillet 2016, avant m√™me la sortie officiel du noyau Linux compatible avec XDP, il √©tait possible de cr√©er des programmes XDP avec BCC :\nDepuis, XDP a continu√© d\u0026rsquo;√©voluer, on peut noter :\nen 2018, l\u0026rsquo;apparition de la socket AF_XDP (Address Family Express Data Path) qui permet d\u0026rsquo;exploiter XDP depuis l\u0026rsquo;espace utilisateur sans passer par la pile r√©seau. en 2022, la gestion des paquets importants (comme Jumbo packet, GRO ou BIG TCP) avec XDP Fragment. Aujourd\u0026rsquo;hui, XDP est consid√©r√© comme stable et utilisable en production.\n\u003c?xml version=\"1.0\" encoding=\"iso-8859-1\"?\u003e\rOn ne peut pas dire qu\u0026rsquo;XDP est un rempla√ßant de Netfilter. Par exemple, recr√©er une commande √©quivalente √† iptables avec XDP serait un travail colossal. Le projet bpfilter est un projet qui vise √† traduire les r√®gles iptables en programmes eBPF n\u0026rsquo;utilise pas uniquement XDP. Pour finir, voici une petite frise chronologique de l\u0026rsquo;histoire de XDP :\nMaintenant qu\u0026rsquo;XDP est jug√©e stable, on peut se poser une question bien l√©gitime : quels projets utilisent XDP ?\nQuels projets utilisent XDP ? # Pour d√©fier le lieu commun : \u0026ldquo;eBPF c\u0026rsquo;est utilis√© que par 3 grosses bo√Ætes\u0026rdquo;, j\u0026rsquo;ai fait une petite recherche des outils qui utilisaient r√©ellement XDP et que donc vous l\u0026rsquo;utilisiez peut-√™tre sans le savoir\u0026hellip;\nKatran : le loadbalancer de Facebook # Le projet Katran d√©veloppe un load balancer XDP de niveau 4. Il est utilis√© par Facebook mais √©galement par Netflix. Par ailleurs, Facebook a cr√©√© un firewall bas√© sur XDP pour emp√™cher le DDoS.\nCilium : les services externes de Kubernetes # Le projet Cilium fournit un plugin CNI pour Kubernetes et peut √©galement remplacer kube-proxy. Selon certaines conditions, Cilium peut activer XDP pour les services de type NodePort, LoadBalancer et externalIPs, permettant ainsi d\u0026rsquo;√™tre plus performant.\nCloudflare : pour emp√™cher le DDoS # En 2018, Cloudflare a publi√© un article expliquant comment il r√©duisait le DDoS avec XDP. R√©cemment Cloudflare a communiqu√© pour avoir d√©jou√© un DDoS de 22,2 Tbit/s.\nEt bien d\u0026rsquo;autres # Il y a certainement d\u0026rsquo;autres projets moins connus qui utilisent XDP comme Surricata.\nNous allons maintenant voir les principales difficult√©s que l\u0026rsquo;on va rencontrer quand on va commencer √† cr√©er un programme XDP.\nComment d√©buter son programme XDP ? # Pour de nombreux programmes eBPF, la premi√®re difficult√© est de trouver le point d\u0026rsquo;accroche. Pour XDP, c\u0026rsquo;est relativement simple : il suffit de conna√Ætre le nom de l\u0026rsquo;interface r√©seau o√π on veut accrocher le programme XDP.\nLa r√©elle difficult√© r√©side plut√¥t dans la cr√©ation d\u0026rsquo;un environnement r√©seau. La solution traditionnelle est de cr√©er des VMs (avec Vagrant par exemple) et de les faire communiquer entre eux. Cette solution est tout √† fait possible pour XDP mais √ßa me para√Æt un peu lourd √† mettre en place (par exemple pour les labs).\nPour la suite, je vous propose une solution beaucoup plus l√©g√®re : en utilisant les namespaces r√©seaux de Linux. Le m√™me m√©canisme qui est utilis√© pour Docker.\nCr√©ation d\u0026rsquo;un environnement pour XDP # \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rlab\rJe suppose que vous √™tes sous Linux pour la d√©monstration. Si ce n\u0026rsquo;est pas le cas, vous pouvez utiliser le lab Killercoda :\nScript de cr√©ation de l\u0026rsquo;environnement # On pourrait faire un tutoriel pour la cr√©ation de namespaces r√©seaux mais comme ce n\u0026rsquo;est pas le sujet central et comme il y a d√©j√† des scripts qu\u0026rsquo;on peut facilement trouver sur le net, je vous propose le script suivant :\ngit clone https://github.com/littlejo/eunomia.dev cd eunomia.dev/docs/tutorials/42-xdp-loadbalancer/ Pour cr√©er les namespaces r√©seaux :\n./setup.sh \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rJ\u0026rsquo;ai d√ª installer le paquet net-tools sous Debian pour avoir acc√®s √† la commande arp qui est utilis√©e dans le script pour effectuer des v√©rifications de bon fonctionnement. Ce script va cr√©er trois namespaces qui peuvent communiquer entre eux (lb, h2 et h3) via un bridge (br0) :\nip netns list lb (id: 23) h3 (id: 18) h2 (id: 15) Pour voir les IPs d\u0026rsquo;un namespace, on peut taper :\nip netns exec lb ip -brief -family inet addr lo UNKNOWN 127.0.0.1/8 veth6@if98 UP 10.0.0.10/24 Il faut voir ces namespaces un peu comme des containers √† part qu\u0026rsquo;√† l\u0026rsquo;int√©rieur des namespaces on a toutes les commandes de l\u0026rsquo;h√¥te ! On peut repr√©senter de cette mani√®re ces namespaces :\nV√©rification du bon fonctionnement # Bien que le script fait d√©j√† les v√©rifications n√©cessaires, on va tout de m√™me en faire quelques uns nous m√™me pour montrer les possibilit√©s de tests qu\u0026rsquo;on peut faire.\nOn peut ainsi pinger l\u0026rsquo;ip d\u0026rsquo;un namespace depuis l\u0026rsquo;h√¥te :\nping -c 3 10.0.0.10 √áa ping bien :\nPING 10.0.0.10 (10.0.0.10) 56(84) bytes of data. 64 bytes from 10.0.0.10: icmp_seq=1 ttl=64 time=0.060 ms 64 bytes from 10.0.0.10: icmp_seq=2 ttl=64 time=0.124 ms 64 bytes from 10.0.0.10: icmp_seq=3 ttl=64 time=0.122 ms --- 10.0.0.10 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2053ms rtt min/avg/max/mdev = 0.060/0.102/0.124/0.029 ms Pour tester la connexions √† un serveur web dans un namespace, je peux le faire de cette mani√®re dans le namespace h2 :\nip netns exec h2 python3 -m http.server 8080 Si je veux tester que depuis lb, je peux me connecter au serveur web, je tape sur un autre terminal :\nip netns exec lb curl http://10.0.0.2:8080 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e On pourra ainsi cr√©er un petit load balancer dans le namespace lb et le rediriger vers le namespace h2 et h3. On a ainsi un environnement de test complet pour la suite des articles.\nNettoyage # Pour supprimer les namespaces et les interfaces r√©seaux, on peut red√©marrer la machine ou juste taper :\n./teardown.sh Mon premier programme xdp # Nous allons maintenant cr√©er un petit programme XDP dans l\u0026rsquo;environnement cr√©√©.\nxdp-tools est une suite d\u0026rsquo;outils pour cr√©er et debugger des programmes XDP.\nPour l\u0026rsquo;installer sous Debian 13, j\u0026rsquo;ai install√© le paquet :\napt install xdp-tools Si vous gal√©rez pour l\u0026rsquo;installer j\u0026rsquo;ai cr√©√© un container pour cela (littlejo/xdp-tools). Tout est l√†. On va utiliser xdp-filter qui permet de cr√©er des programmes xdp qui filtrent les paquets.\nOn va installer un programme xdp sur l\u0026rsquo;interface veth0 :\nxdp-filter load veth0 L\u0026rsquo;option load permet de charger le programme XDP.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Pour le d√©charger, il suffit d\u0026rsquo;utiliser l\u0026rsquo;option unload : xdp-filter unload veth0. Voil√† ce qu\u0026rsquo;on a fait sch√©matiquement :\nDepuis un autre terminal, on peut v√©rifier que le ping fonctionne :\nip netns exec lb ping -c 3 10.0.0.1 Vous pouvez √©galement le voir :\nxdp-filter status Vous voyez qu\u0026rsquo;xdp a bien laiss√© passer 3 packets :\nCURRENT XDP-FILTER STATUS: Aggregate per-action statistics: XDP_ABORTED 0 pkts 0 KiB XDP_DROP 0 pkts 0 KiB XDP_PASS 3 pkts 0 KiB Loaded on interfaces: Enabled features xdpfilt_alw_all veth0 (native mode) tcp,udp,ipv6,ipv4,ethernet,allow Filtered ports: Mode Hit counter Filtered IP addresses: Mode Hit counter Filtered MAC addresses: Mode Hit counter Pour filtrer l\u0026rsquo;ip de lb :\nxdp-filter ip -m src 10.0.0.10 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Created by potrace 1.10, written by Peter Selinger 2001-2011 On peut supprimer la r√®gle avec l\u0026rsquo;option -r : xdp-filter ip -m src -r 10.10.0.10 Avec cet exemple, il faut bien comprendre que les programmes XDP fonctionnent uniquement √† l\u0026rsquo;arriv√©e de l\u0026rsquo;interface (ingress). Ainsi l\u0026rsquo;IP source est 10.0.0.10 et l\u0026rsquo;IP destination est toujours 10.0.0.1.\nSi on avait voulu emp√™cher lb de pinger en cr√©ant un programme XDP sur l\u0026rsquo;interface jumelle veth1, on aurait d√ª lancer la commande suivante :\nxdp-filter ip -m dst 10.0.0.10 En effet, l\u0026rsquo;ip source est maintenant l\u0026rsquo;IP de l\u0026rsquo;interface veth0 et l\u0026rsquo;IP destination est l\u0026rsquo;ip o√π envoie le echo reply c\u0026rsquo;est √† dire 10.0.0.10.\nV√©rifiez tout de m√™me que le ping ne fonctionne plus :\nip netns exec lb ping -c 3 10.0.0.1 Mais qu\u0026rsquo;on peut toujours pinger depuis un autre namespace :\nip netns exec h2 ping -c 3 10.0.0.1 On peut le voir avec xdp-filter status :\nCURRENT XDP-FILTER STATUS: Aggregate per-action statistics: XDP_ABORTED 0 pkts 0 KiB XDP_DROP 5 pkts 0 KiB XDP_PASS 16 pkts 1 KiB Loaded on interfaces: Enabled features xdpfilt_alw_all veth0 (native mode) tcp,udp,ipv6,ipv4,ethernet,allow Filtered ports: Mode Hit counter Filtered IP addresses: Mode Hit counter 10.0.0.10 src 5 Filtered MAC addresses: Mode Hit counter \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rDans le prochain √©pisode, nous allons montrer comment recr√©er la commande xdp-filter avec Aya. Anatomie d\u0026rsquo;un paquet r√©seau # Maintenant qu\u0026rsquo;on a r√©ussi √† cr√©er des programmes XDP avec xdp-filter, une autre difficult√© qui va appara√Ætre assez rapidement quand on va essayer de r√©ellement d√©velopper un programme XDP, c\u0026rsquo;est les connaissances en r√©seau. Comme je l\u0026rsquo;√©crivais au d√©but de l\u0026rsquo;article, avec XDP on r√©cup√®re des donn√©es bruts du paquet, il faut r√©ussir √† l\u0026rsquo;analyser en comprenant comment est architectur√© un paquet r√©seau.\nAinsi un paquet r√©seau a deux parties :\nLe messager (les en-t√™tes)¬†: les adresses IP, MAC, le protocole, le port utilis√©, etc. La partie int√©ressante pour l\u0026rsquo;ing√©nieur r√©seau. Le contenu du message (payload) : la partie int√©ressante pour l\u0026rsquo;utilisateur. Comment sont structur√©s ses en-t√™tes¬†? Par les diff√©rentes couches du mod√®le TCP/IP. √áa vous dit quelques choses¬†? Moi j\u0026rsquo;avais (presque) tout oubli√©.\nMod√®le TCP/IP # Le mod√®le TCP/IP a 4 couches :\nAcc√®s r√©seau : Filaire (Ethernet) ou sans fil (Wifi) Internet : IPv4, IPv6, ICMP, etc Transport : TCP et UDP Application : HTTP, SSH, DNS, etc XDP intervient d√®s la r√©ception de la couche 1. Le paquet encapsule les diff√©rentes couches. Ainsi le paquet sera structur√© de la mani√®re suivante :\nl\u0026rsquo;en-t√™te acc√®s r√©seau (on verra uniquement l\u0026rsquo;en-t√™te ethernet : ethernet header¬†(ethhdr)), il va permettre de savoir si on est en IPv4 ou en IPv6 l\u0026rsquo;en-t√™te internet (par exemple : internet protocol header¬†(iphdr)), il va permettre de savoir si on est en UDP, TCP ou ICMP l\u0026rsquo;en-t√™te transport (par exemple : transmission control protocol header¬†(tcphdr)), il va permettre de savoir sur quel port on est par exemple. l\u0026rsquo;en-t√™te applicative est beaucoup moins standard, nous n\u0026rsquo;irons pas jusque l√†. Voici par exemple les diff√©rentes en-t√™tes pour une requ√™te DNS :\nAinsi pour cr√©er un programme XDP, il faut se balader sur les diff√©rentes en-t√™tes du paquet et r√©cup√©rer un √©l√©ment particulier de l\u0026rsquo;en-t√™te.\nL\u0026rsquo;en-t√™te d\u0026rsquo;UDP est compos√©e des √©l√©ments suivants :\nPort source : depuis quel port le paquet est envoy√© (un port variable d√©finit par l\u0026rsquo;application) Port destination : √† quel port le paquet doit √™tre envoy√© (par exemple le port 53 pour le DNS) Longueur : longueur total du segment UDP (en-t√™te + payload) Checksum : v√©rification de l\u0026rsquo;int√©grit√© du paquet. Une fois qu\u0026rsquo;on a r√©cup√©r√© l\u0026rsquo;√©l√©ment cible, nous pourrons d√©cider par exemple si nous bloquons l\u0026rsquo;acc√®s au paquet.\nDans cet √©pisode, on a vu les bases d\u0026rsquo;XDP : √† quoi cela sert, son histoire, qui l\u0026rsquo;utilise et les pr√©-requis pour d√©buter un programme XDP.\nTout cela vous para√Æt abstrait ? Nous allons maintenant passer √† la pratique dans l\u0026rsquo;√©pisode suivant : on va cr√©er un petit firewall XDP avec Aya !\n","date":"16 octobre 2025","externalUrl":null,"permalink":"/ebpf-another-type/xdp/intro/","section":"Ebpf-Another-Types","summary":"D√©couverte de XDP avec Aya","title":"XDP, le firewall ultra rapide de Linux","type":"ebpf-another-type"},{"content":"","date":"23 septembre 2025","externalUrl":null,"permalink":"/series/apprenons-uprobe-avec-ebpf-et-aya/","section":"Series","summary":"","title":"Apprenons UProbe Avec EBPF Et Aya","type":"series"},{"content":"Nous avons vu ce qu\u0026rsquo;√©tait un programme de type uProbe dans la premi√®re partie. Cela peut √™tre ainsi un moyen de profiler un programme.\nLe but de cet article est donc de regarder le temps que met une fonction d\u0026rsquo;un programme √©crit en Rust √† s\u0026rsquo;ex√©cuter.\nCela permettra √©galement de voir la diff√©rence avec un programme √©crit en Go pour la r√©cup√©ration des points d\u0026rsquo;attache des programmes eBPF de type uProbe.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rJe suppose que vous √™tes d√©j√† dans un environnement pour d√©velopper avec Aya et que vous avez install√© bpftrace.\nSi ce n\u0026rsquo;est pas le cas, vous pouvez utiliser le lab Killercoda :\nPr√©sentation du programme Rust pour tester les uProbes # Calculer les d√©cimales de ùõë # Avant de cr√©er le programme eBPF, nous allons donc d√©j√† r√©cup√©rer un petit programme en Rust.\nPour que √ßa soit un peu plus inventif qu\u0026rsquo;un programme hello world, j\u0026rsquo;ai choisi un programme qui affiche une estimation du nombre ùõë. En faisant varier le nombre de d√©cimal, on peut facilement changer la dur√©e d\u0026rsquo;ex√©cution de la fonction.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Le nombre ùõë (Pi) est un nombre qui permet, par exemple, de calculer le p√©rim√®tre d\u0026rsquo;un cercle. Ce nombre a la particularit√© d\u0026rsquo;avoir une infinit√© de d√©cimales ce qui rend leur calcul complexe. En 2022, on en a d√©termin√© les 100 mille milliards premi√®res d√©cimales. Voici les commandes pour le r√©cup√©rer et le compiler :\ngit clone https://github.com/littlejo/pi_digits_rust cd pi_digits_rust cargo build Pour tester le binaire g√©n√©r√©, on peut alors lancer la commande suivante :\n./target/debug/pi_digits_pure_rust 10 #Pour avoir 10 d√©cimales de Pi Ce qui r√©pond :\n3.1415926536 On a bien 10 d√©cimales.\nLe but de cet article est de r√©cup√©rer le temps que met la fonction d√©di√©e au calcul des d√©cimales de Pi (pi_times_10n_rounded()).\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rVous pouvez tester pour un autre programme compil√© comme C/C++, Go, Zig ou V de votre choix pour comparer. Comment va-t-on proc√©der ? # Pour cela nous allons utiliser :\nun programme de type uProbe pour mesurer le temps √† l\u0026rsquo;arriv√©e de la fonction un programme de type uRetProbe pour mesurer le temps √† la sortie de la fonction Ainsi en soustrayant le temps d\u0026rsquo;entr√©e du temps de sortie, on va trouver la dur√©e totale pour calculer les d√©cimales de ùõë.\nAvant cela, il faut d\u0026rsquo;abord trouver le point d\u0026rsquo;attache pour ce programme √©crit en Rust pour ces deux programmes eBPF.\nTrouver le point d\u0026rsquo;attache # Maintenant qu\u0026rsquo;on a cr√©√© et compil√© le petit programme, il faut trouver comment d√©clencher le programme eBPF de type uProbe ou uRetProbe. Lorsqu\u0026rsquo;on utilise cargo generate pour le repo aya, il faut r√©pondre √† deux questions : o√π se trouve le nom du binaire et quelle fonction observ√©e. Voyons cela en d√©tail.\nNom du binaire # ü§∑ Target to attach the (u|uret)probe? (e.g libc): Pour garantir la portabilit√© du programme eBPF, il faut r√©pondre le chemin absolu du binaire. Par exemple je l\u0026rsquo;ai cr√©√© l√† : /home/cloud_user/pi_digits/target/debug/pi_digits_pure_rust.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Comme le chemin est un peu long, pour la suite, le nom du binaire sera en chemin relatif pour une meilleur lisibilit√© de l\u0026rsquo;article : ./pi_digits_pure_rust) Nom de la fonction # ü§∑ Function name to attach the (u|uret)probe? (e.g getaddrinfo): Que faut-il r√©pondre ?\nOn l\u0026rsquo;a d√©j√† vu : on peut utiliser la commande bpftrace, par exemple :\nbpftrace -l \\ \u0026#39;uprobe:./pi_digits_pure_rust:*pi_times*\u0026#39; On trouve alors :\nuprobe:./pi_digits_pure_rust:pi_times_10n_rounded La fonction est donc bien pi_times_10n_rounded.\nAstuces # Si vous √™tes attentifs, dans la deuxi√®me partie, on avait vu que, par d√©faut, le compilateur Go :\ninlinait les fonctions et donc on ne pouvait pas les voir On a d√ª rajouter l\u0026rsquo;option de compilation -l pour emp√™cher cela modifiait le nom de la fonction (mangle) On a d√ª rajouter l\u0026rsquo;option de compilation -N pour emp√™cher cela Rappelons ce qu\u0026rsquo;est un inline (ici avec le compilateur Go) via un sch√©ma :\nRust fait √©galement cela par d√©faut. Mais ce n\u0026rsquo;est pas au niveau global que je l\u0026rsquo;ai fait mais pour la fonction en particulier.\nJ\u0026rsquo;ai ainsi d√ª rajouter deux attributs dans le code devant la fonction cible :\n#[no_mangle] #[inline(never)] pub fn pi_times_10n_rounded(n: usize) -\u0026gt; num_bigint::BigInt { //[...] } #[no_mangle] : ne pas modifier le nom de la fonction #[inline(never)] : ne jamais inliner la fonction Maintenant qu\u0026rsquo;on a d√©fini le point d\u0026rsquo;attache. Nous allons pouvoir commencer √† cr√©er nos deux programmes eBPF.\nR√©cup√©rons le temps de lancement des programmes eBPF # Commen√ßons simple en cr√©ant les deux programmes eBPF et en r√©cup√©rant juste leur temps de lancement.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e Suite de l‚Äôarticle r√©serv√©e aux membres premium ‚ú®\nL‚Äôarticle complet est accessible uniquement aux membres premium.\nDevenir membre premium, c‚Äôest simple : il suffit de faire un petit don üíñ\nEn √©change, vous aurez pendant 1 an (offre early bird) :\nAcc√®s √† tous les articles complets d√®s leur publication Lecture anticip√©e avant la mise en ligne publique Participation au soutien de ce blog ind√©pendant Acc√®s exclusif √† mes photos de vacances √† Duba√Ø Votre don permet de :\nMe rendre moins d√©pendant des grandes plateformes M‚Äôencourager √† cr√©er plus de contenu technique Lever le paywall plus rapidement pour tous üëâ Devenir membre premium d√®s maintenant\n","date":"23 septembre 2025","externalUrl":null,"permalink":"/ebpf-another-type/uprobe/example-3-tr/","section":"Ebpf-Another-Types","summary":"","title":"Profilons un petit programme avec des uProbes","type":"ebpf-another-type"},{"content":"","date":"23 septembre 2025","externalUrl":null,"permalink":"/tags/uprobe/","section":"Tags","summary":"","title":"Uprobe","type":"tags"},{"content":"","date":"23 septembre 2025","externalUrl":null,"permalink":"/tags/uretprobe/","section":"Tags","summary":"","title":"Uretprobe","type":"tags"},{"content":"","date":"23 septembre 2025","externalUrl":null,"permalink":"/en/series/getting-started-with-ebpf-uprobes-in-aya/","section":"Series","summary":"","title":"Getting Started With EBPF UProbes in Aya","type":"series"},{"content":"Nous avons vu ce qu\u0026rsquo;√©tait un programme de type uProbe dans la premi√®re partie : √ßa peut √™tre un moyen de sonder une biblioth√®que.\nNous allons v√©rifier cela avec un programme Aya qui va r√©cup√©rer les diff√©rents arguments de la fonction execve() de la Libc.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rJe suppose que vous √™tes d√©j√† dans un environnement pour d√©velopper avec Aya et que vous avez install√© bpftrace. Si ce n\u0026rsquo;est pas le cas, vous pouvez utiliser le lab Killercoda :\nQue va-t-on vraiment faire ? # Libc # Contrairement √† la pr√©c√©dente partie o√π on a attach√© notre programme eBPF √† un programme, l√† nous l\u0026rsquo;attachons √† une biblioth√®que partag√©e.\nLa libc est la biblioth√®que standard du C. Donc √† chaque fois qu\u0026rsquo;un programme en C (ou en C++) est ex√©cut√©, potentiellement, un programme eBPF pourra √™tre lanc√©.\n\u003c?xml version=\"1.0\" encoding=\"iso-8859-1\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rJe parle de libc tout au long du chapitre. Pour √™tre plus pr√©cis, il faudrait parler de la glibc (GNU C Library) l\u0026rsquo;impl√©mentation la plus r√©pandue dans les distributions GNU/Linux (Comme Debian ou Red Hat). Mais il y a d\u0026rsquo;autres impl√©mentations comme musl (notamment pour Alpine Linux) ou ulibc qui sont plus l√©g√®res et adapt√©es pour les syst√®mes embarqu√©s. La fonction execve # execve est un appel syst√®me (un syscall) du noyau Linux. Mais c\u0026rsquo;est aussi le nom d\u0026rsquo;une fonction de la libc qui fait appel √† ce m√™me syscall (un wrapper). Ainsi, √† chaque fois que la fonction execve() de la libc sera appel√©e, notre programme eBPF de type uProbe sera lanc√©.\nLes arguments de la fonction execve # Nous devons √©galement r√©cup√©rer les diff√©rents arguments de la fonction execve().\nPour trouver ses arguments, on peut √©videmment regarder dans le code source de la libc. Mais il y a plus simple :\nman execve La partie qui nous int√©resse est la suivante :\nint execve(const char *pathname, char *const _Nullable argv[], char *const _Nullable envp[]); On voit que la fonction a trois arguments :\npathname: le nom de la commande avec le chemin complet (exemple /bin/bash). Il est de type const char * (√©quivalent en Rust √† *const u8). argv: un tableau d\u0026rsquo;arguments de la commande. Il est de type char *const _Nullable[] (√©quivalent en Rust √† *const *const u8) argv[0] : le nom de la commande argv[1] : la premi√®re option etc. envp : un tableau de variables d\u0026rsquo;environnement de la commande. Il est de type char *const _Nullable[] (√©quivalent en Rust √† *const *const u8). \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e _Nullable indique simplement que la valeur peut √™tre NULL. Comment d√©clencher le programme eBPF ? # Prenons un exemple simple. Si tu lances une commande dans un terminal par exemple ls, que va-t-il se passer ?\nGr√¢ce √† la variable d\u0026rsquo;environnement PATH, le shell (par exemple le bash) va trouver le bon chemin pour trouver o√π se trouve le binaire ls : /usr/bin/ls Pour ex√©cuter le binaire, le shell va alors appeler la fonction execve() de la libc : execve(\u0026#34;/usr/bin/ls\u0026#34;, [\u0026#34;ls\u0026#34;], [\u0026#34;PATH=/bin:/usr/bin\u0026#34;, ...]) Le programme eBPF sera enfin d√©clench√©. Voici un petit r√©sum√© de tout cela :\nIl y a √©videmment d\u0026rsquo;autres programmes que des shells qui appellent la fonction execve() de la libc comme systemd pour le d√©marrage des diff√©rents programmes d\u0026rsquo;un syst√®me Linux.\nAinsi nous allons cr√©er un programme tr√®s proche de celui qu\u0026rsquo;on avait cr√©√© avec le Tracepoint sys_enter_execve lors des articles d\u0026rsquo;initiation √† eBPF mais celui-ci sera attach√© au niveau utilisateur √† la fonction execve() de la libc.\nG√©n√©rons un programme Aya de type uProbe # Nous avons donc d√©j√† les r√©ponses aux deux questions :\nü§∑ Target to attach the (u|uret)probe? (e.g libc): ü§∑ Function name to attach the (u|uret)probe? (e.g getaddrinfo): Voyons comment cr√©er un programme eBPF hello world pour ce point d\u0026rsquo;attache.\nTestons avec bpftrace # V√©rifions d\u0026rsquo;abord que √ßa fonctionne avec la ligne de commande bpftrace :\nsudo bpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;Hello execve\\n\u0026#34;); }\u0026#39; uprobe : le type de programme eBPF libc : le nom de la biblioth√®que execve : la fonction √† debugger { printf(\u0026quot;Hello execve\\n\u0026quot;); } : le code bpftrace √Ä chaque fois qu\u0026rsquo;on lance une commande sur un autre terminal, on voit bien Hello execve.\nMaintenant faisons-le avec Aya.\nG√©n√©ration et compilation du programme Aya # La commande cargo generate suivante permet ainsi de g√©nerer le programme eBPF :\ncargo generate --name test-uprobe-2 \\ -d program_type=uprobe \\ -d uprobe_target=libc \\ -d uprobe_fn_name=execve \\ https://github.com/aya-rs/aya-template \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rPour trouver le nom des arguments (uprobe_target et uprobe_fn_name), vous pouvez regarder le fichier test.sh dans le repo aya-template. Maintenant compilons le et installons le dans le noyau Linux :\ncd test-uprobe-2/ RUST_LOG=info cargo run Test du programme # Sur un autre terminal, lancer un programme quelconque :\nls Sur le terminal cargo run vous verrez :\n[INFO test_uprobe] function execve called by libc Dans la partie pr√©c√©dente, on √©tait rest√© √† ce point concernant les uProbes. Regardons comment r√©cup√©rer les diff√©rentes arguments de la fonction execve(). Commen√ßons par le premier : le nom du binaire.\nR√©cup√©rons le nom du binaire # Testons avec bpftrace # Avant de modifier le code Aya, regardons comment on fait avec bpftrace. C\u0026rsquo;est un poil plus compliqu√© qu\u0026rsquo;un simple hello world.\nPour r√©cup√©rer le premier argument, on utilise arg0 :\nsudo bpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;%d\\n\u0026#34;, arg0); }\u0026#39; On r√©cup√®re l\u0026rsquo;adresse o√π se trouve le premi√®re argument. Comment le \u0026ldquo;convertir\u0026rdquo; en cha√Æne de caract√®res ? Il suffit d\u0026rsquo;utiliser la fonction str() :\nsudo bpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;%s\\n\u0026#34;, str(arg0)); }\u0026#39; Maintenant qu\u0026rsquo;on a le brouillon avec bpftrace, regardons comment l\u0026rsquo;impl√©menter avec Aya.\nModifions le code Aya # Nous devons modifier la fonction suivante du fichier test-uprobe-2-ebpf/src/main.rs:\nfn try_test_uprobe_2(ctx: ProbeContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { info!(\u0026amp;ctx, \u0026#34;function execve called by libc\u0026#34;); Ok(0) } Il faut donc chercher √† manipuler la variable ctx. Voici la documentation :\nIl n\u0026rsquo;y a qu\u0026rsquo;une m√©thode qui nous int√©resse :\nLe premier √©l√©ment est le nom du binaire qui est ex√©cut√©.\nIl faut donc rajouter un truc comme √ßa :\nlet arg0: *const u8 = ctx.arg(0).ok_or(1u32)?; \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rOn utilise le type *const u8 car le premier argument est de type const char * en C (cf man execve) Pour \u0026ldquo;convertir\u0026rdquo; ce pointeur en cha√Æne de caract√®re on va le faire de fa√ßon similaire qu\u0026rsquo;on avait fait avec les Tracepoints dans l\u0026rsquo;article d\u0026rsquo;initiation √† la cr√©ation de programme eBPF avec Aya.\nAinsi on se retrouve avec le code suivant :\nfn try_test_uprobe_2(ctx: ProbeContext) -\u0026gt; Result\u0026lt;u32, i64\u0026gt; { let arg0: *const u8 = ctx.arg(0).ok_or(1u32)?; let mut buf = [0u8; 128]; let filename = unsafe { let filename_bytes = bpf_probe_read_user_str_bytes(arg0, \u0026amp;mut buf)?; from_utf8_unchecked(filename_bytes) }; info!(\u0026amp;ctx, \u0026#34;function execve called by libc {}\u0026#34;, filename); Ok(0) } √Ä l\u0026rsquo;√©poque ce n\u0026rsquo;√©tait pas tr√®s clair dans mon esprit.\nExpliquons en d√©tail ce code :\nla fonction helper bpf_probe_read_user_str_bytes() permet de lire l\u0026rsquo;adresse m√©moire depuis l\u0026rsquo;espace utilisateur et de r√©cup√©rer son contenu avec un slice d\u0026rsquo;octets. On a besoin d\u0026rsquo;un buffer pour cela. from_utf8_unchecked() permet de convertir un slice d\u0026rsquo;octets en un \u0026amp;str (la version sans v√©rification car sinon le verifier eBPF n\u0026rsquo;accepte pas) Pour finir, voici un petit sch√©ma qui explique comment r√©cup√©rer une chaine de caract√®res depuis l\u0026rsquo;espace utilisateur :\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Notez le nom de la fonction bpf_probe_read_user_str_bytes qui prend tout son sens pour une uProbe. Testons maintenant la modification # V√©rifions que le code fonctionne toujours :\nRUST_LOG=info cargo run Sur un autre terminal, lan√ßons une commande quelconque :\nls Sur le terminal cargo run vous verrez :\n[INFO test_uprobe_2] function execve called by libc /usr/bin/ls Nous √©tions rest√© √† ce niveau l√† pour les articles d\u0026rsquo;initiation √† eBPF avec Aya. Mais nous aurions √©galement pu aller plus loin en r√©cup√©rant les options de la commande et ses variables d\u0026rsquo;environnement. Voyons comment le faire.\nR√©cup√©rons les options de la commande # Testons avec bpftrace # Avant de le faire avec Aya, nous allons regarder comment le faire avec bpftrace. Pour r√©cup√©rer le deuxi√®me argument, on doit utiliser arg1. Comme arg1 est un pointeur de pointeur. On ne peut pas utiliser directement la fonction str(). Il faut d√©r√©f√©rencer arg1 pour avoir un seul pointeur. Pour cela, il suffit d\u0026rsquo;utiliser *.\nCe qui nous fait :\nbpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;%s\\n\u0026#34;, str(*arg1)); }\u0026#39; On r√©cup√®re alors le premier √©l√©ment du tableau qui est le nom de la commande. Il faut donc se d√©placer dans le tableau si on veut r√©cup√©rer les diff√©rentes options. Chaque √©l√©ment a une taille de 8 octets (uniquement valable en 64 bits).\nPour aller au deuxi√®me √©l√©ment du tableau, c\u0026rsquo;est √† dire √† la premi√®re option, il suffit de se d√©placer de 8 octets (en ajoutant 8) :\nbpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;%s\\n\u0026#34;, str(*(arg1+8))); }\u0026#39; Vous allez voir que la difficult√© va √™tre sensiblement la m√™me en Rust.\nModifions le code Aya # Avec Aya, pour r√©cup√©rer le deuxi√®me argument, il faut rajouter ce bout de code :\nlet argv: *const *const u8 = ctx.arg(1).ok_or(1u32)?; Comment r√©cup√©rer la ni√®me option de la commande ? Il faut utiliser la fonction add pour pouvoir d√©caler son pointeur vers la bonne adresse m√©moire :\nPar exemple, pour r√©cup√©rer la premi√®re option, on va d√©caler de 1 :\nlet argv1 = argv.add(1); \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rContrairement √† bpftrace o√π il faut d√©caler du nombre d\u0026rsquo;octets (8 en 64 bits car 8x8=64 bits). La fonction add() permet de se d√©placer d\u0026rsquo;addresse m√©moire de 1 par 1 sans tenir compte de l\u0026rsquo;architecture. Par contre argv1 est encore de structure *const *const u8. Il faut maintenant d√©r√©f√©rencer pour obtenir *const u8.\nIl y a une fonction toute pr√™te pour cela :\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e La fonction helper bpf_probe_read_user permet de lire le contenu stock√© dans le pointeur depuis l\u0026rsquo;espace utilisateur et de renvoyer une copie de sa valeur. On a donc :\nlet argv1_deref: *const u8 = bpf_probe_read_user(argv1)?; Maintenant que argv1_deref est de structure *const u8, il faut le transformer en \u0026amp;str. On se retrouve alors avec un code similaire √† la r√©cup√©ration du nom du binaire. √áa serait probablement utile de cr√©er une fonction pour un projet \u0026ldquo;s√©rieux\u0026rdquo;.\nVoici le code complet pour r√©cup√©rer la premi√®re option :\nlet argv: *const *const u8 = ctx.arg(1).ok_or(0u32)?; //arg1 let mut buf = [0u8; 16]; let argname = unsafe { let argv1 = argv.add(1); //arg1+8 let argv1_deref: *const u8 = bpf_probe_read_user(argv1)?; //*(arg1+8) let argname_bytes = bpf_probe_read_user_str_bytes(argv1_deref, \u0026amp;mut buf)?; from_utf8_unchecked(argname_bytes) //str(*(arg1+8)) }; info!(\u0026amp;ctx, \u0026#34;function execve called by libc {}\u0026#34;, argname); //printf(\u0026#34;%s\\n\u0026#34;, str(*(arg1+8))); \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e En commentaire j\u0026rsquo;ai mis le code √©quivalent avec bpftrace. Testons maintenant la modification # V√©rifions que le code fonctionne toujours :\nRUST_LOG=info cargo run Sur un autre terminal, lan√ßons une commande avec une option :\nls -lrt Sur le terminal cargo run vous verrez :\n[INFO test_uprobe_2] function execve called by libc /usr/bin/ls [INFO test_uprobe_2] function execve called by libc -lrt C\u0026rsquo;est le comportement qu\u0026rsquo;on voulait.\nSi on lance une commande sans option que se passe-t-il ?\nman Sur le terminal cargo run vous ne verrez que :\n[INFO test_uprobe_2] function execve called by libc /usr/bin/man Que s\u0026rsquo;est-il pass√© ?\nCette partie du code ne s\u0026rsquo;est pas affich√©e :\ninfo!(\u0026amp;ctx, \u0026#34;function execve called by libc {}\u0026#34;, argname); Comme la commande n\u0026rsquo;a pas d\u0026rsquo;argument, cette partie du code est partie en erreur :\nlet argname = unsafe { let argv1 = argv.add(1); //arg1+8 let argv1_deref: *const u8 = bpf_probe_read_user(argv1)?; //*(arg1+8) let argname_bytes = bpf_probe_read_user_str_bytes(argv1_deref, \u0026amp;mut buf)?; from_utf8_unchecked(argname_bytes) //str(*(arg1+8)) }; Et donc le programme est parti en erreur et n\u0026rsquo;a jamais parcouru le dernier info.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rLa r√©cup√©ration des variables d\u0026rsquo;environnement de la commande est tr√®s similaire vu qu\u0026rsquo;il est du m√™me type que pour les arguments. Cet √©pisode est maintenant termin√© ! Nous avons vu comment r√©cup√©rer les arguments d\u0026rsquo;une fonction d\u0026rsquo;un programme en C notamment pour des cha√Ænes de caract√®res et des tableaux de cha√Ænes de caract√®re et comment les afficher.\nDans le prochain √©pisode, nous allons voir comment profiler une fonction d\u0026rsquo;un programme.\n","date":"23 septembre 2025","externalUrl":null,"permalink":"/ebpf-another-type/uprobe/example-2/","section":"Ebpf-Another-Types","summary":"Sondons la fonction \u003ccode\u003eexecve\u003c/code\u003e dans la libc avec un programme eBPF de type uProve et avec Aya","title":"Sondons une biblioth√®que avec une uProbe","type":"ebpf-another-type"},{"content":"","date":"15 septembre 2025","externalUrl":null,"permalink":"/tags/go/","section":"Tags","summary":"","title":"Go","type":"tags"},{"content":"Nous avons vu ce qu\u0026rsquo;√©tait un programme de type uProbe dans la premi√®re partie : un moyen de sonder les fonctions de vos programmes.\nDans cette partie, nous allons d\u0026rsquo;abord cr√©er un programme tr√®s simple en Go et nous allons le faire r√©agir avec deux programmes eBPF :\nLe premier de type uProbe Le deuxi√®me de type uRetProbe \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rJe suppose que vous √™tes d√©j√† dans un environnement pour d√©velopper avec Aya et que vous avez install√© le compilateur go et bpftrace. Si ce n\u0026rsquo;est pas le cas, vous pouvez utiliser le lab Killercoda :\nCr√©ons un programme pour tester les uProbes # Un code tout simple # Pour changer du Rust, nous allons cr√©er un petit programme en Go :\n// hello.go package main import \u0026#34;fmt\u0026#34; func hello() int { fmt.Println(\u0026#34;Hello, world!\u0026#34;) return 3 } func main() { ret := hello() fmt.Println(\u0026#34;Returned:\u0026#34;, ret) } \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rVous pouvez tester pour un autre programme compil√© comme C/C++ ou Rust si vous pr√©f√©rez. Comment va-t-on activer des uProbes ? # Le but de l\u0026rsquo;article est d\u0026rsquo;activer :\nun programme eBPF de type uProbe √† chaque fois que l\u0026rsquo;on rentre dans la fonction hello() : un programme eBPF de type uRetProbe √† chaque fois que l\u0026rsquo;on sort de la fonction hello() : Maintenant qu\u0026rsquo;on a vu les tenants et les aboutissants de l\u0026rsquo;article, passons √† la compilation du programme.\nCompilons le programme # Pour le compiler, il suffit de taper :\ngo build -gcflags=\u0026#34;all=-N -l\u0026#34; -o hello hello.go On peut remarquer qu\u0026rsquo;on a ajout√© une option -gcflags=\u0026quot;all=-N -l\u0026quot;. Normalement, on n\u0026rsquo;a pas besoin d\u0026rsquo;utiliser cette option pour compiler un programme Go :\ngo build -o hello hello.go Cela fonctionne √©galement. Mais alors pourquoi utiliser cette option ?\n-gcflags veut dire go compiler flags ce sont des options pass√©es au compilateur Go. all permet de dire que les options s\u0026rsquo;appliquent √† tous les packages compil√©s. Les options sp√©cifi√©es au compilateur Go sont :\n-N : par d√©faut, le compilateur modifie (mangle) le nom de la fonction. Cette option permet de d√©sactiver cette modification. En anglais, to mangle peut se traduire par modifier, mutiler ou m√™me d√©figurer. En informatique, name mangling se traduit par d√©coration de nom. On a compl√®tement gomm√© le c√¥t√© p√©joratif du terme ! -l : par d√©faut, le compilateur inline les fonctions c\u0026rsquo;est √† dire qu\u0026rsquo;elle int√®gre directement le contenu de la fonction dans le code appelant permettant ainsi aux programmes d\u0026rsquo;√™tre plus performants. Cette option permet de d√©sactiver cet inline. Ainsi ces options vont nous permettre de garder les fonctions et de les rendre lisible, ce qui va nous simplifier pour trouver le point d\u0026rsquo;attache pour notre programme eBPF.\nComment trouver le point d\u0026rsquo;attache ? # Maintenant qu\u0026rsquo;on a cr√©√© et compil√© le petit programme, il faut trouver comment d√©clencher le programme eBPF de type uProbe ou uRetProbe. Lorsqu\u0026rsquo;on utilise cargo generate pour le repo aya, il faut r√©pondre √† deux questions : o√π se trouve le nom du binaire et quelle fonction observ√©e. Voyons cela en d√©tail.\nNom du binaire # ü§∑ Target to attach the (u|uret)probe? (e.g libc): Pour garantir la portabilit√© du programme eBPF, il faut r√©pondre le chemin absolu du binaire. Par exemple je l\u0026rsquo;ai cr√©√© l√† : /home/cloud_user/hello.\nNom de la fonction # Une fois que tu as r√©pondu √† la premi√®re question, il reste une seconde question :\nü§∑ Function name to attach the (u|uret)probe? (e.g getaddrinfo): Que faut-il r√©pondre ? On serait tent√© de r√©pondre hello vu qu\u0026rsquo;on a mis l\u0026rsquo;option -N qui d√©sactive la d√©coration de nom lors de la compilation.\nMais c\u0026rsquo;est un peu plus compliqu√©. Le compilateur Go modifie tout de m√™me l√©g√®rement le nom de la fonction pendant l\u0026rsquo;√©tape de compilation.\nNous l\u0026rsquo;avons vu dans le pr√©c√©dent √©pisode pour trouver toutes les fonctions d\u0026rsquo;un binaire, il suffit d\u0026rsquo;utiliser bpftrace :\nbpftrace -l \u0026#39;uprobe:/home/cloud_user/hello:*\u0026#39; l\u0026rsquo;option -l permet de lister toutes les probes disponibles uprobe : le type de programme eBPF /home/cloud_user/hello : l\u0026rsquo;emplacement du binaire * : le joker (0 ou plusieurs caract√®res) Le format d\u0026rsquo;affichage est alors :\nuprobe:/home/cloud_user/hello:[fonction1] uprobe:/home/cloud_user/hello:[fonction2] uprobe:/home/cloud_user/hello:[fonction3] uprobe:/home/cloud_user/hello:[fonction4] etc C\u0026rsquo;est pas de bol : le nom de la fonction est le m√™me que le nom de mon fichier\u0026hellip; On ne peut pas faire de | grep hello. Comment s\u0026rsquo;en sortir ? avec awk, cut ou pire une regex ? Faisons simple :\nbpftrace -l \u0026#39;uprobe:/home/cloud_user/hello:*hello*\u0026#39; Et √ßa va vous r√©pondre :\nuprobe:/home/cloud_user/hello:main.hello Ainsi le nom r√©el de la fonction est main.hello\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Si vous ne pouvez pas installer bpftrace, vous pouvez utiliser la commande nm. Elle permet de voir tous les symboles qui sont pr√©sents dans un fichier binaire. Maintenant qu\u0026rsquo;on a la r√©ponse aux deux questions, nous pouvons cr√©er nos programmes eBPF.\nCommen√ßons par le programme de type uProbe.\nCr√©ons un programme eBPF de type uProbe # Testons avec bpftrace # Avant de foncer t√™te baiss√©e sur un programme Aya, v√©rifions que √ßa fonctionne bien avec bpftrace, le programme qui cr√©e en une ligne de commande un programme eBPF. √áa tombe bien : on a d√©j√† trouv√© le d√©but dans la section pr√©c√©dente :\nuprobe:/home/cloud_user/hello:main.hello Il reste plus qu\u0026rsquo;√† compl√©ter par un hello world :\nsudo bpftrace -e \\ \u0026#39;uprobe:/home/cloud_user/hello:main.hello { printf(\u0026#34;Hello go\\n\u0026#34;); }\u0026#39; Historiquement, il fallait avoir les droits root pour installer un programme eBPF dans le noyau. Avec un Linux moderne, un utilisateur non root peut installer un programme eBPF avec juste quelques capacit√©s suppl√©mentaires comme CAP_BPF. Cependant bpftrace ne g√®re pas cela : il faut √™tre en root. Dans un autre terminal, lan√ßons alors le programme hello (sans les droits root) :\n./hello Sur le terminal o√π est lanc√© bpftrace, vous voyez Hello go √† chaque fois que vous lancez le programme hello.\nVerifions qu\u0026rsquo;on peut cr√©er un programme similaire avec Aya.\nG√©n√©ration du programme Aya # D√©finissons d√©j√† les diff√©rentes r√©ponses pour le point d\u0026rsquo;attache dans des variables, pour mon cas √ßa sera :\ntarget=/home/cloud_user/hello fn_name=main.hello Lan√ßons maintenant la commande pour g√©n√©rer le programme Aya :\ncargo generate --name test-uprobe \\ -d program_type=uprobe \\ -d uprobe_target=$target \\ -d uprobe_fn_name=$fn_name \\ https://github.com/aya-rs/aya-template Sans les options qu\u0026rsquo;on lui a indiqu√©, cargo generate fonctionnerait en mode interactif : on devrait r√©pondre √† des questions.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rPour trouver le nom des arguments (uprobe_target et uprobe_fn_name), vous pouvez regarder le fichier test.sh dans le repo aya-template. Vous aurez la sortie suivante :\nüîß program_type: \u0026#34;uprobe\u0026#34; (value from CLI) üîß uprobe_target: \u0026#34;/home/cloud_user/hello\u0026#34; (value from CLI) üîß uprobe_fn_name: \u0026#34;main.hello\u0026#34; (value from CLI) üîß Destination: /home/cloud_user/test-uprobe ... üîß project-name: test-uprobe ... üîß Generating template ... [ 1/23] Done: .gitignore [ 2/23] Done: Cargo.toml [ 3/23] Done: LICENSE-APACHE [ 4/23] Done: LICENSE-GPL2 [ 5/23] Done: LICENSE-MIT [ 6/23] Done: README.md [ 7/23] Ignored: pre-script.rhai [ 8/23] Done: rustfmt.toml [ 9/23] Done: test-uprobe/Cargo.toml [10/23] Done: test-uprobe/build.rs [11/23] Done: test-uprobe/src/main.rs [12/23] Done: test-uprobe/src [13/23] Done: test-uprobe [14/23] Done: test-uprobe-common/Cargo.toml [15/23] Done: test-uprobe-common/src/lib.rs [16/23] Done: test-uprobe-common/src [17/23] Done: test-uprobe-common [18/23] Done: test-uprobe-ebpf/Cargo.toml [19/23] Done: test-uprobe-ebpf/build.rs [20/23] Done: test-uprobe-ebpf/src/lib.rs [21/23] Done: test-uprobe-ebpf/src/main.rs [22/23] Done: test-uprobe-ebpf/src [23/23] Done: test-uprobe-ebpf üîß Initializing a fresh Git repository ‚ú® Done! New project created /home/cloud_user/test-uprobe Compilation et installation dans le noyau # Maintenant qu\u0026rsquo;on a g√©n√©r√© le programme, il faut compiler le programme et l\u0026rsquo;installer dans le noyau linux :\ncd test-uprobe/ RUST_LOG=info cargo run Pour simplifier, j\u0026rsquo;ai fait la compilation et l\u0026rsquo;installation du programme eBPF en root. Cela va prendre un peu de temps la premi√®re fois :\nUpdating crates.io index Locking 103 packages to latest compatible versions Adding which v6.0.3 (available: v8.0.0) Downloaded anstyle v1.0.11 Downloaded cfg-if v1.0.1 Downloaded anyhow v1.0.98 Downloaded either v1.15.0 Downloaded cargo_metadata v0.19.2 Downloaded version_check v0.9.5 Downloaded which v6.0.3 Downloaded socket2 v0.6.0 Downloaded mio v1.0.4 [...] warning: test-uprobe@0.1.0: Finished `release` profile [optimized] target(s) in 19.59s Finished `dev` profile [unoptimized + debuginfo] target(s) in 50.16s Running `/root/build-cache/debug/test-uprobe` Waiting for Ctrl-C... Testons maintenant # Laisser le programme Aya tourn√© et sur un autre terminal, lancer le programme que vous voulez examiner. Pour mon cas :\n./hello Sur le terminal o√π on a lanc√© la commande cargo run, Vous devriez voir la sortie suivante √† chaque fois que vous lancez le programme :\n[INFO test_uprobe] function main.hello called by /home/cloud_user/hello Vous voyez que la difficult√© est la m√™me qu\u0026rsquo;avec bpftrace mais que le temps de compilation est beaucoup plus long.\nCr√©ons un programme eBPF de type uRetProbe # Nous avons vu un exemple de programme eBPF de type uProbe o√π on n\u0026rsquo;avait pas √† modifier le code g√©n√©r√©. Nous allons maintenant complexifier l√©g√®rement avec un programme eBPF de type uRetProbe et nous allons r√©cup√©rer la valeur de retour.\nTestons avec bpftrace # Le code bpftrace est alors l√©g√®rement modifi√© :\nsudo bpftrace -e \\ \u0026#39;uretprobe:/home/cloud_user/hello:main.hello { printf(\u0026#34;retval=%d\\n\u0026#34;, retval); }\u0026#39; uprobe est donc remplac√© par uretprobe on a rajout√© la variable de retour : retval Lancer le programme hello dans un autre terminal et vous verrez dans le terminal bpftrace :\nretval=3 Regardons comment produire le programme √©quivalent en Aya.\nG√©n√©ration du programme Aya # La g√©n√©ration du code se fait de mani√®re similaire qu\u0026rsquo;avec une uProbe :\ntarget=/home/cloud_user/hello fn_name=main.hello cargo generate --name test-uretprobe \\ -d program_type=uretprobe \\ -d uprobe_target=$target \\ -d uprobe_fn_name=$fn_name \\ https://github.com/aya-rs/aya-template Compilation et installation # De la m√™me mani√®re on va compiler et installer le programme eBPF :\ncd test-uretprobe/ RUST_LOG=info cargo run √Ä la sortie de chaque fonction hello(), le programme eBPF affiche bien :\n[INFO test_uretprobe] function main.hello called by /home/cloud_user/hello Jusqu\u0026rsquo;√† pr√©sent, nous avons fait un peu pr√®s la m√™me chose que pour l\u0026rsquo;uProbe. Regardons maintenant comment r√©cup√©rer la valeur de retour 3.\nModification du code # Il faut modifier le fichier test-uretprobe-ebpf/src/main.rs : le code de l\u0026rsquo;espace noyau. En particulier ce bout de code :\nfn try_test_uretprobe(ctx: RetProbeContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { info!(\u0026amp;ctx, \u0026#34;function main.hello called by /home/cloud_user/hello\u0026#34;); Ok(0) } Il faut voir comment utiliser la structure RetProbeContext pour afficher le code retour.\nRegardons la documentation :\nIl faut donc utiliser la m√©thode ret(). On va rajouter un truc comme √ßa :\nlet retval: u32 = ctx.ret().ok_or(1u32)?; \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Si la fonction n\u0026rsquo;a pas de retour on affiche 1u32 (entier non sign√© de 32 bits) car la signature de la fonction est Result\u0026lt;u32, u32\u0026gt;. Il faut √©galement modifier la macro Aya info! pour afficher cette valeur.\nCe qui donne au final :\nfn try_test_uretprobe(ctx: RetProbeContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let retval: u32 = ctx.ret().ok_or(1u32)?; info!(\u0026amp;ctx, \u0026#34;retval={}\u0026#34;, retval); Ok(0) } Testons maintenant # Appliquons les modifications :\nRUST_LOG=info cargo run Lan√ßons la commande hello dans un autre terminal :\n./hello Et du c√¥t√© du programme Aya, on a l\u0026rsquo;affichage suivant :\n[INFO test_uretprobe] retval=3 Ce qui est coh√©rent avec ce qu\u0026rsquo;on avait trouv√© avec bpftrace.\nCet √©pisode est maintenant termin√© ! Nous avons vu les bases pour faire r√©agir un programme eBPF de type uProbe et uRetProbe lors du lancement d\u0026rsquo;un programme Go.\nCependant, nous n\u0026rsquo;avons pas encore explor√© comment r√©cup√©rer les arguments d\u0026rsquo;une fonction.\n√áa tombe bien ! Dans le prochain √©pisode, nous allons sonder une biblioth√®que bien connue en r√©cup√©rant les arguments de fonction et en les traitant !\n","date":"15 septembre 2025","externalUrl":null,"permalink":"/ebpf-another-type/uprobe/example-1/","section":"Ebpf-Another-Types","summary":"Observons un petit programme Go avec des programmes eBPF de type u‚Ä¢Ret‚Ä¢Probe et avec Aya","title":"Observons une fonction simple de ton programme avec des uProbes","type":"ebpf-another-type"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/tags/bpftrace/","section":"Tags","summary":"","title":"Bpftrace","type":"tags"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/tags/kprobe/","section":"Tags","summary":"","title":"Kprobe","type":"tags"},{"content":"Je d√©bute la programmation en eBPF avec Aya. L‚Äôid√©e de cette s√©rie d‚Äôarticles est d\u0026rsquo;apprendre un nouveau type de programme eBPF et de l\u0026rsquo;exp√©rimenter avec le framework Rust Aya.\nAujourd\u0026rsquo;hui, nous allons nous plonger dans les uProbes et les uRetProbes : des programmes eBPF qui sondent les fonctions de l\u0026rsquo;espace utilisateur sans laisser de trace.\nVous allez voir que cela peut √™tre tr√®s int√©ressant pour du profilage, du debug ou m√™me de la r√©tro-ing√©nierie.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Si tu ne connais pas eBPF, je te conseille de lire les deux premi√®res parties de ma s√©rie S‚Äôinitier √† eBPF avec Aya. Cela couvre les bases et t\u0026rsquo;aidera pour la suite de l\u0026rsquo;article. Qu\u0026rsquo;est-ce qu\u0026rsquo;une u‚Ä¢Ret‚Ä¢Probe ? # En anglais, une probe peut se traduire par une sonde pour examiner ou explorer quelque chose. En eBPF, il y en a de plusieurs types : kProbe, kRetProbe, uProbe, uRetProbe et USDT.\nkProbe : la sonde pour le kernel # Si tu consultes la documentation d\u0026rsquo;eBPF, il n\u0026rsquo;y a pas de section consacr√©e aux programmes de type uProbe ou uRetProbe. Mais il y en a une d√©di√©e √† la kProbe :\nLa kProbe a pour but d\u0026rsquo;observer des fonctions du kernel Linux. Elle peut √™tre consid√©r√©e comme la probe parente. Toutes les autres probes sont en fait le m√™me type de programme BPF_PROG_TYPE_KPROBE mais c\u0026rsquo;est juste le point d\u0026rsquo;attache qui va d√©terminer comment le programme est ex√©cut√©.\nkRetProbe : retour sur la sonde kernel # La kRetProbe est simplement d√©di√©e √† l\u0026rsquo;observation du retour des fonctions du kernel Linux. Cette sonde permet ainsi de v√©rifier si l\u0026rsquo;appel de la fonction s\u0026rsquo;est bien termin√©.\nNous avons vu bri√®vement kProbe et kRetProbe qui pourraient faire l\u0026rsquo;objet d\u0026rsquo;autres articles. Parlons maintenant des probes qui nous int√©ressent aujourd\u0026rsquo;hui : uProbe et uRetProbe.\nuProbe : la sonde pour les utilisateurs # Contrairement aux kProbes qui sont d√©di√©es √† observer les fonctions du kernel Linux, les uProbes sont d√©di√©es aux fonctions de l\u0026rsquo;espace utilisateur : User-space Probes. Par exemple, on pourrait s\u0026rsquo;en servir pour compter le nombre d\u0026rsquo;appels aux fonctions malloc et free dans un programme C.\nuProbe permet √©galement de r√©cup√©rer le contenu des arguments de la fonction observ√©e. Ainsi on pourrait regarder la quantit√© de m√©moire allou√©e √† chaque malloc ou v√©rifier que free lib√®re r√©ellement des bons pointeurs.\nAinsi les uProbes pourrait s\u0026rsquo;int√©grer √† une CI pour automatiser des v√©rifications de s√©curit√©, faciliter le debogage ou aider au diagnostic m√©moire.\n\u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rFree Medical icons\r√áa peut para√Ætre paradoxal de vouloir tracer un code utilisateur depuis l\u0026rsquo;espace noyau. Cependant cela a le m√©rite d\u0026rsquo;√™tre non intrusif car il n\u0026rsquo;y a pas besoin de modifier le programme. uRetProbe : retour sur la sonde utilisateur # De la m√™me mani√®re que la kRetProbe, uRetProbe a pour but d\u0026rsquo;√©tudier le retour de la fonction cible de l\u0026rsquo;espace utilisateur : User-space Return Probe. On peut donc d√©couvrir la valeur que retourne la fonction. Cela permet ainsi de debugger ou d\u0026rsquo;observer le comportement final de la fonction.\nMais il y a un autre int√©r√™t : en combinant les temps de l\u0026rsquo;uProbe et de l\u0026rsquo;uRetProbe, on peut r√©cup√©rer la dur√©e que met une fonction √† s\u0026rsquo;ex√©cuter assez facilement. Il est ainsi possible de profiler une fonction de son programme.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e file_type_sql On pourrait, par exemple, l\u0026rsquo;utiliser pour des requ√™tes SQL o√π on identifierait les requ√™tes les plus longues. Les uRetProbe et uProbes peuvent √™tre utilis√©es pour d√©bugger et comprendre un programme dont tu n\u0026rsquo;as pas le code source. √áa peut donc √™tre un bel outil de r√©tro-ing√©nierie (reverse engineering).\nPar contre, elles sont limit√©es aux programmes dont le langage est compil√© : C/C++, Rust, Go, etc. Si on a un programme d√©velopp√© avec un autre langage, USDT pourrait vous convenir. Parlons-en.\nUSDT : le tracepoint de l\u0026rsquo;espace utilisateur # USDT veut dire User Statically-Defined Tracing. Comme son nom l\u0026rsquo;indique, elle est √©galement d√©di√©e aux programmes de l\u0026rsquo;espace utilisateur mais il faut rajouter dans le code des sondes usdt pour les utiliser. USDT est, en fait, d√©riv√©e de l\u0026rsquo;uProbe.\nPar contre, elle est beaucoup plus pr√©cise que l\u0026rsquo;uProbe. En effet, la sonde uProbe est cantonn√©e au d√©but de fonction alors que la sonde usdt peut √™tre mise √† n\u0026rsquo;importe quel endroit dans le code.\nVoici un exemple de code Python :\ndef benchmark_module(): loop = 0 for _ in range(100000): pyusdt.trace_start_loop(loop) calculate_pi(1000) pyusdt.trace_stop_loop(loop) loop += 1 Avec ce code, on peut avoir la dur√©e pour calculer les 1000 d√©cimales de œÄ.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rAu moment de l\u0026rsquo;√©criture, le framework Aya ne g√®re pas encore les programmes de type USDT. Nous allons maintenant nous consacrer pour la suite de l\u0026rsquo;article aux uProbes et uRetProbes. Parlons d\u0026rsquo;abord un peu de leur histoire.\nOrigin story # uTrace l\u0026rsquo;anc√™tre # Vouloir tracer des fonctions de l\u0026rsquo;espace utilisateur depuis le noyau Linux ne date pas de l\u0026rsquo;introduction d\u0026rsquo;eBPF. Par exemple, une (premi√®re ?) tentative est apparue en 2007 avec les uTraces :\nMais elles n\u0026rsquo;ont jamais √©t√© incluses dans le code principal du fait d\u0026rsquo;opposition de certains mainteneurs.\nHabemus uProbe # Il a fallu attendre 2012 pour que le consensus finisse par arriver et les uProbes ont √©t√© introduites lors de la version 3.5 du noyau Linux :\n√Ä l\u0026rsquo;√©poque, les uProbes √©taient limit√©s par rapport √† celles qu\u0026rsquo;on conna√Æt aujourd\u0026rsquo;hui.\nAinsi, elles ont ensuite √©t√© am√©lior√©es avec la version 3.14 (sortie en 2014, la m√™me ann√©e que l\u0026rsquo;introduction d\u0026rsquo;eBPF) :\nCe patch a permis de r√©cup√©rer un nombre plus important de donn√©es comme la valeur de retour d\u0026rsquo;une fonction.\nLes uProbes sont alors devenues pleinement exploitables alors qu\u0026rsquo;eBPF n\u0026rsquo;√©tait pas encore sortie. Voyons quand son int√©gration s\u0026rsquo;est faite.\nuProbe avec eBPF # D\u0026rsquo;apr√®s la documentation d\u0026rsquo;eBPF, kProbe est apparue en 2015 dans la version 4.1 du noyau Linux. C\u0026rsquo;est Alexei Starovoitov, l\u0026rsquo;un des cr√©ateurs d\u0026rsquo;eBPF, qui l\u0026rsquo;a initi√© :\nComme une uProbe est une kProbe avec un point d\u0026rsquo;attache diff√©rent, on pouvait commencer √† d√©velopper des uProbes avec eBPF √† partir du 2 avril 2015.\nCependant, il fallait encore attendre que les frameworks eBPF de l\u0026rsquo;√©poque puissent le g√©rer.\nAinsi on pouvait d√©j√† l\u0026rsquo;utiliser en 2016 avec BCC comme l\u0026rsquo;atteste le tutoriel de Brendan Gregg :\nOn peut voir √©galement son issue sur GitHub datant d\u0026rsquo;octobre 2015 : Pour finir, voici une petite frise chronologique de l\u0026rsquo;histoire des uProbes :\n\u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rFree Medical icons\rLes uRetProbes ont √©t√© introduites de fa√ßon conjointe aux uProbes. Maintenant qu\u0026rsquo;uProbe a plus de 10 ans d\u0026rsquo;existence, on peut se poser une question bien l√©gitime : est-elle encore utilis√©e et par quel projet ?\nQuels projets utilisent u‚Ä¢Ret‚Ä¢Probe ? # Pour d√©fier le lieu commun : \u0026ldquo;eBPF c\u0026rsquo;est utilis√© que par 3 grosses bo√Ætes\u0026rdquo;, j\u0026rsquo;ai fait une petite recherche des outils qui utilisaient r√©ellement les uProbes et que donc vous l\u0026rsquo;utilisiez peut-√™tre sans le savoir\u0026hellip;\nPixie : where is my mind? # Le projet Pixie utilise uProbe notamment pour tracer les connexions TLS :\nD\u0026rsquo;ailleurs il y a un article de Douglas Mendez pour capturer le traffic HTTPs avec Aya.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rLe Projet Pixie est un outil d\u0026rsquo;observabilit√© pour les applications qui sont sur Kubernetes. Parca : l\u0026rsquo;hiver vient ! # Le projet Parca utilise √©galement les uProbes.\nLe projet Parca est un outil de profilage \u0026ldquo;en continue\u0026rdquo; c\u0026rsquo;est √† dire de fa√ßon syst√©matique. Inspektor Gadget : h√© l√†, qui va l√†? # Le projet Inspektor Gadget a cr√©√© des outils bas√©s sur des uProbes et sur des sondes USDT depuis 2024 :\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rLe projet Inspektor Gadget fournit des outils (des gadgets) et un framework pour collecter les donn√©es et l\u0026rsquo;inspection du syst√®me sur Kubernetes. Bonus Track # Pour finir la pr√©sentation, je vous partage quelques liens bien sympathiques que j\u0026rsquo;ai trouv√© lors de mes recherches sur les uProbes :\nUtilisation des uprobes sans eBPF par Brendan Gregg en 2015 : L\u0026rsquo;excellent article de blog de Julia Evans sur tous les syst√®mes de tracing sous Linux. Vous pouvez √©galement lire son zine : Si les uProbes ne vous conviennent pas, peut-√™tre que les bpftimes d\u0026rsquo;Eunomia peuvent vous int√©resser : Maintenant qu\u0026rsquo;on a pr√©sent√© uProbe et uRetProbe, voyons comment d√©buter son d√©veloppement avec Aya.\nComment d√©buter son programme Aya ? # Quand on d√©marre le d√©veloppement d\u0026rsquo;un nouveau programme eBPF, la premi√®re difficult√© est de r√©ussir √† le d√©marrer. Pour cela, il a besoin d\u0026rsquo;un √©v√©nement d√©clencheur (event-driven). Dans cet √©pisode, cet √©v√©nement sera donc le passage d\u0026rsquo;une uProbe ou d\u0026rsquo;une uRetProbe dans le noyau Linux.\nAya nous facilite la t√¢che. Quand on lance la commande :\ncargo generate https://github.com/aya-rs/aya-template Tu devras r√©pondre √† deux questions importantes qui permettront de d√©finir cet √©v√©nement :\nü§∑ Target to attach the (u|uret)probe? (e.g libc): ü§∑ Function name to attach the (u|uret)probe? (e.g getaddrinfo): Voyons comment y r√©pondre.\nCible pour attacher l\u0026rsquo;u‚Ä¢Ret‚Ä¢Probe # La premi√®re question demande le nom d\u0026rsquo;une biblioth√®que (comme la libc) ou d\u0026rsquo;un binaire. La question aurait pu √™tre pos√©e autrement : quel fichier tu veux debugger ou tracer ?\nIl faut voir √ßa comme un filtre :\nSi tu choisis libc, le programme eBPF ne pourra d√©marrer que si un programme de la libc est ex√©cut√© Si tu choisis un binaire, il ne pourra d√©marrer que si le binaire est ex√©cut√©. Mais cela n\u0026rsquo;est pas suffisant pour d√©marrer le programme eBPF. Il faut √™tre plus pr√©cis : donner le nom d\u0026rsquo;une fonction.\nNom de la fonction pour attacher l\u0026rsquo;u‚Ä¢Ret‚Ä¢Probe # La seconde question demande ainsi la fonction du binaire ou de la biblioth√®que que tu veux d√©bugger.\nPar exemple :\nsi tu choisis le nom d\u0026rsquo;une fonction d\u0026rsquo;un programme C, le programme eBPF sera lanc√© √† chaque fois qu\u0026rsquo;il passe par cette fonction. si tu choisis une fonction de la libc, il ne sera lanc√© lorsqu\u0026rsquo;un programme appellera cette fonction de la libc. Si cela vous parait un peu trop th√©orique, nous allons finir le chapitre en parlant d\u0026rsquo;un outil bien sympathique qui va nous permettre d\u0026rsquo;illustrer cela.\nS\u0026rsquo;initier √† eBPF avec bpftrace # Le projet bpftrace permet de cr√©er rapidement la plupart des types de programme eBPF d√©di√©s aux tracings dont notamment uProbe et uRetProbe mais √©galement USDT, kProbe et kRetProbe (Voir la prise en charge ici).\nN\u0026rsquo;h√©sitez pas √† l\u0026rsquo;installer, il est probablement packag√© pour votre distribution Linux favorite.\nLe projet s\u0026rsquo;est fortement inspir√© de DTrace, un outil de tracing cr√©√© √† l\u0026rsquo;origine pour les unix comme Solaris, FreeBSD ou NetBSD au d√©but des ann√©es 2000. Tr√®ve de bavardage, prenons un exemple :\nsudo bpftrace -e \\ \u0026#39;uretprobe:/bin/bash:readline { printf(\u0026#34;%s\\n\u0026#34;, str(retval)); }\u0026#39; Que veut dire cela ?\nuretprobe : le type de programme eBPF /bin/bash : le binaire cible readline : le nom de la fonction { printf(\u0026quot;%s\\n\u0026quot;, str(retval)); } : le code du programme bpftrace (il affiche la valeur retour de la fonction) Cette commande cr√©e ainsi un programme eBPF de type uRetProbe avec comme point d\u0026rsquo;attache la fonction readline du binaire bash.\nSi vous avez vraiment lanc√© la commande, vous allez voir que cette cr√©ation est quasi imm√©diate ! V√©rifions qu\u0026rsquo;il fonctionne bien.\nD√©marrez un autre terminal et lancez quelques commandes de ton choix. Voici un exemple de ce que vous pourrez voir sur le terminal bpftrace :\nAttaching 1 probe... ls -lrth hello man woman Vous voyez toutes les commandes que vous avez tap√© sur le terminal !\nbpftrace peut ainsi √™tre un bon moyen de prototyper un programme uProbe ou uRetProbe avant de le g√©n√©rer avec Aya.\nEt si je veux observer une autre fonction que readline dans le programme bash ? Comment faire ? Le premier reflexe serait d\u0026rsquo;aller dans le code de bash et de chercher une autre fonction mais il y a plus simple et plus s√ªr :\nbpftrace -l \u0026#39;uretprobe:/bin/bash:*\u0026#39; Cette commande va te lister toutes les fonctions disponibles dans bash.\nOn peut ainsi voir qu\u0026rsquo;on peut d√©bugger 1670 fonctions dans bash : bpftrace -l 'uretprobe:/bin/bash:*' | wc -l Ainsi bpftrace va nous permetre pour la suite de v√©rifier la faisabilit√© avant de cr√©er le programme en Rust avec Aya.\nDans cet √©pisode, on a vu les bases des uProbes et des uRetProbes : √† quoi elles servent, leur histoire, qui les utilise et comment trouver le bon point d\u0026rsquo;accroche. Nous avons √©galement vu bpftrace, un outil qui permet de cr√©er des probes rapidement.\nNous allons maintenant passer √† la pratique dans l\u0026rsquo;√©pisode suivant : on va cr√©er un petit programme Go et on va le faire r√©agir avec des programmes eBPF de type uProbe et uRetProbe avec Aya.\n","date":"8 septembre 2025","externalUrl":null,"permalink":"/ebpf-another-type/uprobe/intro/","section":"Ebpf-Another-Types","summary":"D√©couverte des uProbes et uRetProbes eBPF avec Aya","title":"L‚Äôobservabilit√© pour tous les d√©veloppeurs avec les uProbes","type":"ebpf-another-type"},{"content":"","date":"8 septembre 2025","externalUrl":null,"permalink":"/tags/usdt/","section":"Tags","summary":"","title":"Usdt","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"}]