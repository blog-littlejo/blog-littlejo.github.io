[{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/series/apprenons-uprobe-avec-ebpf-et-aya/","section":"Series","summary":"","title":"Apprenons UProbe Avec EBPF Et Aya","type":"series"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/en/tags/aya/","section":"Tags","summary":"","title":"Aya","type":"tags"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/en/categories/development/","section":"Categories","summary":"","title":"Development","type":"categories"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/en/tags/ebpf/","section":"Tags","summary":"","title":"EBPF","type":"tags"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/en/ebpf-another-type/","section":"Ebpf-Another-Types","summary":"","title":"Ebpf-Another-Types","type":"ebpf-another-type"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/en/series/getting-started-with-ebpf-uprobes-in-aya/","section":"Series","summary":"","title":"Getting Started With EBPF UProbes in Aya","type":"series"},{"content":"We saw what a uProbe-type program was in part one: a way to profile a program.\nThe purpose of this article is therefore to look at the time it takes for a function in a program written in Rust to execute.\nThis will also allow us to see the difference with a program written in Go for retrieving the attachment points of uProbe-type eBPF programs.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rI assume you are already in an environment for developing with Aya and that you have installed bpftrace. If not, you can use the Killercoda lab:\nIntroduction to the Rust program for testing uProbes # Calculating the decimal places of ùõë # Before creating the eBPF program, we will first retrieve a small program in Rust.\nTo make it a little more inventive than a hello world program, I chose a program that displays an estimate of the number ùõë. By varying the number of decimal places, we can easily change the execution time of the function.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e The number ùõë (Pi) is a number that can be used, for example, to calculate the circumference of a circle. This number has the particularity of having an infinite number of decimal places, which makes calculating them complex. In 2022, the first 100 trillion decimal places were determined. Here are the commands to retrieve and compile it:\ngit clone https://github.com/littlejo/pi_digits_rust cd pi_digits_rust cargo build To test the generated binary, you can then run the following command:\n./target/debug/pi_digits_pure_rust 10 #To get 10 decimal places of Pi Which responds:\n3.1415926536 We have 10 decimal places.\nThe purpose of this article is to retrieve the time taken by the function dedicated to calculating the decimal places of Pi (pi_times_10n_rounded()).\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rYou can test another program compiled as C/C++, Go, Zig, or V of your choice for comparison. How are we going to proceed? # To do this, we will use:\na uProbe-type program to measure the time at the start of the function a uRetProbe-type program to measure the time at the end of the function By subtracting the start time from the end time, we will find the total time required to calculate the decimal places of ùõë.\nBefore that, we first need to find the attachment point for this Rust-written program for these two eBPF programs.\nFinding the attachment point # Now that we have created and compiled the small program, we need to figure out how to trigger the uProbe or uRetProbe eBPF program. When using cargo generate for the aya repo, we need to answer two questions: where is the binary name located and which function is being observed. Let\u0026rsquo;s take a closer look.\nName of the binary # ü§∑ Target to attach the (u|uret)probe? (e.g libc): To ensure the portability of the eBPF program, you must answer with the absolute path of the binary. For example, I created it here: /home/cloud_user/pi_digits/target/debug/pi_digits_pure_rust.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e As the path is a bit long, for the rest of this article, the name of the binary will be given as a relative path for better readability: ./pi_digits_pure_rust) Function name # ü§∑ Function name to attach the (u|uret)probe? (e.g getaddrinfo): What should we answer?\nWe\u0026rsquo;ve already seen this: we can use the bpftrace command, for example:\nbpftrace -l \\ \u0026#39;uprobe:./pi_digits_pure_rust:*pi_times*\u0026#39; We then find:\nuprobe:./pi_digits_pure_rust:pi_times_10n_rounded The function is therefore pi_times_10n_rounded.\nTips # If you pay close attention, in the second part, we saw that, by default, the Go compiler:\ninlines functions, so we couldn\u0026rsquo;t see them We had to add the -l compilation option to prevent this modifies the function name (mangle) We had to add the -N compilation option to prevent this Let\u0026rsquo;s recall what an inline is (here with the Go compiler) using a diagram:\nRust also does this by default. But I didn\u0026rsquo;t do it at the global level, but for the function in particular.\nSo I had to add two attributes in the code before the target function:\n#[no_mangle] #[inline(never)] pub fn pi_times_10n_rounded(n: usize) -\u0026gt; num_bigint::BigInt { //[...] } #[no_mangle]: do not modify the function name #[inline(never)]: never inline the function Now that we have defined the attachment point, we can start creating our two eBPF programs.\nLet\u0026rsquo;s retrieve the launch time of eBPF programs # Let\u0026rsquo;s start simple by creating the two eBPF programs and just retrieving their launch time.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e Continued reading reserved for premium members ‚ú®\nThe full article is only available to premium members.\nBecoming a premium member is easy: just make a small donation üíñ\nIn exchange, you will receive for 1 year (early bird offer):\nAccess to all full articles as soon as they are published Early reading before public release Participation in supporting this independent blog Exclusive access to my vacation photos in Dubai Your donation will help:\nMake me less dependent on large platforms Encourage me to create more technical content Lift the paywall more quickly for everyone üëâ Become a premium member now\n","date":"23 September 2025","externalUrl":null,"permalink":"/en/ebpf-another-type/uprobe/example-3-tr/","section":"Ebpf-Another-Types","summary":"Let‚Äôs profile a small program with eBPF uProbes and uRetProbes in Aya","title":"Let‚Äôs Profile a Small Program Using eBPF uProbes","type":"ebpf-another-type"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/en/tags/rust/","section":"Tags","summary":"","title":"Rust","type":"tags"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/en/categories/teaser/","section":"Categories","summary":"","title":"Teaser","type":"categories"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/en/","section":"The Little Jo‚Äôs Blog","summary":"","title":"The Little Jo‚Äôs Blog","type":"page"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/en/categories/tutorial/","section":"Categories","summary":"","title":"Tutorial","type":"categories"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/en/tags/uprobe/","section":"Tags","summary":"","title":"Uprobe","type":"tags"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/en/tags/uretprobe/","section":"Tags","summary":"","title":"Uretprobe","type":"tags"},{"content":"We saw what a uProbe-type program was in part one: a way to probe a library.\nWe will verify this with an Aya program that will retrieve the various arguments of the execve() function from Libc.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rI assume you are already in an environment for developing with Aya and that you have installed bpftrace. If not, you can use the Killercoda lab:\nWhat are we really going to do? # Libc # Unlike in the previous section, where we attached our eBPF program to a program, here we are attaching it to a shared library.\nLibc is the standard C library. So every time a C (or C++) program is executed, an eBPF program could potentially be launched.\n\u003c?xml version=\"1.0\" encoding=\"iso-8859-1\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rI refer to libc throughout this chapter. To be more precise, we should refer to glibc (GNU C Library), the most widely used implementation in GNU/Linux distributions (such as Debian or Red Hat). But there are other implementations such as musl (notably for Alpine Linux) or ulibc, which are lighter and more suited to embedded systems. The execve function # execve is a system call (a syscall) from the Linux kernel. But it is also the name of a function in libc that calls this same syscall (a wrapper). Thus, each time the execve() function of libc is called, our uProbe-type eBPF program will be launched.\nThe arguments of the execve function # We also need to retrieve the various arguments of the execve() function.\nTo find its arguments, we could obviously look in the libc source code. But there is an easier way:\nman execve The part that interests us is the following:\nint execve(const char *pathname, char *const _Nullable argv[], char *const _Nullable envp[]); We can see that the function has three arguments:\npathname: the name of the command with the full path (e.g., /bin/bash). It is of type const char * (equivalent in Rust to *const u8). argv: an array of command arguments. It is of type char *const _Nullable[] (equivalent in Rust to *const *const u8) argv[0]: the name of the command argv[1]: the first option etc. envp: an array of command environment variables. It is of type char *const _Nullable[] (equivalent in Rust to *const *const u8). \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e _Nullable simply indicates that the value can be NULL. How to trigger the eBPF program? # Let\u0026rsquo;s take a simple example. If you run a command in a terminal, for example ls, what will happen?\nThanks to the PATH environment variable, the shell (for example bash) will find the right path to locate the ls binary: /usr/bin/ls To execute the binary, the shell will then call the execve() function from libc: execve(\u0026#34;/usr/bin/ls\u0026#34;, [\u0026#39;ls\u0026#39;], [\u0026#34;PATH=/bin:/usr/bin\u0026#34;, ...]) The eBPF program will finally be triggered. Here is a brief summary of all this:\nThere are obviously other programs besides shells that call the execve() function in libc, such as systemd for starting various programs on a Linux system.\nSo we are going to create a program very similar to the one we created with the sys_enter_execve tracepoint in the introductory articles on eBPF, but this one will be attached at the user level to the execve() function of libc.\nLet\u0026rsquo;s generate an uProbe-type Aya program # So we already have the answers to both questions:\nü§∑ Target to attach the (u|uret)probe? (e.g libc): ü§∑ Function name to attach the (u|uret)probe? (e.g getaddrinfo): Let\u0026rsquo;s see how to create an eBPF hello world program for this attachment point.\nLet\u0026rsquo;s test it with bpftrace # First, let\u0026rsquo;s check that it works with the bpftrace command line:\nsudo bpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;Hello execve\\n\u0026#34;); }\u0026#39; uprobe: the type of eBPF program libc: the name of the library execve: the function to debug { printf(\u0026quot;Hello execve\\n\u0026quot;); }: the bpftrace code Each time we run a command on another terminal, we see Hello execve.\nNow let\u0026rsquo;s do it with Aya.\nGenerating and compiling the Aya program # The following cargo generate command generates the eBPF program:\ncargo generate --name test-uprobe-2 \\ -d program_type=uprobe \\ -d uprobe_target=libc \\ -d uprobe_fn_name=execve \\ https://github.com/aya-rs/aya-template \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rTo find the names of the arguments (uprobe_target and uprobe_fn_name), you can look at the test.sh in the aya-template repo. Now let\u0026rsquo;s compile it and install it in the Linux kernel:\ncd test-uprobe-2/ RUST_LOG=info cargo run Testing the program # On another terminal, launch any program:\nls On the cargo run terminal, you will see:\n[INFO test_uprobe] function execve called by libc In the previous section, we left off at this point regarding uProbes. Let\u0026rsquo;s look at how to retrieve the various arguments of the execve() function. Let\u0026rsquo;s start with the first one: the name of the binary.\nLet\u0026rsquo;s retrieve the name of the binary # Let\u0026rsquo;s test with bpftrace # Before modifying the Aya code, let\u0026rsquo;s see how to do it with bpftrace. It\u0026rsquo;s a bit more complicated than a simple hello world.\nTo retrieve the first argument, we use arg0:\nsudo bpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;%d\\n\u0026#34;, arg0); }\u0026#39; We retrieve the address where the first argument is located. How do we \u0026ldquo;convert\u0026rdquo; it to a string? Just use the str() function:\nsudo bpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;%s\\n\u0026#34;, str(arg0)); }\u0026#39; Now that we have the draft with bpftrace, let\u0026rsquo;s see how to implement it with Aya.\nLet\u0026rsquo;s modify the Aya code # We need to modify the following function in the test-uprobe-2-ebpf/src/main.rs file:\nfn try_test_uprobe_2(ctx: ProbeContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { info!(\u0026amp;ctx, \u0026#34;function execve called by libc\u0026#34;); Ok(0) } We therefore need to manipulate the ctx variable. Here is the documentation:\nThere is only one method that interests us:\nThe first element is the name of the binary that is executed.\nSo we need to add something like this:\nlet arg0: *const u8 = ctx.arg(0).ok_or(1u32)?; \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rWe use the type *const u8 because the first argument is of type const char * in C (see man execve) To \u0026ldquo;convert\u0026rdquo; this pointer into a character string, we will do it in a similar way to how we did with Tracepoints in the introductory article on creating eBPF programs with Aya.\nThis gives us the following code:\nfn try_test_uprobe_2(ctx: ProbeContext) -\u0026gt; Result\u0026lt;u32, i64\u0026gt; { let arg0: *const u8 = ctx.arg(0).ok_or(1u32)?; let mut buf = [0u8; 128]; let filename = unsafe { let filename_bytes = bpf_probe_read_user_str_bytes(arg0, \u0026amp;mut buf)?; from_utf8_unchecked(filename_bytes) }; info!(\u0026amp;ctx, \u0026#34;function execve called by libc {}\u0026#34;, filename); Ok(0) } At the time, it wasn\u0026rsquo;t very clear in my mind.\nLet\u0026rsquo;s explain this code in detail:\nThe helper function bpf_probe_read_user_str_bytes() allows you to read the memory address from user space and retrieve its contents with a slice of bytes. You need a buffer for this. from_utf8_unchecked() converts a slice of bytes into an \u0026amp;str (without unchecked, otherwise the eBPF verifier will not accept it). Finally, here is a small diagram explaining how to retrieve a character string from user space:\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Note the name of the function bpf_probe_read_user_str_bytes, which makes perfect sense for a uProbe. Now let\u0026rsquo;s test the change. # Let\u0026rsquo;s check that the code still works:\nRUST_LOG=info cargo run On another terminal, let\u0026rsquo;s run any command:\nls On the cargo run terminal, you will see:\n[INFO test_uprobe_2] function execve called by libc /usr/bin/ls We left off at this point in the introductory articles on eBPF with Aya. But we could have gone further by retrieving the command options and its environment variables. Let\u0026rsquo;s see how to do that.\nLet\u0026rsquo;s retrieve the command options # Let\u0026rsquo;s test with bpftrace # Before doing this with Aya, we\u0026rsquo;ll look at how to do it with bpftrace. To retrieve the second argument, we must use arg1. Since arg1 is a pointer to a pointer, we cannot use the str() function directly. We must dereference arg1 to obtain a single pointer. To do this, simply use *.\nThis gives us:\nbpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;%s\\n\u0026#34;, str(*arg1)); }\u0026#39; We then retrieve the first element of the array, which is the name of the command. We therefore need to move through the array if we want to retrieve the different options. Each element is 8 bytes in size (only valid in 64-bit).\nTo go to the second element of the array, i.e., the first option, simply move 8 bytes (by adding 8):\nbpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;%s\\n\u0026#34;, str(*(arg1+8))); }\u0026#39; You will see that the difficulty will be much the same in Rust.\nLet\u0026rsquo;s modify the Aya code # With Aya, to retrieve the second argument, you need to add this piece of code:\nlet argv: *const *const u8 = ctx.arg(1).ok_or(1u32)?; How do we retrieve the nth option of the command? We need to use the add function to shift its pointer to the correct memory address:\nFor example, to retrieve the first option, we will shift by 1:\nlet argv1 = argv.add(1); \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rUnlike bpftrace, where you have to shift by the number of bytes (8 in 64 bits because 8x8=64 bits). The add() function allows you to move from memory address 1 by 1 without taking the architecture into account. However, argv1 is still of type *const *const u8. You now need to dereference it to obtain *const u8.\nThere is a ready-made function for this:\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e The helper function bpf_probe_read_user allows you to read the content stored in the pointer from user space and return a copy of its value. So we have:\nlet argv1_deref: *const u8 = bpf_probe_read_user(argv1)?; Now that argv1_deref is of type *const u8, we need to convert it to \u0026amp;str. This gives us code similar to that used to retrieve the name of the binary. It would probably be useful to create a function for a \u0026ldquo;serious\u0026rdquo; project.\nHere is the complete code for retrieving the first option:\nlet argv: *const *const u8 = ctx.arg(1).ok_or(0u32)?; //arg1 let mut buf = [0u8; 16]; let argname = unsafe { let argv1 = argv.add(1); //arg1+8 let argv1_deref: *const u8 = bpf_probe_read_user(argv1)?; //*(arg1+8) let argname_bytes = bpf_probe_read_user_str_bytes(argv1_deref, \u0026amp;mut buf)?; from_utf8_unchecked(argname_bytes) //str(*(arg1+8)) }; info!(\u0026amp;ctx, \u0026#34;function execve called by libc {}\u0026#34;, argname); //printf(\u0026#34;%s\\n\u0026#34;, str(*(arg1+8))); \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e I have included the equivalent code with bpftrace as a comment. Now let\u0026rsquo;s test the change. # Let\u0026rsquo;s check that the code still works:\nRUST_LOG=info cargo run On another terminal, let\u0026rsquo;s run a command with an option:\nls -lrt On the cargo run terminal, you will see:\n[INFO test_uprobe_2] function execve called by libc /usr/bin/ls [INFO test_uprobe_2] function execve called by libc -lrt This is the behavior we wanted.\nWhat happens if we run a command without an option?\nman On the cargo run terminal, you will only see:\n[INFO test_uprobe_2] function execve called by libc /usr/bin/man What happened?\nThis part of the code was not displayed:\ninfo!(\u0026amp;ctx, \u0026#34;function execve called by libc {}\u0026#34;, argname); Since the command has no arguments, this part of the code threw an error:\nlet argname = unsafe { let argv1 = argv.add(1); //arg1+8 let argv1_deref: *const u8 = bpf_probe_read_user(argv1)?; //*(arg1+8) let argname_bytes = bpf_probe_read_user_str_bytes(argv1_deref, \u0026amp;mut buf)?; from_utf8_unchecked(argname_bytes) //str(*(arg1+8)) }; And so the program crashed and never processed the last info.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rRetrieving environment variables from the command is very similar, since it is the same type as for arguments. This episode is now over! We have seen how to retrieve the arguments of a function in a C program, particularly for character strings and character string arrays, and how to display them.\nIn the next episode, we will see how to profile a program function.\n","date":"23 September 2025","externalUrl":null,"permalink":"/en/ebpf-another-type/uprobe/example-2/","section":"Ebpf-Another-Types","summary":"Let‚Äôs probe the function \u003ccode\u003eexecve\u003c/code\u003e in libc using eBPF uProbe with Aya","title":"Let‚Äôs Probe a Library with an eBPF uProbe","type":"ebpf-another-type"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/en/tags/go/","section":"Tags","summary":"","title":"Go","type":"tags"},{"content":"We saw what a uProbe-type program was in part one: a way to probe the functions of your programs.\nIn this part, we will first create a very simple program in Go and make it interact with two eBPF programs:\nThe first is a uProbe type The second is a uRetProbe type \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rI assume you are already in an environment for developing with Aya and that you have installed the go compiler and bpftrace. If not, you can use the Killercoda lab:\nLet\u0026rsquo;s create a program to test the uProbes # A very simple code # For a change from Rust, we\u0026rsquo;re going to create a small program in Go:\n// hello.go package main import \u0026#34;fmt\u0026#34; func hello() int { fmt.Println(\u0026#34;Hello, world!\u0026#34;) return 3 } func main() { ret := hello() fmt.Println(\u0026#34;Returned:\u0026#34;, ret) } \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rYou can test another compiled program such as C/C++ or Rust if you prefer. How do we activate uProbes? # The purpose of this article is to activate:\nan eBPF program of type uProbe each time we enter the hello() function: an eBPF program of type uRetProbe each time we exit the hello() function: Now that we have seen the ins and outs of the article, let\u0026rsquo;s move on to compiling the program.\nLet\u0026rsquo;s compile the program # To compile it, just type:\ngo build -gcflags=\u0026#34;all=-N -l\u0026#34; -o hello hello.go You may notice that we added an option -gcflags=\u0026quot;all=-N -l\u0026quot;. Normally, you don\u0026rsquo;t need to use this option to compile a Go program:\ngo build -o hello hello.go This also works. So why use this option?\n-gcflags means go compiler flags; these are options passed to the Go compiler. all means that the options apply to all compiled packages. The options specified to the Go compiler are:\n-N: by default, the compiler modifies (mangles) the function name. This option disables this modification. In English, to mangle means to modify, mutilate, or even disfigure. -l: by default, the compiler inlines functions, i.e., it directly integrates the content of the function into the calling code, thus allowing programs to perform better. This option allows you to disable this inline. These options will allow us to keep the functions and make them readable, which will make it easier for us to find the attachment point for our eBPF program.\nHow to find the attachment point? # Now that we have created and compiled the small program, we need to figure out how to trigger the uProbe or uRetProbe type eBPF program. When using cargo generate for the aya repo, we need to answer two questions: where is the binary name and which function is being observed. Let\u0026rsquo;s take a closer look.\nName of the binary # ü§∑ Target to attach the (u|uret)probe? (e.g libc): To ensure the portability of the eBPF program, you must answer with the absolute path of the binary. For example, I created it here: /home/cloud_user/hello.\nFunction name # Once you have answered the first question, there is a second question:\nü§∑ Function name to attach the (u|uret)probe? (e.g getaddrinfo): What should you answer? You might be tempted to answer hello since you set the -N option, which disables name decoration during compilation.\nBut it\u0026rsquo;s a little more complicated than that. The Go compiler still slightly modifies the function name during the compilation stage.\nAs we saw in the previous episode, to find all the functions in a binary, just use bpftrace:\nbpftrace -l \u0026#39;uprobe:/home/cloud_user/hello:*\u0026#39; The -l option lists all available probes uprobe: the type of eBPF program /home/cloud_user/hello: the location of the binary *: the wildcard (0 or more characters) The display format is then:\nuprobe:/home/cloud_user/hello:[function1] uprobe:/home/cloud_user/hello:[function2] uprobe:/home/cloud_user/hello:[function3] uprobe:/home/cloud_user/hello:[function4] etc That\u0026rsquo;s unfortunate: the function name is the same as my file name\u0026hellip; We can\u0026rsquo;t do | grep hello. How can we get around this? With awk, cut, or worse, a regex? Let\u0026rsquo;s keep it simple:\nbpftrace -l \u0026#39;uprobe:/home/cloud_user/hello:*hello*\u0026#39; And it will respond with:\nuprobe:/home/cloud_user/hello:main.hello So the real name of the function is main.hello\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e If you can\u0026rsquo;t install bpftrace, you can use the nm command. It allows you to see all the symbols that are present in a binary file. Now that we have the answers to both questions, we can create our eBPF programs.\nLet\u0026rsquo;s start with the uProbe-type program.\nLet\u0026rsquo;s create an eBPF uProbe program # Let\u0026rsquo;s test with bpftrace # Before diving headfirst into an Aya program, let\u0026rsquo;s check that it works properly with bpftrace, the program that creates an eBPF program from a command line. That\u0026rsquo;s good timing: we already found the beginning in the previous section:\nuprobe:/home/cloud_user/hello:main.hello All that\u0026rsquo;s left to do is add a hello world:\nsudo bpftrace -e \\ \u0026#39;uprobe:/home/cloud_user/hello:main.hello { printf(\u0026#34;Hello go\\n\u0026#34;); }\u0026#39; Historically, you needed root privileges to install an eBPF program in the kernel. With modern Linux, a non-root user can install an eBPF program with just a few additional capabilities such as CAP_BPF. However, bpftrace does not support this: you must be root. In another terminal, let\u0026rsquo;s launch the hello program (without root privileges):\n./hello On the terminal where bpftrace is running, you will see Hello go each time you launch the hello program.\nLet\u0026rsquo;s check that we can create a similar program with Aya.\nGenerating the Aya program # Let\u0026rsquo;s define the different responses for the attachment point in variables. In my case, it will be:\ntarget=/home/cloud_user/hello fn_name=main.hello Now let\u0026rsquo;s run the command to generate the Aya program:\ncargo generate --name test-uprobe \\ -d program_type=uprobe \\ -d uprobe_target=$target \\ -d uprobe_fn_name=$fn_name \\ https://github.com/aya-rs/aya-template Without the options we specified, cargo generate would run in interactive mode: we would have to answer questions.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rTo find the names of the arguments (uprobe_target and uprobe_fn_name), you can look at the test.sh in the aya-template repo. You will get the following output:\nüîß program_type: \u0026#34;uprobe\u0026#34; (value from CLI) üîß uprobe_target: \u0026#34;/home/cloud_user/hello\u0026#34; (value from CLI) üîß uprobe_fn_name: \u0026#34;main.hello\u0026#34; (value from CLI) üîß Destination: /home/cloud_user/test-uprobe ... üîß project-name: test-uprobe ... üîß Generating template ... [ 1/23] Done: .gitignore [ 2/23] Done: Cargo.toml [ 3/23] Done: LICENSE-APACHE [ 4/23] Done: LICENSE-GPL2 [ 5/23] Done: LICENSE-MIT [ 6/23] Done: README.md [ 7/23] Ignored: pre-script.rhai [ 8/23] Done: rustfmt.toml [ 9/23] Done: test-uprobe/Cargo.toml [10/23] Done: test-uprobe/build.rs [11/23] Done: test-uprobe/src/main.rs [12/23] Done: test-uprobe/src [13/23] Done: test-uprobe [14/23] Done: test-uprobe-common/Cargo.toml [15/23] Done: test-uprobe-common/src/lib.rs [16/23] Done: test-uprobe-common/src [17/23] Done: test-uprobe-common [18/23] Done: test-uprobe-ebpf/Cargo.toml [19/23] Done: test-uprobe-ebpf/build.rs [20/23] Done: test-uprobe-ebpf/src/lib.rs [21/23] Done: test-uprobe-ebpf/src/main.rs [22/23] Done: test-uprobe-ebpf/src [23/23] Done: test-uprobe-ebpf üîß Initializing a fresh Git repository ‚ú® Done! New project created /home/cloud_user/test-uprobe Compilation and installation in the kernel # Now that we have generated the program, we need to compile it and install it in the Linux kernel:\ncd test-uprobe/ RUST_LOG=info cargo run For simplicity, I compiled and installed the eBPF program as root. This will take a little time the first time:\nUpdating crates.io index Locking 103 packages to latest compatible versions Adding which v6.0.3 (available: v8.0.0) Downloaded anstyle v1.0.11 Downloaded cfg-if v1.0.1 Downloaded anyhow v1.0.98 Downloaded either v1.15.0 Downloaded cargo_metadata v0.19.2 Downloaded version_check v0.9.5 Downloaded which v6.0.3 Downloaded socket2 v0.6.0 Downloaded mio v1.0.4 [...] warning: test-uprobe@0.1.0: Finished `release` profile [optimized] target(s) in 19.59s Finished `dev` profile [unoptimized + debuginfo] target(s) in 50.16s Running `/root/build-cache/debug/test-uprobe` Waiting for Ctrl-C... Let\u0026rsquo;s test it now # Leave the Aya program running and, on another terminal, launch the program you want to examine. In my case:\n./hello On the terminal where you launched the cargo run command, you should see the following output each time you launch the program:\n[INFO test_uprobe] function main.hello called by /home/cloud_user/hello You can see that the difficulty is the same as with bpftrace, but the compilation time is much longer.\nLet‚Äôs create an eBPF uRetProbe program # We saw an example of a uProbe-type eBPF program where we didn\u0026rsquo;t have to modify the generated code. Now we\u0026rsquo;re going to make things a little more complex with a uRetProbe-type eBPF program and retrieve the return value.\nLet\u0026rsquo;s test with bpftrace # The bpftrace code is then slightly modified:\nsudo bpftrace -e \\ \u0026#39;uretprobe:/home/cloud_user/hello:main.hello { printf(\u0026#34;retval=%d\\n\u0026#34;, retval); }\u0026#39; uprobe is replaced by uretprobe The return variable has been added: retval Run the hello program in another terminal and you will see in the bpftrace terminal:\nretval=3 Let\u0026rsquo;s see how to produce the equivalent program in Aya.\nGenerating the Aya program # The code is generated in a similar way to uProbe:\ntarget=/home/cloud_user/hello fn_name=main.hello cargo generate --name test-uretprobe \\ -d program_type=uretprobe \\ -d uprobe_target=$target \\ -d uprobe_fn_name=$fn_name \\ https://github.com/aya-rs/aya-template Compilation and installation # In the same way, we will compile and install the eBPF program:\ncd test-uretprobe/ RUST_LOG=info cargo run At the end of each hello() function, the eBPF program displays:\n[INFO test_uretprobe] function main.hello called by /home/cloud_user/hello So far, we have done pretty much the same thing as for uProbe. Now let\u0026rsquo;s see how to retrieve the return value 3.\nModifying the code # We need to modify the file test-uretprobe-ebpf/src/main.rs: the kernel space code. Specifically, this piece of code:\nfn try_test_uretprobe(ctx: RetProbeContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { info!(\u0026amp;ctx, \u0026#34;function main.hello called by /home/cloud_user/hello\u0026#34;); Ok(0) } We need to see how to use the RetProbeContext structure to display the return code.\nLet\u0026rsquo;s look at the documentation:\nSo we need to use the ret() method. We\u0026rsquo;ll add something like this:\nlet retval: u32 = ctx.ret().ok_or(1u32)?; \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e If the function has no return value, we display 1u32 (32-bit unsigned integer) because the function signature is Result\u0026lt;u32, u32\u0026gt;. We also need to modify the Aya macro info! to display this value.\nThis gives us the following result:\nfn try_test_uretprobe(ctx: RetProbeContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let retval: u32 = ctx.ret().ok_or(1u32)?; info!(\u0026amp;ctx, \u0026#34;retval={}\u0026#34;, retval); Ok(0) } Let\u0026rsquo;s test it now. # Apply the changes:\nRUST_LOG=info cargo run Run the hello command in another terminal:\n./hello And on the Aya program side, we get the following display:\n[INFO test_uretprobe] retval=3 This is consistent with what we found with bpftrace.\nThis episode is now complete! We\u0026rsquo;ve seen the basics of making an uProbe and uRetProbe eBPF program react when launching a Go program.\nHowever, we haven\u0026rsquo;t yet explored how to retrieve the arguments of a function.\nThat\u0026rsquo;s perfect timing! In the next episode, we\u0026rsquo;ll probe a well-known library by retrieving function arguments and processing them!\n","date":"15 September 2025","externalUrl":null,"permalink":"/en/ebpf-another-type/uprobe/example-1/","section":"Ebpf-Another-Types","summary":"Let‚Äôs observe a small Go program using uProbes and uRetProbes with Aya","title":"Let‚Äôs Observe a Simple Function in Your Program with uProbes","type":"ebpf-another-type"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/tags/bpftrace/","section":"Tags","summary":"","title":"Bpftrace","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/categories/introduction/","section":"Categories","summary":"","title":"Introduction","type":"categories"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/tags/kprobe/","section":"Tags","summary":"","title":"Kprobe","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/series/lets-learn-another-ebpf-program/","section":"Series","summary":"","title":"Let‚Äôs Learn Another EBPF Program","type":"series"},{"content":"I\u0026rsquo;m getting started with eBPF programming with Aya. The idea behind this series of articles is to learn about a new type of eBPF program and experiment with it using the Rust Aya framework.\nToday, we\u0026rsquo;re going to dive into uProbes and uRetProbes: eBPF programs that probe user space functions without leaving a trace.\nYou\u0026rsquo;ll see that this can be very useful for profiling, debugging, or even reverse engineering.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e If you\u0026rsquo;re not familiar with eBPF, I recommend reading the first two parts of my series Getting Started with eBPF with Aya. This covers the basics and will help you understand the rest of the article. What is a u‚Ä¢Ret‚Ä¢Probe? # In English, a probe can be defined as a device used to examine or explore something. In eBPF, there are several types: kProbe, kRetProbe, uProbe, uRetProbe, and USDT.\nkProbe: the probe for the kernel # If you consult the eBPF documentation, there is no section dedicated to uProbe or uRetProbe type programs. But there is one dedicated to kProbe:\nThe purpose of kProbe is to observe Linux kernel functions. It can be considered the parent probe. All other probes are in fact the same type of program BPF_PROG_TYPE_KPROBE, but it is just the attachment point that determines how the program is executed.\nkRetProbe: feedback on the kernel probe # The kRetProbe is simply dedicated to observing the return of Linux kernel functions. This probe allows you to check whether the function call has completed successfully.\nWe have briefly looked at kProbe and kRetProbe, which could be the subject of other articles. Let\u0026rsquo;s now talk about the probes that interest us today: uProbe and uRetProbe.\nuProbe: the probe for users # Unlike kProbes, which are dedicated to observing Linux kernel functions, uProbes are dedicated to user space functions: User-space Probes. For example, they could be used to count the number of calls to the malloc and free functions in a C program.\nuProbe also allows you to retrieve the content of the arguments of the observed function. This means you could look at the amount of memory allocated to each malloc or check that free is actually freeing the right pointers.\nuProbes could therefore be integrated into a CI to automate security checks, facilitate debugging, or assist with memory diagnostics.\n\u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rFree Medical icons\rIt may seem paradoxical to want to trace user code from kernel space. However, this has the advantage of being non-intrusive, as there is no need to modify the program. uRetProbe: user probe return # Like kRetProbe, uRetProbe is designed to study the return of the target function in user space: User-space Return Probe. This allows us to discover the value returned by the function. This makes it possible to debug or observe the final behavior of the function.\nBut there is another benefit: by combining the times from uProbe and uRetProbe, we can easily retrieve the time it takes for a function to execute. This makes it possible to profile a function in your program.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e file_type_sql For example, you could use it for SQL queries to identify the longest queries. uRetProbes and uProbes can be used to debug and understand a program for which you do not have the source code. This can be a useful reverse engineering tool.\nHowever, they are limited to programs written in compiled languages: C/C++, Rust, Go, etc. If you have a program developed in another language, USDT might be a good fit for you. Let\u0026rsquo;s talk about it.\nUSDT: the user space tracepoint # USDT stands for User Statically-Defined Tracing. As its name suggests, it is also dedicated to user space programs, but usdt probes must be added to the code in order to use them. USDT is, in fact, derived from uProbe.\nHowever, it is much more accurate than uProbe. The uProbe is confined to the beginning of the function, while the usdt probe can be placed anywhere in the code.\nHere is an example of Python code:\ndef benchmark_module(): loop = 0 for _ in range(100000): pyusdt.trace_start_loop(loop) calculate_pi(1000) pyusdt.trace_stop_loop(loop) loop += 1 With this code, we can get the time it takes to calculate the first 1000 decimal places of œÄ.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rAt the time of writing, the Aya framework does not yet support USDT-type programs. We will now focus on uProbes and uRetProbes for the rest of this article. Let\u0026rsquo;s first talk a little about their history.\nOrigin story # uTrace, the predecessor # The desire to trace user space functions from the Linux kernel did not begin with the introduction of eBPF. For example, a (first?) attempt appeared in 2007 with uTraces:\nHowever, they were never included in the main code due to opposition from certain maintainers.\nHabemus uProbe # It wasn\u0026rsquo;t until 2012 that consensus was finally reached, and uProbes were introduced in version 3.5 of the Linux kernel:\nAt the time, uProbes were limited compared to what we know today.\nThey were then improved with version 3.14 (released in 2014, the same year that eBPF was introduced):\nThis patch made it possible to retrieve a greater amount of data, such as the return value of a function.\nuProbes then became fully usable even though eBPF had not yet been released. Let\u0026rsquo;s see when it was integrated.\nuProbe with eBPF # In the kProbe eBPF documentation, kProbe appeared in 2015 in version 4.1. Alexei Starovoitov, one of eBPF\u0026rsquo;s creators, was the one who initiated it:\nSince a uProbe is a kProbe with a different attachment point, we were able to start developing uProbes with eBPF as of April 2, 2015.\nHowever, we still had to wait for the eBPF frameworks of the time to be able to handle it.\nSo we could already use it in 2016 with BCC as evidenced by Brendan Gregg\u0026rsquo;s tutorial:\nYou can also see his GitHub issue from October 2015: Finally, here is a brief timeline of the history of uProbes:\n\u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rFree Medical icons\ruRetProbes were introduced at the same time as uProbes. Now that uProbe has been around for over 10 years, it\u0026rsquo;s fair to ask: is it still being used, and if so, by which projects?\nWhich projects use u‚Ä¢Ret‚Ä¢Probe? # To challenge the common misconception that \u0026ldquo;eBPF is only used by three big companies\u0026rdquo;, I did a little research on tools that actually use uProbes, which means you may be using them without even knowing it\u0026hellip;\nPixie: Where is my mind? # The Pixie project uses uProbe in particular to trace TLS connections:\nThere is also an article by Douglas Mendez on capturing HTTPs traffic with Aya.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rThe Pixie Project is an observability tool for applications running on Kubernetes. Parca: Winter is coming! # The Parca project also uses uProbes.\nThe Parca project is a \u0026ldquo;continuous\u0026rdquo; profiling tool, i.e., it profiles systematically. Inspektor Gadget: I\u0026rsquo;m always on duty! # The Inspektor Gadget project has been creating tools based on uProbes and USDT probes since 2024:\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rThe Inspektor Gadget project provides tools (gadgets) and a framework for collecting data and inspecting the system on Kubernetes. Bonus Track # To conclude this presentation, I would like to share some interesting links that I found while researching uProbes:\nUsing uProbes without eBPF by Brendan Gregg in 2015: Julia Evans\u0026rsquo; excellent blog post on all tracing systems on Linux. You can also read her zine: If uProbes aren\u0026rsquo;t right for you, you might be interested in Eunomia\u0026rsquo;s bpftimes: Now that we\u0026rsquo;ve introduced uProbe and uRetProbe, let\u0026rsquo;s see how to get started with development using Aya.\nHow to start your Aya program? # When you start developing a new eBPF program, the first challenge is getting it to start. To do this, it needs an event-driven trigger. In this episode, this event will be the passage of a uProbe or uRetProbe in the Linux kernel.\nAya makes this task easier. When you run the command:\ncargo generate https://github.com/aya-rs/aya-template You will need to answer two important questions that will help define this event:\nü§∑ Target to attach the (u|uret)probe? (e.g libc): ü§∑ Function name to attach the (u|uret)probe? (e.g getaddrinfo): Let\u0026rsquo;s see how to answer them.\nTarget for attaching the u‚Ä¢Ret‚Ä¢Probe # The first question asks for the name of a library (such as libc) or a binary. The question could have been phrased differently: which file do you want to debug or trace?\nThink of it as a filter:\nIf you choose libc, the eBPF program will only start if a program from libc is running. If you choose a binary, it will only start if the binary is running. But this is not enough to start the eBPF program. You need to be more specific: give the name of a function.\nName of the function to attach the u‚Ä¢Ret‚Ä¢Probe # The second question asks for the function of the binary or library you want to debug.\nFor example:\nIf you choose the name of a function from a C program, the eBPF program will be launched each time it passes through this function. If you choose a function from libc, it will only be launched when a program calls this function from libc. If this seems a little too theoretical, we will finish the chapter by talking about a very useful tool that will allow us to illustrate this.\nGetting started with eBPF using bpftrace # The bpftrace project allows you to quickly create most types of eBPF programs dedicated to tracing, including uProbe and uRetProbe, as well as USDT, kProbe, and kRetProbe (see support here).\nFeel free to install it; it is probably packaged for your favorite Linux distribution.\nThe project was heavily inspired by DTrace, a tracing tool originally created for Unix systems such as Solaris, FreeBSD, and NetBSD in the early 2000s. Enough talk, let\u0026rsquo;s look at an example:\nsudo bpftrace -e \\ \u0026#39;uretprobe:/bin/bash:readline { printf(\u0026#34;%s\\n\u0026#34;, str(retval)); }\u0026#39; What does this mean?\nuretprobe: the type of eBPF program /bin/bash: the target binary readline: the name of the function { printf(\u0026quot;%s\\n\u0026quot;, str(retval)); }: the bpftrace program code (it displays the return value of the function) This command creates an eBPF program of type uRetProbe with the readline function of the bash binary as its attachment point.\nIf you have actually run the command, you will see that this creation is almost immediate! Let\u0026rsquo;s check that it works properly.\nStart another terminal and run a few commands of your choice. Here is an example of what you will see on the bpftrace terminal:\nAttaching 1 probe... ls -lrth hello man woman You can see all the commands you typed on the terminal!\nbpftrace can therefore be a good way to prototype a uProbe or uRetProbe program before generating it with Aya.\nWhat if I want to observe a function other than readline in the bash program? How do I do that? The first instinct would be to go into the bash code and look for another function, but there is an easier and safer way:\nbpftrace -l \u0026#39;uretprobe:/bin/bash:*\u0026#39; This command will list all the functions available in bash.\nWe can see that we can debug 1670 functions in bash: bpftrace -l 'uretprobe:/bin/bash:*' | wc -l Bpftrace will allow us to verify feasibility before creating the program in Rust with Aya.\nIn this episode, we looked at the basics of uProbes and uRetProbes: what they are used for, their history, who uses them, and how to find the right hook. We also looked at bpftrace, a tool that allows you to create probes quickly.\nNow let\u0026rsquo;s move on to the practical stuff. In the next episode, we\u0026rsquo;ll create a small Go program and make it interact with uProbe and uRetProbe eBPF programs using Aya.\n","date":"8 September 2025","externalUrl":null,"permalink":"/en/ebpf-another-type/uprobe/intro/","section":"Ebpf-Another-Types","summary":"An introduction to eBPF uProbes and uRetProbes with Aya","title":"Observability for All Developers with uProbes","type":"ebpf-another-type"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/tags/usdt/","section":"Tags","summary":"","title":"Usdt","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/series/apprenons-un-autre-programme-ebpf/","section":"Series","summary":"","title":"Apprenons Un Autre Programme EBPF","type":"series"},{"content":"","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"}]