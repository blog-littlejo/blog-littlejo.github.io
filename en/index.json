[{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/series/apprenons-un-autre-programme-ebpf/","section":"Series","summary":"","title":"Apprenons Un Autre Programme EBPF","type":"series"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/series/apprenons-uprobe-avec-ebpf-et-aya/","section":"Series","summary":"","title":"Apprenons UProbe Avec EBPF Et Aya","type":"series"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/tags/aya/","section":"Tags","summary":"","title":"Aya","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/tags/bpftrace/","section":"Tags","summary":"","title":"Bpftrace","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/categories/development/","section":"Categories","summary":"","title":"Development","type":"categories"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/tags/ebpf/","section":"Tags","summary":"","title":"EBPF","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/categories/introduction/","section":"Categories","summary":"","title":"Introduction","type":"categories"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/tags/kprobe/","section":"Tags","summary":"","title":"Kprobe","type":"tags"},{"content":"Je débute la programmation en eBPF avec Aya. L’idée de cette série d’articles est d\u0026rsquo;apprendre un nouveau type de programme eBPF et de l\u0026rsquo;expérimenter avec le framework Rust Aya.\nAujourd\u0026rsquo;hui, nous allons nous plonger dans les uProbes et les uRetProbes : des programmes eBPF qui sondent les fonctions de l\u0026rsquo;espace utilisateur sans laisser de trace.\nVous allez voir que cela peut être très intéressant pour du profilage, du debug ou même de la rétro-ingénierie.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Si tu ne connais pas eBPF, je te conseille de lire les deux premières parties de ma série S’initier à eBPF avec Aya. Cela couvre les bases et t\u0026rsquo;aidera pour la suite de l\u0026rsquo;article. Qu\u0026rsquo;est-ce qu\u0026rsquo;une u•Ret•Probe ? # En anglais, une probe peut se traduire par une sonde pour examiner ou explorer quelque chose. En eBPF, il y en a de plusieurs types : kProbe, kRetProbe, uProbe, uRetProbe et USDT.\nkProbe : la sonde pour le kernel # Si tu consultes la documentation d\u0026rsquo;eBPF, il n\u0026rsquo;y a pas de section consacrée aux programmes de type uProbe ou uRetProbe. Mais il y en a une dédiée à la kProbe :\nLa kProbe a pour but d\u0026rsquo;observer des fonctions du kernel Linux. Elle peut être considérée comme la probe parente. Toutes les autres probes sont en fait le même type de programme BPF_PROG_TYPE_KPROBE mais c\u0026rsquo;est juste le point d\u0026rsquo;attache qui va déterminer comment le programme est exécuté.\nkRetProbe : retour sur la sonde kernel # La kRetProbe est simplement dédiée à l\u0026rsquo;observation du retour des fonctions du kernel Linux. Cette sonde permet ainsi de vérifier si l\u0026rsquo;appel de la fonction s\u0026rsquo;est bien terminé.\nNous avons vu brièvement kProbe et kRetProbe qui pourraient faire l\u0026rsquo;objet d\u0026rsquo;autres articles. Parlons maintenant des probes qui nous intéressent aujourd\u0026rsquo;hui : uProbe et uRetProbe.\nuProbe : la sonde pour les utilisateurs # Contrairement aux kProbes qui sont dédiées à observer les fonctions du kernel Linux, les uProbes sont dédiées aux fonctions de l\u0026rsquo;espace utilisateur : User-space Probes. Par exemple, on pourrait s\u0026rsquo;en servir pour compter le nombre d\u0026rsquo;appels aux fonctions malloc et free dans un programme C.\nuProbe permet également de récupérer le contenu des arguments de la fonction observée. Ainsi on pourrait regarder la quantité de mémoire allouée à chaque malloc ou vérifier que free libère réellement des bons pointeurs.\nAinsi les uProbes pourrait s\u0026rsquo;intégrer à une CI pour automatiser des vérifications de sécurité, faciliter le debogage ou aider au diagnostic mémoire.\n\u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rFree Medical icons\rÇa peut paraître paradoxal de vouloir tracer un code utilisateur depuis l\u0026rsquo;espace noyau. Cependant cela a le mérite d\u0026rsquo;être non intrusif car il n\u0026rsquo;y a pas besoin de modifier le programme. uRetProbe : retour sur la sonde utilisateur # De la même manière que la kRetProbe, uRetProbe a pour but d\u0026rsquo;étudier le retour de la fonction cible de l\u0026rsquo;espace utilisateur : User-space Return Probe. On peut donc découvrir la valeur que retourne la fonction. Cela permet ainsi de debugger ou d\u0026rsquo;observer le comportement final de la fonction.\nMais il y a un autre intérêt : en combinant les temps de l\u0026rsquo;uProbe et de l\u0026rsquo;uRetProbe, on peut récupérer la durée que met une fonction à s\u0026rsquo;exécuter assez facilement. Il est ainsi possible de profiler une fonction de son programme.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e file_type_sql On pourrait, par exemple, l\u0026rsquo;utiliser pour des requêtes SQL où on identifierait les requêtes les plus longues. Les uRetProbe et uProbes peuvent être utilisées pour débugger et comprendre un programme dont tu n\u0026rsquo;as pas le code source. Ça peut donc être un bel outil de rétro-ingénierie (reverse engineering).\nPar contre, elles sont limitées aux programmes dont le langage est compilé : C/C++, Rust, Go, etc. Si on a un programme développé avec un autre langage, USDT pourrait vous convenir. Parlons-en.\nUSDT : le tracepoint de l\u0026rsquo;espace utilisateur # USDT veut dire User Statically-Defined Tracing. Comme son nom l\u0026rsquo;indique, elle est également dédiée aux programmes de l\u0026rsquo;espace utilisateur mais il faut rajouter dans le code des sondes usdt pour les utiliser. USDT est, en fait, dérivée de l\u0026rsquo;uProbe.\nPar contre, elle est beaucoup plus précise que l\u0026rsquo;uProbe. En effet, la sonde uProbe est cantonnée au début de fonction alors que la sonde usdt peut être mise à n\u0026rsquo;importe quel endroit dans le code.\nVoici un exemple de code Python :\ndef benchmark_module(): loop = 0 for _ in range(100000): pyusdt.trace_start_loop(loop) calculate_pi(1000) pyusdt.trace_stop_loop(loop) loop += 1 Avec ce code, on peut avoir la durée pour calculer les 1000 décimales de π.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rAu moment de l\u0026rsquo;écriture, le framework Aya ne gère pas encore les programmes de type USDT. Nous allons maintenant nous consacrer pour la suite de l\u0026rsquo;article aux uProbes et uRetProbes. Parlons d\u0026rsquo;abord un peu de leur histoire.\nOrigin story # uTrace l\u0026rsquo;ancêtre # Vouloir tracer des fonctions de l\u0026rsquo;espace utilisateur depuis le noyau Linux ne date pas de l\u0026rsquo;introduction d\u0026rsquo;eBPF. Par exemple, une (première ?) tentative est apparue en 2007 avec les uTraces :\nMais elles n\u0026rsquo;ont jamais été incluses dans le code principal du fait d\u0026rsquo;opposition de certains mainteneurs.\nHabemus uProbe # Il a fallu attendre 2012 pour que le consensus finisse par arriver et les uProbes ont été introduites lors de la version 3.5 du noyau Linux :\nÀ l\u0026rsquo;époque, les uProbes étaient limités par rapport à celles qu\u0026rsquo;on connaît aujourd\u0026rsquo;hui.\nAinsi, elles ont ensuite été améliorées avec la version 3.14 (sortie en 2014, la même année que l\u0026rsquo;introduction d\u0026rsquo;eBPF) :\nCe patch a permis de récupérer un nombre plus important de données comme la valeur de retour d\u0026rsquo;une fonction.\nLes uProbes sont alors devenues pleinement exploitables alors qu\u0026rsquo;eBPF n\u0026rsquo;était pas encore sortie. Voyons quand son intégration s\u0026rsquo;est faite.\nuProbe avec eBPF # D\u0026rsquo;après la documentation d\u0026rsquo;eBPF, kProbe est apparue en 2015 dans la version 4.1 du noyau Linux. C\u0026rsquo;est Alexei Starovoitov, l\u0026rsquo;un des créateurs d\u0026rsquo;eBPF, qui l\u0026rsquo;a initié :\nComme une uProbe est une kProbe avec un point d\u0026rsquo;attache différent, on pouvait commencer à développer des uProbes avec eBPF à partir du 2 avril 2015.\nCependant, il fallait encore attendre que les frameworks eBPF de l\u0026rsquo;époque puissent le gérer.\nAinsi on pouvait déjà l\u0026rsquo;utiliser en 2016 avec BCC comme l\u0026rsquo;atteste le tutoriel de Brendan Gregg :\nOn peut voir également son issue sur GitHub datant d\u0026rsquo;octobre 2015 : Pour finir, voici une petite frise chronologique de l\u0026rsquo;histoire des uProbes :\n\u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rFree Medical icons\rLes uRetProbes ont été introduites de façon conjointe aux uProbes. Maintenant qu\u0026rsquo;uProbe a plus de 10 ans d\u0026rsquo;existence, on peut se poser une question bien légitime : est-elle encore utilisée et par quel projet ?\nQuels projets utilisent u•Ret•Probe ? # Pour défier le lieu commun : \u0026ldquo;eBPF c\u0026rsquo;est utilisé que par 3 grosses boîtes\u0026rdquo;, j\u0026rsquo;ai fait une petite recherche des outils qui utilisaient réellement les uProbes et que donc vous l\u0026rsquo;utilisiez peut-être sans le savoir\u0026hellip;\nPixie : where is my mind? # Le projet Pixie utilise uProbe notamment pour tracer les connexions TLS :\nD\u0026rsquo;ailleurs il y a un article de Douglas Mendez pour capturer le traffic HTTPs avec Aya.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rLe Projet Pixie est un outil d\u0026rsquo;observabilité pour les applications qui sont sur Kubernetes. Parca : l\u0026rsquo;hiver vient ! # Le projet Parca utilise également les uProbes.\nLe projet Parca est un outil de profilage \u0026ldquo;en continue\u0026rdquo; c\u0026rsquo;est à dire de façon systématique. Inspektor Gadget : hé là, qui va là? # Le projet Inspektor Gadget a créé des outils basés sur des uProbes et sur des sondes USDT depuis 2024 :\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rLe projet Inspektor Gadget fournit des outils (des gadgets) et un framework pour collecter les données et l\u0026rsquo;inspection du système sur Kubernetes. Bonus Track # Pour finir la présentation, je vous partage quelques liens bien sympathiques que j\u0026rsquo;ai trouvé lors de mes recherches sur les uProbes :\nUtilisation des uprobes sans eBPF par Brendan Gregg en 2015 : L\u0026rsquo;excellent article de blog de Julia Evans sur tous les systèmes de tracing sous Linux. Vous pouvez également lire son zine : Si les uProbes ne vous conviennent pas, peut-être que les bpftimes d\u0026rsquo;Eunomia peuvent vous intéresser : Maintenant qu\u0026rsquo;on a présenté uProbe et uRetProbe, voyons comment débuter son développement avec Aya.\nComment débuter son programme Aya ? # Quand on démarre le développement d\u0026rsquo;un nouveau programme eBPF, la première difficulté est de réussir à le démarrer. Pour cela, il a besoin d\u0026rsquo;un événement déclencheur (event-driven). Dans cet épisode, cet événement sera donc le passage d\u0026rsquo;une uProbe ou d\u0026rsquo;une uRetProbe dans le noyau Linux.\nAya nous facilite la tâche. Quand on lance la commande :\ncargo generate https://github.com/aya-rs/aya-template Tu devras répondre à deux questions importantes qui permettront de définir cet événement :\n🤷 Target to attach the (u|uret)probe? (e.g libc): 🤷 Function name to attach the (u|uret)probe? (e.g getaddrinfo): Voyons comment y répondre.\nCible pour attacher l\u0026rsquo;u•Ret•Probe # La première question demande le nom d\u0026rsquo;une bibliothèque (comme la libc) ou d\u0026rsquo;un binaire. La question aurait pu être posée autrement : quel fichier tu veux debugger ou tracer ?\nIl faut voir ça comme un filtre :\nSi tu choisis libc, le programme eBPF ne pourra démarrer que si un programme de la libc est exécuté Si tu choisis un binaire, il ne pourra démarrer que si le binaire est exécuté. Mais cela n\u0026rsquo;est pas suffisant pour démarrer le programme eBPF. Il faut être plus précis : donner le nom d\u0026rsquo;une fonction.\nNom de la fonction pour attacher l\u0026rsquo;u•Ret•Probe # La seconde question demande ainsi la fonction du binaire ou de la bibliothèque que tu veux débugger.\nPar exemple :\nsi tu choisis le nom d\u0026rsquo;une fonction d\u0026rsquo;un programme C, le programme eBPF sera lancé à chaque fois qu\u0026rsquo;il passe par cette fonction. si tu choisis une fonction de la libc, il ne sera lancé lorsqu\u0026rsquo;un programme appellera cette fonction de la libc. Si cela vous parait un peu trop théorique, nous allons finir le chapitre en parlant d\u0026rsquo;un outil bien sympathique qui va nous permettre d\u0026rsquo;illustrer cela.\nS\u0026rsquo;initier à eBPF avec bpftrace # Le projet bpftrace permet de créer rapidement la plupart des types de programme eBPF dédiés aux tracings dont notamment uProbe et uRetProbe mais également USDT, kProbe et kRetProbe (Voir la prise en charge ici).\nN\u0026rsquo;hésitez pas à l\u0026rsquo;installer, il est probablement packagé pour votre distribution Linux favorite.\nLe projet s\u0026rsquo;est fortement inspiré de DTrace, un outil de tracing créé à l\u0026rsquo;origine pour les unix comme Solaris, FreeBSD ou NetBSD au début des années 2000. Trève de bavardage, prenons un exemple :\nsudo bpftrace -e \\ \u0026#39;uretprobe:/bin/bash:readline { printf(\u0026#34;%s\\n\u0026#34;, str(retval)); }\u0026#39; Que veut dire cela ?\nuretprobe : le type de programme eBPF /bin/bash : le binaire cible readline : le nom de la fonction { printf(\u0026quot;%s\\n\u0026quot;, str(retval)); } : le code du programme bpftrace (il affiche la valeur retour de la fonction) Cette commande crée ainsi un programme eBPF de type uRetProbe avec comme point d\u0026rsquo;attache la fonction readline du binaire bash.\nSi vous avez vraiment lancé la commande, vous allez voir que cette création est quasi immédiate ! Vérifions qu\u0026rsquo;il fonctionne bien.\nDémarrez un autre terminal et lancez quelques commandes de ton choix. Voici un exemple de ce que vous pourrez voir sur le terminal bpftrace :\nAttaching 1 probe... ls -lrth hello man woman Vous voyez toutes les commandes que vous avez tapé sur le terminal !\nbpftrace peut ainsi être un bon moyen de prototyper un programme uProbe ou uRetProbe avant de le générer avec Aya.\nEt si je veux observer une autre fonction que readline dans le programme bash ? Comment faire ? Le premier reflexe serait d\u0026rsquo;aller dans le code de bash et de chercher une autre fonction mais il y a plus simple et plus sûr :\nbpftrace -l \u0026#39;uretprobe:/bin/bash:*\u0026#39; Cette commande va te lister toutes les fonctions disponibles dans bash.\nOn peut ainsi voir qu\u0026rsquo;on peut débugger 1670 fonctions dans bash : bpftrace -l 'uretprobe:/bin/bash:*' | wc -l Ainsi bpftrace va nous permetre pour la suite de vérifier la faisabilité avant de créer le programme en Rust avec Aya.\nDans cet épisode, on a vu les bases des uProbes et des uRetProbes : à quoi elles servent, leur histoire, qui les utilise et comment trouver le bon point d\u0026rsquo;accroche. Nous avons également vu bpftrace, un outil qui permet de créer des probes rapidement.\nNous allons maintenant passer à la pratique dans l\u0026rsquo;épisode suivant : on va créer un petit programme Go et on va le faire réagir avec des programmes eBPF de type uProbe et uRetProbe avec Aya.\n","date":"8 September 2025","externalUrl":null,"permalink":"/ebpf-another-type/uprobe/intro/","section":"Ebpf-Another-Types","summary":"Découverte des uProbes et uRetProbes eBPF avec Aya","title":"L’observabilité pour tous les développeurs avec les uProbes","type":"ebpf-another-type"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/tags/rust/","section":"Tags","summary":"","title":"Rust","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/categories/tutorial/","section":"Categories","summary":"","title":"Tutorial","type":"categories"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/tags/uprobe/","section":"Tags","summary":"","title":"Uprobe","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/tags/uretprobe/","section":"Tags","summary":"","title":"Uretprobe","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/tags/usdt/","section":"Tags","summary":"","title":"Usdt","type":"tags"},{"content":"","date":"24 July 2025","externalUrl":null,"permalink":"/en/ebpf-another-type/","section":"Ebpf-Another-Types","summary":"","title":"Ebpf-Another-Types","type":"ebpf-another-type"},{"content":"","date":"24 July 2025","externalUrl":null,"permalink":"/en/","section":"The Little Jo’s Blog","summary":"","title":"The Little Jo’s Blog","type":"page"},{"content":"","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]