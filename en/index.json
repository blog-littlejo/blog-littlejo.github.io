[{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/ebpf-another-type/","section":"Ebpf-Another-Types","summary":"","title":"Ebpf-Another-Types","type":"ebpf-another-type"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/","section":"The Little Joâ€™s Blog","summary":"","title":"The Little Joâ€™s Blog","type":"page"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/tags/aya/","section":"Tags","summary":"","title":"Aya","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/categories/development/","section":"Categories","summary":"","title":"Development","type":"categories"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/tags/ebpf/","section":"Tags","summary":"","title":"EBPF","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/series/getting-started-with-ebpf-uprobes-in-aya/","section":"Series","summary":"","title":"Getting Started With EBPF UProbes in Aya","type":"series"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/tags/go/","section":"Tags","summary":"","title":"Go","type":"tags"},{"content":"We saw what a uProbe-type program was in part one: a way to probe the functions of your programs.\nIn this part, we will first create a very simple program in Go and make it interact with two eBPF programs:\nThe first is a uProbe type The second is a uRetProbe type \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rI assume you are already in an environment for developing with Aya and that you have installed the go compiler and bpftrace. If not, you can use the Killercoda lab:\nLet\u0026rsquo;s create a program to test the uProbes # A very simple code # For a change from Rust, we\u0026rsquo;re going to create a small program in Go:\n// hello.go package main import \u0026#34;fmt\u0026#34; func hello() int { fmt.Println(\u0026#34;Hello, world!\u0026#34;) return 3 } func main() { ret := hello() fmt.Println(\u0026#34;Returned:\u0026#34;, ret) } \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rYou can test another compiled program such as C/C++ or Rust if you prefer. How do we activate uProbes? # The purpose of this article is to activate:\nan eBPF program of type uProbe each time we enter the hello() function: an eBPF program of type uRetProbe each time we exit the hello() function: Now that we have seen the ins and outs of the article, let\u0026rsquo;s move on to compiling the program.\nLet\u0026rsquo;s compile the program # To compile it, just type:\ngo build -gcflags=\u0026#34;all=-N -l\u0026#34; -o hello hello.go You may notice that we added an option -gcflags=\u0026quot;all=-N -l\u0026quot;. Normally, you don\u0026rsquo;t need to use this option to compile a Go program:\ngo build -o hello hello.go This also works. So why use this option?\n-gcflags means go compiler flags; these are options passed to the Go compiler. all means that the options apply to all compiled packages. The options specified to the Go compiler are:\n-N: by default, the compiler modifies (mangles) the function name. This option disables this modification. In English, to mangle means to modify, mutilate, or even disfigure. -l: by default, the compiler inlines functions, i.e., it directly integrates the content of the function into the calling code, thus allowing programs to perform better. This option allows you to disable this inline. These options will allow us to keep the functions and make them readable, which will make it easier for us to find the attachment point for our eBPF program.\nHow to find the attachment point? # Now that we have created and compiled the small program, we need to figure out how to trigger the uProbe or uRetProbe type eBPF program. When using cargo generate for the aya repo, we need to answer two questions: where is the binary name and which function is being observed. Let\u0026rsquo;s take a closer look.\nName of the binary # ðŸ¤· Target to attach the (u|uret)probe? (e.g libc): To ensure the portability of the eBPF program, you must answer with the absolute path of the binary. For example, I created it here: /home/cloud_user/hello.\nFunction name # Once you have answered the first question, there is a second question:\nðŸ¤· Function name to attach the (u|uret)probe? (e.g getaddrinfo): What should you answer? You might be tempted to answer hello since you set the -N option, which disables name decoration during compilation.\nBut it\u0026rsquo;s a little more complicated than that. The Go compiler still slightly modifies the function name during the compilation stage.\nAs we saw in the previous episode, to find all the functions in a binary, just use bpftrace:\nbpftrace -l \u0026#39;uprobe:/home/cloud_user/hello:*\u0026#39; The -l option lists all available probes uprobe: the type of eBPF program /home/cloud_user/hello: the location of the binary *: the wildcard (0 or more characters) The display format is then:\nuprobe:/home/cloud_user/hello:[function1] uprobe:/home/cloud_user/hello:[function2] uprobe:/home/cloud_user/hello:[function3] uprobe:/home/cloud_user/hello:[function4] etc That\u0026rsquo;s unfortunate: the function name is the same as my file name\u0026hellip; We can\u0026rsquo;t do | grep hello. How can we get around this? With awk, cut, or worse, a regex? Let\u0026rsquo;s keep it simple:\nbpftrace -l \u0026#39;uprobe:/home/cloud_user/hello:*hello*\u0026#39; And it will respond with:\nuprobe:/home/cloud_user/hello:main.hello So the real name of the function is main.hello\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e If you can\u0026rsquo;t install bpftrace, you can use the nm command. It allows you to see all the symbols that are present in a binary file. Now that we have the answers to both questions, we can create our eBPF programs.\nLet\u0026rsquo;s start with the uProbe-type program.\nLet\u0026rsquo;s create an eBPF uProbe program # Let\u0026rsquo;s test with bpftrace # \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e Continued reading reserved for premium members âœ¨\nThe full article is only available to premium members.\nBecoming a premium member is easy: just make a small donation ðŸ’–\nIn exchange, you will receive for 1 year (early bird offer):\nAccess to all full articles as soon as they are published Early reading before public release Participation in supporting this independent blog Exclusive access to my vacation photos in Dubai Your donation will help:\nMake me less dependent on large platforms Encourage me to create more technical content Lift the paywall more quickly for everyone ðŸ‘‰ Become a premium member now\n","date":"8 September 2025","externalUrl":null,"permalink":"/en/ebpf-another-type/uprobe/example-1-tr/","section":"Ebpf-Another-Types","summary":"Letâ€™s observe a small Go program using uProbes and uRetProbes with Aya","title":"Letâ€™s Observe a Simple Function in Your Program with uProbes","type":"ebpf-another-type"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/tags/rust/","section":"Tags","summary":"","title":"Rust","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/categories/teaser/","section":"Categories","summary":"","title":"Teaser","type":"categories"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/categories/tutorial/","section":"Categories","summary":"","title":"Tutorial","type":"categories"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/tags/uprobe/","section":"Tags","summary":"","title":"Uprobe","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/tags/uretprobe/","section":"Tags","summary":"","title":"Uretprobe","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/tags/bpftrace/","section":"Tags","summary":"","title":"Bpftrace","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/categories/introduction/","section":"Categories","summary":"","title":"Introduction","type":"categories"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/tags/kprobe/","section":"Tags","summary":"","title":"Kprobe","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/series/lets-learn-another-ebpf-program/","section":"Series","summary":"","title":"Letâ€™s Learn Another EBPF Program","type":"series"},{"content":"I\u0026rsquo;m getting started with eBPF programming with Aya. The idea behind this series of articles is to learn about a new type of eBPF program and experiment with it using the Rust Aya framework.\nToday, we\u0026rsquo;re going to dive into uProbes and uRetProbes: eBPF programs that probe user space functions without leaving a trace.\nYou\u0026rsquo;ll see that this can be very useful for profiling, debugging, or even reverse engineering.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e If you\u0026rsquo;re not familiar with eBPF, I recommend reading the first two parts of my series Getting Started with eBPF with Aya. This covers the basics and will help you understand the rest of the article. What is a uâ€¢Retâ€¢Probe? # In English, a probe can be defined as a device used to examine or explore something. In eBPF, there are several types: kProbe, kRetProbe, uProbe, uRetProbe, and USDT.\nkProbe: the probe for the kernel # If you consult the eBPF documentation, there is no section dedicated to uProbe or uRetProbe type programs. But there is one dedicated to kProbe:\nThe purpose of kProbe is to observe Linux kernel functions. It can be considered the parent probe. All other probes are in fact the same type of program BPF_PROG_TYPE_KPROBE, but it is just the attachment point that determines how the program is executed.\nkRetProbe: feedback on the kernel probe # The kRetProbe is simply dedicated to observing the return of Linux kernel functions. This probe allows you to check whether the function call has completed successfully.\nWe have briefly looked at kProbe and kRetProbe, which could be the subject of other articles. Let\u0026rsquo;s now talk about the probes that interest us today: uProbe and uRetProbe.\nuProbe: the probe for users # Unlike kProbes, which are dedicated to observing Linux kernel functions, uProbes are dedicated to user space functions: User-space Probes. For example, they could be used to count the number of calls to the malloc and free functions in a C program.\nuProbe also allows you to retrieve the content of the arguments of the observed function. This means you could look at the amount of memory allocated to each malloc or check that free is actually freeing the right pointers.\nuProbes could therefore be integrated into a CI to automate security checks, facilitate debugging, or assist with memory diagnostics.\n\u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rFree Medical icons\rIt may seem paradoxical to want to trace user code from kernel space. However, this has the advantage of being non-intrusive, as there is no need to modify the program. uRetProbe: user probe return # Like kRetProbe, uRetProbe is designed to study the return of the target function in user space: User-space Return Probe. This allows us to discover the value returned by the function. This makes it possible to debug or observe the final behavior of the function.\nBut there is another benefit: by combining the times from uProbe and uRetProbe, we can easily retrieve the time it takes for a function to execute. This makes it possible to profile a function in your program.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e file_type_sql For example, you could use it for SQL queries to identify the longest queries. uRetProbes and uProbes can be used to debug and understand a program for which you do not have the source code. This can be a useful reverse engineering tool.\nHowever, they are limited to programs written in compiled languages: C/C++, Rust, Go, etc. If you have a program developed in another language, USDT might be a good fit for you. Let\u0026rsquo;s talk about it.\nUSDT: the user space tracepoint # USDT stands for User Statically-Defined Tracing. As its name suggests, it is also dedicated to user space programs, but usdt probes must be added to the code in order to use them. USDT is, in fact, derived from uProbe.\nHowever, it is much more accurate than uProbe. The uProbe is confined to the beginning of the function, while the usdt probe can be placed anywhere in the code.\nHere is an example of Python code:\ndef benchmark_module(): loop = 0 for _ in range(100000): pyusdt.trace_start_loop(loop) calculate_pi(1000) pyusdt.trace_stop_loop(loop) loop += 1 With this code, we can get the time it takes to calculate the first 1000 decimal places of Ï€.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rAt the time of writing, the Aya framework does not yet support USDT-type programs. We will now focus on uProbes and uRetProbes for the rest of this article. Let\u0026rsquo;s first talk a little about their history.\nOrigin story # uTrace, the predecessor # The desire to trace user space functions from the Linux kernel did not begin with the introduction of eBPF. For example, a (first?) attempt appeared in 2007 with uTraces:\nHowever, they were never included in the main code due to opposition from certain maintainers.\nHabemus uProbe # It wasn\u0026rsquo;t until 2012 that consensus was finally reached, and uProbes were introduced in version 3.5 of the Linux kernel:\nAt the time, uProbes were limited compared to what we know today.\nThey were then improved with version 3.14 (released in 2014, the same year that eBPF was introduced):\nThis patch made it possible to retrieve a greater amount of data, such as the return value of a function.\nuProbes then became fully usable even though eBPF had not yet been released. Let\u0026rsquo;s see when it was integrated.\nuProbe with eBPF # In the kProbe eBPF documentation, kProbe appeared in 2015 in version 4.1. Alexei Starovoitov, one of eBPF\u0026rsquo;s creators, was the one who initiated it:\nSince a uProbe is a kProbe with a different attachment point, we were able to start developing uProbes with eBPF as of April 2, 2015.\nHowever, we still had to wait for the eBPF frameworks of the time to be able to handle it.\nSo we could already use it in 2016 with BCC as evidenced by Brendan Gregg\u0026rsquo;s tutorial:\nYou can also see his GitHub issue from October 2015: Finally, here is a brief timeline of the history of uProbes:\n\u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rFree Medical icons\ruRetProbes were introduced at the same time as uProbes. Now that uProbe has been around for over 10 years, it\u0026rsquo;s fair to ask: is it still being used, and if so, by which projects?\nWhich projects use uâ€¢Retâ€¢Probe? # To challenge the common misconception that \u0026ldquo;eBPF is only used by three big companies\u0026rdquo;, I did a little research on tools that actually use uProbes, which means you may be using them without even knowing it\u0026hellip;\nPixie: Where is my mind? # The Pixie project uses uProbe in particular to trace TLS connections:\nThere is also an article by Douglas Mendez on capturing HTTPs traffic with Aya.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rThe Pixie Project is an observability tool for applications running on Kubernetes. Parca: Winter is coming! # The Parca project also uses uProbes.\nThe Parca project is a \u0026ldquo;continuous\u0026rdquo; profiling tool, i.e., it profiles systematically. Inspektor Gadget: I\u0026rsquo;m always on duty! # The Inspektor Gadget project has been creating tools based on uProbes and USDT probes since 2024:\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rThe Inspektor Gadget project provides tools (gadgets) and a framework for collecting data and inspecting the system on Kubernetes. Bonus Track # To conclude this presentation, I would like to share some interesting links that I found while researching uProbes:\nUsing uProbes without eBPF by Brendan Gregg in 2015: Julia Evans\u0026rsquo; excellent blog post on all tracing systems on Linux. You can also read her zine: If uProbes aren\u0026rsquo;t right for you, you might be interested in Eunomia\u0026rsquo;s bpftimes: Now that we\u0026rsquo;ve introduced uProbe and uRetProbe, let\u0026rsquo;s see how to get started with development using Aya.\nHow to start your Aya program? # When you start developing a new eBPF program, the first challenge is getting it to start. To do this, it needs an event-driven trigger. In this episode, this event will be the passage of a uProbe or uRetProbe in the Linux kernel.\nAya makes this task easier. When you run the command:\ncargo generate https://github.com/aya-rs/aya-template You will need to answer two important questions that will help define this event:\nðŸ¤· Target to attach the (u|uret)probe? (e.g libc): ðŸ¤· Function name to attach the (u|uret)probe? (e.g getaddrinfo): Let\u0026rsquo;s see how to answer them.\nTarget for attaching the uâ€¢Retâ€¢Probe # The first question asks for the name of a library (such as libc) or a binary. The question could have been phrased differently: which file do you want to debug or trace?\nThink of it as a filter:\nIf you choose libc, the eBPF program will only start if a program from libc is running. If you choose a binary, it will only start if the binary is running. But this is not enough to start the eBPF program. You need to be more specific: give the name of a function.\nName of the function to attach the uâ€¢Retâ€¢Probe # The second question asks for the function of the binary or library you want to debug.\nFor example:\nIf you choose the name of a function from a C program, the eBPF program will be launched each time it passes through this function. If you choose a function from libc, it will only be launched when a program calls this function from libc. If this seems a little too theoretical, we will finish the chapter by talking about a very useful tool that will allow us to illustrate this.\nGetting started with eBPF using bpftrace # The bpftrace project allows you to quickly create most types of eBPF programs dedicated to tracing, including uProbe and uRetProbe, as well as USDT, kProbe, and kRetProbe (see support here).\nFeel free to install it; it is probably packaged for your favorite Linux distribution.\nThe project was heavily inspired by DTrace, a tracing tool originally created for Unix systems such as Solaris, FreeBSD, and NetBSD in the early 2000s. Enough talk, let\u0026rsquo;s look at an example:\nsudo bpftrace -e \\ \u0026#39;uretprobe:/bin/bash:readline { printf(\u0026#34;%s\\n\u0026#34;, str(retval)); }\u0026#39; What does this mean?\nuretprobe: the type of eBPF program /bin/bash: the target binary readline: the name of the function { printf(\u0026quot;%s\\n\u0026quot;, str(retval)); }: the bpftrace program code (it displays the return value of the function) This command creates an eBPF program of type uRetProbe with the readline function of the bash binary as its attachment point.\nIf you have actually run the command, you will see that this creation is almost immediate! Let\u0026rsquo;s check that it works properly.\nStart another terminal and run a few commands of your choice. Here is an example of what you will see on the bpftrace terminal:\nAttaching 1 probe... ls -lrth hello man woman You can see all the commands you typed on the terminal!\nbpftrace can therefore be a good way to prototype a uProbe or uRetProbe program before generating it with Aya.\nWhat if I want to observe a function other than readline in the bash program? How do I do that? The first instinct would be to go into the bash code and look for another function, but there is an easier and safer way:\nbpftrace -l \u0026#39;uretprobe:/bin/bash:*\u0026#39; This command will list all the functions available in bash.\nWe can see that we can debug 1670 functions in bash: bpftrace -l 'uretprobe:/bin/bash:*' | wc -l Bpftrace will allow us to verify feasibility before creating the program in Rust with Aya.\nIn this episode, we looked at the basics of uProbes and uRetProbes: what they are used for, their history, who uses them, and how to find the right hook. We also looked at bpftrace, a tool that allows you to create probes quickly.\nNow let\u0026rsquo;s move on to the practical stuff. In the next episode, we\u0026rsquo;ll create a small Go program and make it interact with uProbe and uRetProbe eBPF programs using Aya.\n","date":"8 September 2025","externalUrl":null,"permalink":"/en/ebpf-another-type/uprobe/intro/","section":"Ebpf-Another-Types","summary":"An introduction to eBPF uProbes and uRetProbes with Aya","title":"Observability for All Developers with uProbes","type":"ebpf-another-type"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/tags/usdt/","section":"Tags","summary":"","title":"Usdt","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/series/apprenons-uprobe-avec-ebpf-et-aya/","section":"Series","summary":"","title":"Apprenons UProbe Avec EBPF Et Aya","type":"series"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/series/apprenons-un-autre-programme-ebpf/","section":"Series","summary":"","title":"Apprenons Un Autre Programme EBPF","type":"series"},{"content":"","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"}]