[{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/en/tags/aya/","section":"Tags","summary":"","title":"Aya","type":"tags"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/en/categories/development/","section":"Categories","summary":"","title":"Development","type":"categories"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/en/tags/ebpf/","section":"Tags","summary":"","title":"EBPF","type":"tags"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/en/ebpf-another-type/","section":"Ebpf-Another-Types","summary":"","title":"Ebpf-Another-Types","type":"ebpf-another-type"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/en/series/getting-started-with-ebpf-uprobes-in-aya/","section":"Series","summary":"","title":"Getting Started With EBPF UProbes in Aya","type":"series"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/en/tags/go/","section":"Tags","summary":"","title":"Go","type":"tags"},{"content":"We saw what a uProbe-type program was in part one: a way to probe the functions of your programs.\nIn this part, we will first create a very simple program in Go and make it interact with two eBPF programs:\nThe first is a uProbe type The second is a uRetProbe type \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rI assume you are already in an environment for developing with Aya and that you have installed the go compiler and bpftrace. If not, you can use the Killercoda lab:\nLet\u0026rsquo;s create a program to test the uProbes # A very simple code # For a change from Rust, we\u0026rsquo;re going to create a small program in Go:\n// hello.go package main import \u0026#34;fmt\u0026#34; func hello() int { fmt.Println(\u0026#34;Hello, world!\u0026#34;) return 3 } func main() { ret := hello() fmt.Println(\u0026#34;Returned:\u0026#34;, ret) } \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rYou can test another compiled program such as C/C++ or Rust if you prefer. How do we activate uProbes? # The purpose of this article is to activate:\nan eBPF program of type uProbe each time we enter the hello() function: an eBPF program of type uRetProbe each time we exit the hello() function: Now that we have seen the ins and outs of the article, let\u0026rsquo;s move on to compiling the program.\nLet\u0026rsquo;s compile the program # To compile it, just type:\ngo build -gcflags=\u0026#34;all=-N -l\u0026#34; -o hello hello.go You may notice that we added an option -gcflags=\u0026quot;all=-N -l\u0026quot;. Normally, you don\u0026rsquo;t need to use this option to compile a Go program:\ngo build -o hello hello.go This also works. So why use this option?\n-gcflags means go compiler flags; these are options passed to the Go compiler. all means that the options apply to all compiled packages. The options specified to the Go compiler are:\n-N: by default, the compiler modifies (mangles) the function name. This option disables this modification. In English, to mangle means to modify, mutilate, or even disfigure. -l: by default, the compiler inlines functions, i.e., it directly integrates the content of the function into the calling code, thus allowing programs to perform better. This option allows you to disable this inline. These options will allow us to keep the functions and make them readable, which will make it easier for us to find the attachment point for our eBPF program.\nHow to find the attachment point? # Now that we have created and compiled the small program, we need to figure out how to trigger the uProbe or uRetProbe type eBPF program. When using cargo generate for the aya repo, we need to answer two questions: where is the binary name and which function is being observed. Let\u0026rsquo;s take a closer look.\nName of the binary # ðŸ¤· Target to attach the (u|uret)probe? (e.g libc): To ensure the portability of the eBPF program, you must answer with the absolute path of the binary. For example, I created it here: /home/cloud_user/hello.\nFunction name # Once you have answered the first question, there is a second question:\nðŸ¤· Function name to attach the (u|uret)probe? (e.g getaddrinfo): What should you answer? You might be tempted to answer hello since you set the -N option, which disables name decoration during compilation.\nBut it\u0026rsquo;s a little more complicated than that. The Go compiler still slightly modifies the function name during the compilation stage.\nAs we saw in the previous episode, to find all the functions in a binary, just use bpftrace:\nbpftrace -l \u0026#39;uprobe:/home/cloud_user/hello:*\u0026#39; The -l option lists all available probes uprobe: the type of eBPF program /home/cloud_user/hello: the location of the binary *: the wildcard (0 or more characters) The display format is then:\nuprobe:/home/cloud_user/hello:[function1] uprobe:/home/cloud_user/hello:[function2] uprobe:/home/cloud_user/hello:[function3] uprobe:/home/cloud_user/hello:[function4] etc That\u0026rsquo;s unfortunate: the function name is the same as my file name\u0026hellip; We can\u0026rsquo;t do | grep hello. How can we get around this? With awk, cut, or worse, a regex? Let\u0026rsquo;s keep it simple:\nbpftrace -l \u0026#39;uprobe:/home/cloud_user/hello:*hello*\u0026#39; And it will respond with:\nuprobe:/home/cloud_user/hello:main.hello So the real name of the function is main.hello\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e If you can\u0026rsquo;t install bpftrace, you can use the nm command. It allows you to see all the symbols that are present in a binary file. Now that we have the answers to both questions, we can create our eBPF programs.\nLet\u0026rsquo;s start with the uProbe-type program.\nLet\u0026rsquo;s create an eBPF uProbe program # Let\u0026rsquo;s test with bpftrace # Before diving headfirst into an Aya program, let\u0026rsquo;s check that it works properly with bpftrace, the program that creates an eBPF program from a command line. That\u0026rsquo;s good timing: we already found the beginning in the previous section:\nuprobe:/home/cloud_user/hello:main.hello All that\u0026rsquo;s left to do is add a hello world:\nsudo bpftrace -e \\ \u0026#39;uprobe:/home/cloud_user/hello:main.hello { printf(\u0026#34;Hello go\\n\u0026#34;); }\u0026#39; Historically, you needed root privileges to install an eBPF program in the kernel. With modern Linux, a non-root user can install an eBPF program with just a few additional capabilities such as CAP_BPF. However, bpftrace does not support this: you must be root. In another terminal, let\u0026rsquo;s launch the hello program (without root privileges):\n./hello On the terminal where bpftrace is running, you will see Hello go each time you launch the hello program.\nLet\u0026rsquo;s check that we can create a similar program with Aya.\nGenerating the Aya program # Let\u0026rsquo;s define the different responses for the attachment point in variables. In my case, it will be:\ntarget=/home/cloud_user/hello fn_name=main.hello Now let\u0026rsquo;s run the command to generate the Aya program:\ncargo generate --name test-uprobe \\ -d program_type=uprobe \\ -d uprobe_target=$target \\ -d uprobe_fn_name=$fn_name \\ https://github.com/aya-rs/aya-template Without the options we specified, cargo generate would run in interactive mode: we would have to answer questions.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rTo find the names of the arguments (uprobe_target and uprobe_fn_name), you can look at the test.sh in the aya-template repo. You will get the following output:\nðŸ”§ program_type: \u0026#34;uprobe\u0026#34; (value from CLI) ðŸ”§ uprobe_target: \u0026#34;/home/cloud_user/hello\u0026#34; (value from CLI) ðŸ”§ uprobe_fn_name: \u0026#34;main.hello\u0026#34; (value from CLI) ðŸ”§ Destination: /home/cloud_user/test-uprobe ... ðŸ”§ project-name: test-uprobe ... ðŸ”§ Generating template ... [ 1/23] Done: .gitignore [ 2/23] Done: Cargo.toml [ 3/23] Done: LICENSE-APACHE [ 4/23] Done: LICENSE-GPL2 [ 5/23] Done: LICENSE-MIT [ 6/23] Done: README.md [ 7/23] Ignored: pre-script.rhai [ 8/23] Done: rustfmt.toml [ 9/23] Done: test-uprobe/Cargo.toml [10/23] Done: test-uprobe/build.rs [11/23] Done: test-uprobe/src/main.rs [12/23] Done: test-uprobe/src [13/23] Done: test-uprobe [14/23] Done: test-uprobe-common/Cargo.toml [15/23] Done: test-uprobe-common/src/lib.rs [16/23] Done: test-uprobe-common/src [17/23] Done: test-uprobe-common [18/23] Done: test-uprobe-ebpf/Cargo.toml [19/23] Done: test-uprobe-ebpf/build.rs [20/23] Done: test-uprobe-ebpf/src/lib.rs [21/23] Done: test-uprobe-ebpf/src/main.rs [22/23] Done: test-uprobe-ebpf/src [23/23] Done: test-uprobe-ebpf ðŸ”§ Initializing a fresh Git repository âœ¨ Done! New project created /home/cloud_user/test-uprobe Compilation and installation in the kernel # Now that we have generated the program, we need to compile it and install it in the Linux kernel:\ncd test-uprobe/ RUST_LOG=info cargo run For simplicity, I compiled and installed the eBPF program as root. This will take a little time the first time:\nUpdating crates.io index Locking 103 packages to latest compatible versions Adding which v6.0.3 (available: v8.0.0) Downloaded anstyle v1.0.11 Downloaded cfg-if v1.0.1 Downloaded anyhow v1.0.98 Downloaded either v1.15.0 Downloaded cargo_metadata v0.19.2 Downloaded version_check v0.9.5 Downloaded which v6.0.3 Downloaded socket2 v0.6.0 Downloaded mio v1.0.4 [...] warning: test-uprobe@0.1.0: Finished `release` profile [optimized] target(s) in 19.59s Finished `dev` profile [unoptimized + debuginfo] target(s) in 50.16s Running `/root/build-cache/debug/test-uprobe` Waiting for Ctrl-C... Let\u0026rsquo;s test it now # Leave the Aya program running and, on another terminal, launch the program you want to examine. In my case:\n./hello On the terminal where you launched the cargo run command, you should see the following output each time you launch the program:\n[INFO test_uprobe] function main.hello called by /home/cloud_user/hello You can see that the difficulty is the same as with bpftrace, but the compilation time is much longer.\nLetâ€™s create an eBPF uRetProbe program # We saw an example of a uProbe-type eBPF program where we didn\u0026rsquo;t have to modify the generated code. Now we\u0026rsquo;re going to make things a little more complex with a uRetProbe-type eBPF program and retrieve the return value.\nLet\u0026rsquo;s test with bpftrace # The bpftrace code is then slightly modified:\nsudo bpftrace -e \\ \u0026#39;uretprobe:/home/cloud_user/hello:main.hello { printf(\u0026#34;retval=%d\\n\u0026#34;, retval); }\u0026#39; uprobe is replaced by uretprobe The return variable has been added: retval Run the hello program in another terminal and you will see in the bpftrace terminal:\nretval=3 Let\u0026rsquo;s see how to produce the equivalent program in Aya.\nGenerating the Aya program # The code is generated in a similar way to uProbe:\ntarget=/home/cloud_user/hello fn_name=main.hello cargo generate --name test-uretprobe \\ -d program_type=uretprobe \\ -d uprobe_target=$target \\ -d uprobe_fn_name=$fn_name \\ https://github.com/aya-rs/aya-template Compilation and installation # In the same way, we will compile and install the eBPF program:\ncd test-uretprobe/ RUST_LOG=info cargo run At the end of each hello() function, the eBPF program displays:\n[INFO test_uretprobe] function main.hello called by /home/cloud_user/hello So far, we have done pretty much the same thing as for uProbe. Now let\u0026rsquo;s see how to retrieve the return value 3.\nModifying the code # We need to modify the file test-uretprobe-ebpf/src/main.rs: the kernel space code. Specifically, this piece of code:\nfn try_test_uretprobe(ctx: RetProbeContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { info!(\u0026amp;ctx, \u0026#34;function main.hello called by /home/cloud_user/hello\u0026#34;); Ok(0) } We need to see how to use the RetProbeContext structure to display the return code.\nLet\u0026rsquo;s look at the documentation:\nSo we need to use the ret() method. We\u0026rsquo;ll add something like this:\nlet retval: u32 = ctx.ret().ok_or(1u32)?; \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e If the function has no return value, we display 1u32 (32-bit unsigned integer) because the function signature is Result\u0026lt;u32, u32\u0026gt;. We also need to modify the Aya macro info! to display this value.\nThis gives us the following result:\nfn try_test_uretprobe(ctx: RetProbeContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let retval: u32 = ctx.ret().ok_or(1u32)?; info!(\u0026amp;ctx, \u0026#34;retval={}\u0026#34;, retval); Ok(0) } Let\u0026rsquo;s test it now. # Apply the changes:\nRUST_LOG=info cargo run Run the hello command in another terminal:\n./hello And on the Aya program side, we get the following display:\n[INFO test_uretprobe] retval=3 This is consistent with what we found with bpftrace.\nThis episode is now complete! We\u0026rsquo;ve seen the basics of making an uProbe and uRetProbe eBPF program react when launching a Go program.\nHowever, we haven\u0026rsquo;t yet explored how to retrieve the arguments of a function.\nThat\u0026rsquo;s perfect timing! In the next episode, we\u0026rsquo;ll probe a well-known library by retrieving function arguments and processing them!\n","date":"15 September 2025","externalUrl":null,"permalink":"/en/ebpf-another-type/uprobe/example-1/","section":"Ebpf-Another-Types","summary":"Letâ€™s observe a small Go program using uProbes and uRetProbes with Aya","title":"Letâ€™s Observe a Simple Function in Your Program with uProbes","type":"ebpf-another-type"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/en/tags/rust/","section":"Tags","summary":"","title":"Rust","type":"tags"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/en/","section":"The Little Joâ€™s Blog","summary":"","title":"The Little Joâ€™s Blog","type":"page"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/en/categories/tutorial/","section":"Categories","summary":"","title":"Tutorial","type":"categories"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/en/tags/uprobe/","section":"Tags","summary":"","title":"Uprobe","type":"tags"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/en/tags/uretprobe/","section":"Tags","summary":"","title":"Uretprobe","type":"tags"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/series/apprenons-uprobe-avec-ebpf-et-aya/","section":"Series","summary":"","title":"Apprenons UProbe Avec EBPF Et Aya","type":"series"},{"content":"We saw what a uProbe-type program was in part one: a way to probe a library.\nWe will verify this with an Aya program that will retrieve the various arguments of the execve() function from Libc.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rI assume you are already in an environment for developing with Aya and that you have installed bpftrace. If not, you can use the Killercoda lab:\nWhat are we really going to do? # Libc # Unlike in the previous section, where we attached our eBPF program to a program, here we are attaching it to a shared library.\nLibc is the standard C library. So every time a C (or C++) program is executed, an eBPF program could potentially be launched.\n\u003c?xml version=\"1.0\" encoding=\"iso-8859-1\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rI refer to libc throughout this chapter. To be more precise, we should refer to glibc (GNU C Library), the most widely used implementation in GNU/Linux distributions (such as Debian or Red Hat). But there are other implementations such as musl (notably for Alpine Linux) or ulibc, which are lighter and more suited to embedded systems. The execve function # execve is a system call (a syscall) from the Linux kernel. But it is also the name of a function in libc that calls this same syscall (a wrapper). Thus, each time the execve() function of libc is called, our uProbe-type eBPF program will be launched.\nThe arguments of the execve function # We also need to retrieve the various arguments of the execve() function.\nTo find its arguments, we could obviously look in the libc source code. But there is an easier way:\nman execve The part that interests us is the following:\nint execve(const char *pathname, char *const _Nullable argv[], char *const _Nullable envp[]); We can see that the function has three arguments:\npathname: the name of the command with the full path (e.g., /bin/bash). It is of type const char * (equivalent in Rust to *const u8). argv: an array of command arguments. It is of type char *const _Nullable[] (equivalent in Rust to *const *const u8) argv[0]: the name of the command argv[1]: the first option etc. envp: an array of command environment variables. It is of type char *const _Nullable[] (equivalent in Rust to *const *const u8). \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e _Nullable simply indicates that the value can be NULL. How to trigger the eBPF program? # Let\u0026rsquo;s take a simple example. If you run a command in a terminal, for example ls, what will happen?\nThanks to the PATH environment variable, the shell (for example bash) will find the right path to locate the ls binary: /usr/bin/ls To execute the binary, the shell will then call the execve() function from libc: execve(\u0026#34;/usr/bin/ls\u0026#34;, [\u0026#39;ls\u0026#39;], [\u0026#34;PATH=/bin:/usr/bin\u0026#34;, ...]) The eBPF program will finally be triggered. Here is a brief summary of all this:\nThere are obviously other programs besides shells that call the execve() function in libc, such as systemd for starting various programs on a Linux system.\nSo we are going to create a program very similar to the one we created with the sys_enter_execve tracepoint in the introductory articles on eBPF, but this one will be attached at the user level to the execve() function of libc.\nLet\u0026rsquo;s generate an uProbe-type Aya program # So we already have the answers to both questions:\nðŸ¤· Target to attach the (u|uret)probe? (e.g libc): ðŸ¤· Function name to attach the (u|uret)probe? (e.g getaddrinfo): Let\u0026rsquo;s see how to create an eBPF Hello world program for this attachment point.\nLet\u0026rsquo;s test it with bpftrace # First, let\u0026rsquo;s check that it works with the bpftrace command line:\nsudo bpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;Hello execve\\n\u0026#34;); }\u0026#39; uprobe: the type of eBPF program libc: the name of the library execve: the function to debug { printf(\u0026quot;Hello execve\\n\u0026quot;); }: the bpftrace code Each time we run a command on another terminal, we see Hello execve.\nNow let\u0026rsquo;s do it with Aya.\nGenerating and compiling the Aya program # The following cargo generate command generates the eBPF program:\ncargo generate --name test-uprobe-2 \\ -d program_type=uprobe \\ -d uprobe_target=libc \\ -d uprobe_fn_name=execve \\ https://github.com/aya-rs/aya-template \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rTo find the names of the arguments (uprobe_target and uprobe_fn_name), you can look at the test.sh in the aya-template repo. Now let\u0026rsquo;s compile it and install it in the Linux kernel:\ncd test-uprobe-2/ RUST_LOG=info cargo run Testing the program # On another terminal, launch any program:\nls On the cargo run terminal, you will see:\n[INFO test_uprobe] function execve called by libc In the previous section, we left off at this point regarding uProbes. Let\u0026rsquo;s look at how to retrieve the various arguments of the execve() function. Let\u0026rsquo;s start with the first one: the name of the binary.\nLet\u0026rsquo;s retrieve the name of the binary # Let\u0026rsquo;s test with bpftrace # Before modifying the Aya code, let\u0026rsquo;s see how to do it with bpftrace. It\u0026rsquo;s a bit more complicated than a simple hello world.\nTo retrieve the first argument, we use arg0:\nsudo bpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;%d\\n\u0026#34;, arg0); }\u0026#39; We retrieve the address where the first argument is located. How do we \u0026ldquo;convert\u0026rdquo; it to a string? Just use the str() function:\nsudo bpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;%s\\n\u0026#34;, str(arg0)); }\u0026#39; Now that we have the draft with bpftrace, let\u0026rsquo;s see how to implement it with Aya.\nLet\u0026rsquo;s modify the Aya code # \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e Continued reading reserved for premium members âœ¨\nThe full article is only available to premium members.\nBecoming a premium member is easy: just make a small donation ðŸ’–\nIn exchange, you will receive for 1 year (early bird offer):\nAccess to all full articles as soon as they are published Early reading before public release Participation in supporting this independent blog Exclusive access to my vacation photos in Dubai Your donation will help:\nMake me less dependent on large platforms Encourage me to create more technical content Lift the paywall more quickly for everyone ðŸ‘‰ Become a premium member now\n","date":"15 September 2025","externalUrl":null,"permalink":"/en/ebpf-another-type/uprobe/example-2-tr/","section":"Ebpf-Another-Types","summary":"Letâ€™s probe the function \u003ccode\u003eexecve\u003c/code\u003e in libc using eBPF uProbe with Aya","title":"Letâ€™s Probe a Library with an eBPF uProbe","type":"ebpf-another-type"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/en/categories/teaser/","section":"Categories","summary":"","title":"Teaser","type":"categories"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/tags/bpftrace/","section":"Tags","summary":"","title":"Bpftrace","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/categories/introduction/","section":"Categories","summary":"","title":"Introduction","type":"categories"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/tags/kprobe/","section":"Tags","summary":"","title":"Kprobe","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/series/lets-learn-another-ebpf-program/","section":"Series","summary":"","title":"Letâ€™s Learn Another EBPF Program","type":"series"},{"content":"I\u0026rsquo;m getting started with eBPF programming with Aya. The idea behind this series of articles is to learn about a new type of eBPF program and experiment with it using the Rust Aya framework.\nToday, we\u0026rsquo;re going to dive into uProbes and uRetProbes: eBPF programs that probe user space functions without leaving a trace.\nYou\u0026rsquo;ll see that this can be very useful for profiling, debugging, or even reverse engineering.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e If you\u0026rsquo;re not familiar with eBPF, I recommend reading the first two parts of my series Getting Started with eBPF with Aya. This covers the basics and will help you understand the rest of the article. What is a uâ€¢Retâ€¢Probe? # In English, a probe can be defined as a device used to examine or explore something. In eBPF, there are several types: kProbe, kRetProbe, uProbe, uRetProbe, and USDT.\nkProbe: the probe for the kernel # If you consult the eBPF documentation, there is no section dedicated to uProbe or uRetProbe type programs. But there is one dedicated to kProbe:\nThe purpose of kProbe is to observe Linux kernel functions. It can be considered the parent probe. All other probes are in fact the same type of program BPF_PROG_TYPE_KPROBE, but it is just the attachment point that determines how the program is executed.\nkRetProbe: feedback on the kernel probe # The kRetProbe is simply dedicated to observing the return of Linux kernel functions. This probe allows you to check whether the function call has completed successfully.\nWe have briefly looked at kProbe and kRetProbe, which could be the subject of other articles. Let\u0026rsquo;s now talk about the probes that interest us today: uProbe and uRetProbe.\nuProbe: the probe for users # Unlike kProbes, which are dedicated to observing Linux kernel functions, uProbes are dedicated to user space functions: User-space Probes. For example, they could be used to count the number of calls to the malloc and free functions in a C program.\nuProbe also allows you to retrieve the content of the arguments of the observed function. This means you could look at the amount of memory allocated to each malloc or check that free is actually freeing the right pointers.\nuProbes could therefore be integrated into a CI to automate security checks, facilitate debugging, or assist with memory diagnostics.\n\u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rFree Medical icons\rIt may seem paradoxical to want to trace user code from kernel space. However, this has the advantage of being non-intrusive, as there is no need to modify the program. uRetProbe: user probe return # Like kRetProbe, uRetProbe is designed to study the return of the target function in user space: User-space Return Probe. This allows us to discover the value returned by the function. This makes it possible to debug or observe the final behavior of the function.\nBut there is another benefit: by combining the times from uProbe and uRetProbe, we can easily retrieve the time it takes for a function to execute. This makes it possible to profile a function in your program.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e file_type_sql For example, you could use it for SQL queries to identify the longest queries. uRetProbes and uProbes can be used to debug and understand a program for which you do not have the source code. This can be a useful reverse engineering tool.\nHowever, they are limited to programs written in compiled languages: C/C++, Rust, Go, etc. If you have a program developed in another language, USDT might be a good fit for you. Let\u0026rsquo;s talk about it.\nUSDT: the user space tracepoint # USDT stands for User Statically-Defined Tracing. As its name suggests, it is also dedicated to user space programs, but usdt probes must be added to the code in order to use them. USDT is, in fact, derived from uProbe.\nHowever, it is much more accurate than uProbe. The uProbe is confined to the beginning of the function, while the usdt probe can be placed anywhere in the code.\nHere is an example of Python code:\ndef benchmark_module(): loop = 0 for _ in range(100000): pyusdt.trace_start_loop(loop) calculate_pi(1000) pyusdt.trace_stop_loop(loop) loop += 1 With this code, we can get the time it takes to calculate the first 1000 decimal places of Ï€.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rAt the time of writing, the Aya framework does not yet support USDT-type programs. We will now focus on uProbes and uRetProbes for the rest of this article. Let\u0026rsquo;s first talk a little about their history.\nOrigin story # uTrace, the predecessor # The desire to trace user space functions from the Linux kernel did not begin with the introduction of eBPF. For example, a (first?) attempt appeared in 2007 with uTraces:\nHowever, they were never included in the main code due to opposition from certain maintainers.\nHabemus uProbe # It wasn\u0026rsquo;t until 2012 that consensus was finally reached, and uProbes were introduced in version 3.5 of the Linux kernel:\nAt the time, uProbes were limited compared to what we know today.\nThey were then improved with version 3.14 (released in 2014, the same year that eBPF was introduced):\nThis patch made it possible to retrieve a greater amount of data, such as the return value of a function.\nuProbes then became fully usable even though eBPF had not yet been released. Let\u0026rsquo;s see when it was integrated.\nuProbe with eBPF # In the kProbe eBPF documentation, kProbe appeared in 2015 in version 4.1. Alexei Starovoitov, one of eBPF\u0026rsquo;s creators, was the one who initiated it:\nSince a uProbe is a kProbe with a different attachment point, we were able to start developing uProbes with eBPF as of April 2, 2015.\nHowever, we still had to wait for the eBPF frameworks of the time to be able to handle it.\nSo we could already use it in 2016 with BCC as evidenced by Brendan Gregg\u0026rsquo;s tutorial:\nYou can also see his GitHub issue from October 2015: Finally, here is a brief timeline of the history of uProbes:\n\u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rFree Medical icons\ruRetProbes were introduced at the same time as uProbes. Now that uProbe has been around for over 10 years, it\u0026rsquo;s fair to ask: is it still being used, and if so, by which projects?\nWhich projects use uâ€¢Retâ€¢Probe? # To challenge the common misconception that \u0026ldquo;eBPF is only used by three big companies\u0026rdquo;, I did a little research on tools that actually use uProbes, which means you may be using them without even knowing it\u0026hellip;\nPixie: Where is my mind? # The Pixie project uses uProbe in particular to trace TLS connections:\nThere is also an article by Douglas Mendez on capturing HTTPs traffic with Aya.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rThe Pixie Project is an observability tool for applications running on Kubernetes. Parca: Winter is coming! # The Parca project also uses uProbes.\nThe Parca project is a \u0026ldquo;continuous\u0026rdquo; profiling tool, i.e., it profiles systematically. Inspektor Gadget: I\u0026rsquo;m always on duty! # The Inspektor Gadget project has been creating tools based on uProbes and USDT probes since 2024:\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rThe Inspektor Gadget project provides tools (gadgets) and a framework for collecting data and inspecting the system on Kubernetes. Bonus Track # To conclude this presentation, I would like to share some interesting links that I found while researching uProbes:\nUsing uProbes without eBPF by Brendan Gregg in 2015: Julia Evans\u0026rsquo; excellent blog post on all tracing systems on Linux. You can also read her zine: If uProbes aren\u0026rsquo;t right for you, you might be interested in Eunomia\u0026rsquo;s bpftimes: Now that we\u0026rsquo;ve introduced uProbe and uRetProbe, let\u0026rsquo;s see how to get started with development using Aya.\nHow to start your Aya program? # When you start developing a new eBPF program, the first challenge is getting it to start. To do this, it needs an event-driven trigger. In this episode, this event will be the passage of a uProbe or uRetProbe in the Linux kernel.\nAya makes this task easier. When you run the command:\ncargo generate https://github.com/aya-rs/aya-template You will need to answer two important questions that will help define this event:\nðŸ¤· Target to attach the (u|uret)probe? (e.g libc): ðŸ¤· Function name to attach the (u|uret)probe? (e.g getaddrinfo): Let\u0026rsquo;s see how to answer them.\nTarget for attaching the uâ€¢Retâ€¢Probe # The first question asks for the name of a library (such as libc) or a binary. The question could have been phrased differently: which file do you want to debug or trace?\nThink of it as a filter:\nIf you choose libc, the eBPF program will only start if a program from libc is running. If you choose a binary, it will only start if the binary is running. But this is not enough to start the eBPF program. You need to be more specific: give the name of a function.\nName of the function to attach the uâ€¢Retâ€¢Probe # The second question asks for the function of the binary or library you want to debug.\nFor example:\nIf you choose the name of a function from a C program, the eBPF program will be launched each time it passes through this function. If you choose a function from libc, it will only be launched when a program calls this function from libc. If this seems a little too theoretical, we will finish the chapter by talking about a very useful tool that will allow us to illustrate this.\nGetting started with eBPF using bpftrace # The bpftrace project allows you to quickly create most types of eBPF programs dedicated to tracing, including uProbe and uRetProbe, as well as USDT, kProbe, and kRetProbe (see support here).\nFeel free to install it; it is probably packaged for your favorite Linux distribution.\nThe project was heavily inspired by DTrace, a tracing tool originally created for Unix systems such as Solaris, FreeBSD, and NetBSD in the early 2000s. Enough talk, let\u0026rsquo;s look at an example:\nsudo bpftrace -e \\ \u0026#39;uretprobe:/bin/bash:readline { printf(\u0026#34;%s\\n\u0026#34;, str(retval)); }\u0026#39; What does this mean?\nuretprobe: the type of eBPF program /bin/bash: the target binary readline: the name of the function { printf(\u0026quot;%s\\n\u0026quot;, str(retval)); }: the bpftrace program code (it displays the return value of the function) This command creates an eBPF program of type uRetProbe with the readline function of the bash binary as its attachment point.\nIf you have actually run the command, you will see that this creation is almost immediate! Let\u0026rsquo;s check that it works properly.\nStart another terminal and run a few commands of your choice. Here is an example of what you will see on the bpftrace terminal:\nAttaching 1 probe... ls -lrth hello man woman You can see all the commands you typed on the terminal!\nbpftrace can therefore be a good way to prototype a uProbe or uRetProbe program before generating it with Aya.\nWhat if I want to observe a function other than readline in the bash program? How do I do that? The first instinct would be to go into the bash code and look for another function, but there is an easier and safer way:\nbpftrace -l \u0026#39;uretprobe:/bin/bash:*\u0026#39; This command will list all the functions available in bash.\nWe can see that we can debug 1670 functions in bash: bpftrace -l 'uretprobe:/bin/bash:*' | wc -l Bpftrace will allow us to verify feasibility before creating the program in Rust with Aya.\nIn this episode, we looked at the basics of uProbes and uRetProbes: what they are used for, their history, who uses them, and how to find the right hook. We also looked at bpftrace, a tool that allows you to create probes quickly.\nNow let\u0026rsquo;s move on to the practical stuff. In the next episode, we\u0026rsquo;ll create a small Go program and make it interact with uProbe and uRetProbe eBPF programs using Aya.\n","date":"8 September 2025","externalUrl":null,"permalink":"/en/ebpf-another-type/uprobe/intro/","section":"Ebpf-Another-Types","summary":"An introduction to eBPF uProbes and uRetProbes with Aya","title":"Observability for All Developers with uProbes","type":"ebpf-another-type"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/tags/usdt/","section":"Tags","summary":"","title":"Usdt","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/series/apprenons-un-autre-programme-ebpf/","section":"Series","summary":"","title":"Apprenons Un Autre Programme EBPF","type":"series"},{"content":"","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"}]