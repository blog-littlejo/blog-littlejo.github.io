[{"content":"","date":"29 October 2025","externalUrl":null,"permalink":"/en/ebpf-another-type/","section":"Ebpf-Another-Types","summary":"","title":"Ebpf-Another-Types","type":"ebpf-another-type"},{"content":"","date":"29 October 2025","externalUrl":null,"permalink":"/en/","section":"The Little Jo‚Äôs Blog","summary":"","title":"The Little Jo‚Äôs Blog","type":"page"},{"content":"","date":"29 October 2025","externalUrl":null,"permalink":"/en/tags/aya/","section":"Tags","summary":"","title":"Aya","type":"tags"},{"content":"","date":"29 October 2025","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"29 October 2025","externalUrl":null,"permalink":"/en/categories/development/","section":"Categories","summary":"","title":"Development","type":"categories"},{"content":"","date":"29 October 2025","externalUrl":null,"permalink":"/en/tags/ebpf/","section":"Tags","summary":"","title":"EBPF","type":"tags"},{"content":"","date":"29 October 2025","externalUrl":null,"permalink":"/en/series/getting-started-with-xdp-in-aya/","section":"Series","summary":"","title":"Getting Started With XDP in Aya","type":"series"},{"content":"We saw what an XDP program is in part one: it can be used to mitigate distributed denial-of-service (DDoS) attacks.\nIn this part, i will show you how to create an XDP program that mitigates SYN flood attacks. We\u0026rsquo;ll do that with the Rust Aya framework.\nFollow the guide!\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rlab\rI assume you are already in an environment for developing with Aya. If not, you can use the Killercoda lab:\nLet\u0026rsquo;s create a little tcpdump with XDP # Before doing that, we will first explain how to analyze a TCP segment with XDP and thus retrieve SYN packets. By the way, do you remember how TCP works?\nTCP connections # TCP stands for Transmission Control Protocol. It is probably the most widely used network protocol by application protocols such as HTTP, SSH, etc. It is difficult to ignore in articles about networks. However, it is probably the most complex when compared to UDP or ICMP.\nBefore downloading useful data, there is a connection phase (3-way handshake) to establish a reliable channel.\nWhat is SYN Flood? # SYN is the first TCP segment used to initiate a TCP connection. When a server receives a SYN, it must send back a SYN-ACK to acknowledge receipt. Once this is done, the client must confirm with an ACK and the data download can finally take place.\nSuppose a client sends a SYN connection but never responds. What happens?\nThe server sends a SYN-ACK in response and then retries 5 times (default value). The server finally closes the incomplete connection Suppose a client floods the server with lots of SYN connections but never responds. What happens?\nThe server then keeps a lot of connections ‚Äúpending‚Äù (some of which are probably legitimate) The server continues to send SYN-ACK until its memory resources are saturated That\u0026rsquo;s the principle behind a SYN Flood attack.\nIn this article, to counter this attack, we will count the number of SYN per IP and if there are too many, we will temporarily block these segments for that IP.\nHow to view segment details # If you haven\u0026rsquo;t already done so, let\u0026rsquo;s recreate the development environment:\ngit clone https://github.com/littlejo/eunomia.dev cd eunomia.dev/docs/tutorials/42-xdp-loadbalancer/ ./setup.sh Let\u0026rsquo;s start a small web server at the lb namespace level:\nip netns exec lb python3 -m http.server 8080 On the veth6 interface, we will see the TCP packets sent by the client (such as SYN); On the veth7 interface, we will see the TCP packets sent by the server (such as SYN-ACK). We therefore need to install the eBPF program on veth6.\nLet\u0026rsquo;s generate the Aya program:\ncargo generate --name antiddos-xdp \\ -d program_type=xdp \\ -d default_iface=veth6 \\ https://github.com/aya-rs/aya-template cd antiddos-xdp In anticipation, we will use additional crates:\naya-ebpf-bindings for additional eBPF bindings network-types for Rust structures of level 1, 2, and 3 headers blog-xdp, the crate from this blog, so we don\u0026rsquo;t have to copy/paste previously written helper functions So we\u0026rsquo;re going to modify the antiddos-xdp-ebpf/Cargo.toml file and add the following to the dependencies section:\naya-ebpf-bindings = \u0026#34;0.1.1\u0026#34; network-types = \u0026#34;0.1.0\u0026#34; blog-xdp = { git = \u0026#34;https://github.com/littlejo/blog-xdp\u0026#34; } Let\u0026rsquo;s check that the generated program works properly:\nFirst, we\u0026rsquo;ll build the binary:\ncargo build Then we\u0026rsquo;ll install it in the target namespace where the veth6 interface is located:\nip netns exec lb cargo run Since the namespace does not have Internet access, we must first download the crates to compile them on the server, then install the eBPF program in the namespace. Now we will retrieve only TCP packets in the eBPF program. We will modify the antiddos-xdp-ebpf/src/main.rs file. We end up with code similar to the code in the previous section:\nuse network_types::{ eth::{EthHdr, EtherType}, ip::{Ipv4Hdr, IpProto}, tcp::TcpHdr, }; use blog_xdp::helper::ptr_at; fn try_antiddos_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0)?; match unsafe { (*ethhdr).ether_type() } { Ok(EtherType::Ipv4) =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } let ipv4hdr: *const Ipv4Hdr = ptr_at(\u0026amp;ctx, EthHdr::LEN)? ; match unsafe { (*ipv4hdr).proto } { IpProto::Tcp =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } let tcphdr: *const TcpHdr = ptr_at(\u0026amp;ctx, EthHdr::LEN + Ipv4Hdr::LEN)? ; let src_addr = unsafe { (*ipv4hdr).src_addr }; let dst_addr = unsafe { (*ipv4hdr).dst_addr }; info!(\u0026amp;ctx, \u0026#34;src:{:i} =\u0026gt; dst:{:i}\u0026#34;, src_addr, dst_addr); Ok(xdp_action::XDP_PASS) } We can test that it works:\nip netns exec lb cargo run Then, use the following command to test the XDP program:\ncurl 10.0.0.10:8080 In the Cargo output, we can see several packets passing through:\n[INFO antiddos_xdp] src:10.0.0.1 =\u0026gt; dst:10.0.0.10 [INFO antiddos_xdp] src:10.0.0.1 =\u0026gt; dst:10.0.0.10 [INFO antiddos_xdp] src:10.0.0.1 =\u0026gt; dst:10.0.0.10 [INFO antiddos_xdp] src:10.0.0.1 =\u0026gt; dst:10.0.0.10 [INFO antiddos_xdp] src:10.0.0.1 =\u0026gt; dst:10.0.0.10 [INFO antiddos_xdp] src:10.0.0.1 =\u0026gt; dst:10.0.0.10 As I explained at the beginning, when we launch a TCP connection, there is not just one packet but several packets.\nWe only see the packets sent by the client (those marked ingress).\nIf we want to see the packets sent by the server, we need to install the program on the veth7 interface. It\u0026rsquo;s very simple, just override the iface variable:\ncargo run -- --iface veth7 To display a little more detail about the nature of the packets, let\u0026rsquo;s now look at the TCP segment header:\nFor purists, the diagram is somewhat simplified.\nLet\u0026rsquo;s take a quick look at what the main data is used for:\nSRC/DST PORT: TCP ports SEQUENCE/ACK NUMBER: for connection tracking BITFIELD: this is where we define the nature of the segment (SYN, ACK, etc.) WINDOW: for flow control (useful for big files) CHECKSUM: for segment integrity As with UDP, we can easily retrieve the elements by looking at the crate documentation network-types:\nTo retrieve the nature of the segment, there are even functions to help us: To reproduce a small tcpdump, let\u0026rsquo;s add this, for example:\nlet src_port = u16::from_be_bytes(unsafe { (*tcphdr).source }); let dst_port = u16::from_be_bytes(unsafe { (*tcphdr).dest }); let seq = u32::from_be_bytes(unsafe {(*tcphdr).seq}); let ack_seq = u32::from_be_bytes(unsafe {(*tcphdr).ack_seq}); let syn = unsafe {(*tcphdr).syn()}; let ack = unsafe {(*tcphdr).ack()}; let psh = unsafe {(*tcphdr).psh()}; let fin = unsafe {(*tcphdr).fin()}; info!(\u0026amp;ctx, \u0026#34;seq: {}, ack_seq: {}, syn: {}, ack: {}, data: {}, fin: {}, src: {:i}:{}, dst: {:i}:{}\u0026#34;, seq, ack_seq, syn, ack, psh, fin, src_addr, src_port, dst_addr, dst_port); Let\u0026rsquo;s install this program on both network interfaces:\nip netns exec lb cargo run cargo run -- --iface veth7 Let\u0026rsquo;s launch a connection:\ncurl 10.0.0.10:8080 At the veth6 level, we can then see the details of the different segments:\n[INFO antiddos_xdp] seq: 2481734691, ack_seq: 0, syn: 1, ack: 0, data: 0, fin: 0, src: 10.0.0.1:47632, dst: 10.0.0.10:8080 [INFO antiddos_xdp] seq: 2481734692, ack_seq: 161636304, syn: 0, ack: 1, data: 0, fin: 0, src: 10.0.0.1:47632, dst: 10.0.0.10:8080 [INFO antiddos_xdp] seq: 2481734692, ack_seq: 161636304, syn: 0, ack: 1, data: 1, fin: 0, src: 10.0.0.1:47632, dst: 10.0.0.10:8080 [INFO antiddos_xdp] seq: 2481734769, ack_seq: 161636460, syn: 0, ack: 1, data: 0, fin: 0, src: 10.0.0.1:47632, dst: 10.0.0.10:8080 [INFO antiddos_xdp] seq: 2481734769, ack_seq: 161637894, syn: 0, ack: 1, data: 0, fin: 0, src: 10.0.0.1:47632, dst: 10.0.0.10:8080 [INFO antiddos_xdp] seq: 2481734769, ack_seq: 161637894, syn: 0, ack: 1, data: 0, fin: 1, src: 10.0.0.1:47632, dst: 10.0.0.10:8080 [INFO antiddos_xdp] seq: 2481734770, ack_seq: 161637895, syn: 0, ack: 1, data: 0, fin: 0, src: 10.0.0.1:47632, dst: 10.0.0.10:8080 At the veth7 level:\n[INFO antiddos_xdp] seq: 161636303, ack_seq: 2481734692, syn: 1, ack: 1, data: 0, fin: 0, src: 10.0.0.10:8080, dst: 10.0.0.1:47632, [INFO antiddos_xdp] seq: 161636304, ack_seq: 2481734769, syn: 0, ack: 1, data: 0, fin: 0, src: 10.0.0.10:8080, dst: 10.0.0.1:47632, [INFO antiddos_xdp] seq: 161636304, ack_seq: 2481734769, syn: 0, ack: 1, data: 1, fin: 0, src: 10.0.0.10:8080, dst: 10.0.0.1:47632, [INFO antiddos_xdp] seq: 161636460, ack_seq: 2481734769, syn: 0, ack: 1, data: 1, fin: 0, src: 10.0.0.10:8080, dst: 10.0.0.1:47632, [INFO antiddos_xdp] seq: 161637894, ack_seq: 2481734769, syn: 0, ack: 1, data: 0, fin: 1, src: 10.0.0.10:8080, dst: 10.0.0.1:47632, [INFO antiddos_xdp] seq: 161637895, ack_seq: 2481734770, syn: 0, ack: 1, data: 0, fin: 0, src: 10.0.0.10:8080, dst: 10.0.0.1:47632, Now that we have seen all the details of a TCP segment, we will now focus solely on SYN type segments:\nmatch unsafe { (*tcphdr).syn() } { 1 =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } If we are dealing with a SYN, we continue processing; otherwise, we let the packet pass.\nSince we will no longer be touching this part of the code, we will create a function:\n#[inline(always)] fn filter_tcp_syn_src(ctx: \u0026amp;XdpContext) -\u0026gt; Option\u0026lt;[u8; 4]\u0026gt; { let ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0).ok()?; match unsafe { (*ethhdr).ether_type() } { Ok(EtherType::Ipv4) =\u0026gt; {} _ =\u0026gt; return None, } let ipv4hdr: *const Ipv4Hdr = ptr_at(\u0026amp;ctx, EthHdr::LEN).ok()? ; match unsafe { (*ipv4hdr).proto } { IpProto::Tcp =\u0026gt; {} _ =\u0026gt; return None, } let tcphdr: *const TcpHdr = ptr_at(\u0026amp;ctx, EthHdr::LEN + Ipv4Hdr::LEN).ok()? ; match unsafe { (*tcphdr).syn() } { 1 =\u0026gt; {} _ =\u0026gt; return None, } let src_addr = unsafe { (*ipv4hdr).src_addr }; Some(src_addr) } fn try_antiddos_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let src_addr = match filter_tcp_syn_src(\u0026amp;ctx) { Some(x) =\u0026gt; x, None =\u0026gt; return Ok(xdp_action::XDP_PASS), }; info!(ctx, \u0026#34;{}\u0026#34;, src_addr); Ok(xdp_action::XDP_PASS) } We only retrieve the source IP address from this function in order to potentially block it.\nThis will allow us to focus on the code to prevent the attack.\nLet‚Äôs try mitigating SYN flood attacks # \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e Continued reading reserved for premium members ‚ú®\nThe full article is only available to premium members.\nBecoming a premium member is easy: just make a small donation üíñ\nIn exchange, you will receive for 1 year (early bird offer):\nAccess to all full articles as soon as they are published Early reading before public release Participation in supporting this independent blog Exclusive access to my vacation photos in Dubai Your donation will help:\nMake me less dependent on large platforms Encourage me to create more technical content Lift the paywall more quickly for everyone üëâ Become a premium member now\n","date":"29 October 2025","externalUrl":null,"permalink":"/en/ebpf-another-type/xdp/example-2-tr/","section":"Ebpf-Another-Types","summary":"Let‚Äôs see how to mitigate denial-of-service attacks with XDP.","title":"Let's Mitigate DDoS Attacks with XDP","type":"ebpf-another-type"},{"content":"","date":"29 October 2025","externalUrl":null,"permalink":"/en/categories/network/","section":"Categories","summary":"","title":"Network","type":"categories"},{"content":"","date":"29 October 2025","externalUrl":null,"permalink":"/en/tags/rust/","section":"Tags","summary":"","title":"Rust","type":"tags"},{"content":"","date":"29 October 2025","externalUrl":null,"permalink":"/en/categories/security/","section":"Categories","summary":"","title":"Security","type":"categories"},{"content":"","date":"29 October 2025","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"29 October 2025","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"29 October 2025","externalUrl":null,"permalink":"/en/categories/teaser/","section":"Categories","summary":"","title":"Teaser","type":"categories"},{"content":"","date":"29 October 2025","externalUrl":null,"permalink":"/en/categories/tutorial/","section":"Categories","summary":"","title":"Tutorial","type":"categories"},{"content":"","date":"29 October 2025","externalUrl":null,"permalink":"/en/tags/xdp/","section":"Tags","summary":"","title":"Xdp","type":"tags"},{"content":"","date":"29 October 2025","externalUrl":null,"permalink":"/series/apprenons-xdp-avec-aya/","section":"Series","summary":"","title":"Apprenons XDP Avec Aya","type":"series"},{"content":"We saw what an XDP program is in part one: it can be a way to filter a network stream.\nIn this part, I will take you on a brief tour of the different headers and show you how filtering can be done. We will see how to redevelop xdp-filter with the Rust Aya framework.\nFollow the guide!\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rlab\rI assume you are already in an environment for developing with Aya. If not, you can use the Killercoda lab:\nLet\u0026rsquo;s build an XDP hello world program # Let\u0026rsquo;s recreate the development environment # As we saw in the previous section, I suggest installing namespaces:\ngit clone https://github.com/littlejo/eunomia.dev cd eunomia.dev/docs/tutorials/42-xdp-loadbalancer/ ./setup.sh Let\u0026rsquo;s recall what we created:\nLet\u0026rsquo;s create the ‚Äúhello world‚Äù program # As we did with xdp-filter, we will install the XDP program on veth0.\nLet\u0026rsquo;s generate the Aya program:\ncargo generate --name browser-xdp \\ -d program_type=xdp \\ -d default_iface=veth0 \\ https://github.com/aya-rs/aya-template Let\u0026rsquo;s build and install the ‚Äúhello world‚Äù program:\ncd browser-xdp/ cargo run On another terminal, let\u0026rsquo;s test the program:\nip netns exec lb ping -c 2 10.0.0.1 On the cargo run terminal, we can clearly see two packets:\n[INFO browser_xdp] received a packet [INFO browser_xdp] received a packet So every time the interface receives a packet, the XDP program is launched.\nNow we\u0026rsquo;ll see how to stop a packet and what type of packet we\u0026rsquo;re dealing with.\nThe basics of creating an XDP program # XDP actions # Let\u0026rsquo;s first look at the code generated by cargo.\nThe most important file is this one: browser-xdp-ebpf/src/main.rs, i.e., the kernel-side code.\nOverall, the code looks like the code generated for other types of eBPF programs such as Tracepoints:\n#[xdp] pub fn browser_xdp(ctx: XdpContext) -\u0026gt; u32 { match try_browser_xdp(ctx) { Ok(ret) =\u0026gt; ret, Err(_) =\u0026gt; xdp_action::XDP_ABORTED, } } fn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { info!(\u0026amp;ctx, \u0026#34;received a packet\u0026#34;); Ok(xdp_action::XDP_PASS) } However, there is one small difference: xdp_action::*.\nThis determines what the packet does once it has finished traversing the eBPF program.\nThere are five different actions:\nXDP_ABORTED: Stops the packet with an error XDP_DROP: Stops the packet silently XDP_PASS: Lets the packet continue through the network stack. XDP_REDIRECT: Redirects the packet to another interface or to an AF_XDP socket attached to an interface. XDP_TX: Redirects the packet to the same interface In this article, we will only use XDP_PASS and XDP_DROP.\nThe XDP context and its methods # As with all other eBPF programs, to go beyond hello world, you need to understand how to work with the context.\nLet\u0026rsquo;s take a look at the documentation:\nUnlike previous types of programs where only one method was used, there are four different methods for XDP:\ndata() returns the memory address of the start of the network packet. data_end() returns the memory address of the end of the network packet. metadata() returns the memory address of the start of the XDP metadata linked to the Linux kernel or driver. metadata_end() returns the memory address of the end of the metadata. In the same way as data_end(), In this article, we will only use the data() and data_end() methods to retrieve the different headers.\nHow to retrieve the headers? # Let\u0026rsquo;s recall the following diagram: data() is located at the beginning of the ethHdr header data_end() is located at the end of the payload How do we retrieve the Ethernet header (ethHdr)? It is located at the very beginning of the packet.\nlet ethhdr = ctx.data(); To retrieve the next header, simply add the length of the Ethernet header. In Rust pseudo-code, this would look like:\nlet ipv4hdr = ctx.data() + sizeof(ethhdr); Etc.\nLet\u0026rsquo;s focus on the Ethernet header. How can we retrieve its elements? ctx.data() is of type usize. This is a natural integer that represents a memory address. We therefore need to retrieve its content. How can we do this?\nIn the same way that *const u8 represents a pointer to a character string, we must do the same for the Ethernet header.\nWe must therefore convert it into a structure that represents the Ethernet frame header. There are several ways to do this, such as looking at the C code and converting it to Rust, which is a good exercise but a little tedious. Fortunately, since Rust is now well established in the eBPF ecosystem, there is already a Rust crate that has done the work for us: network-types.\nTo retrieve this crate, we will modify the browser-xdp-ebpf/Cargo.toml file and add the following to the dependencies section:\nnetwork-types = \u0026#34;0.1.0\u0026#34; We will then be able to include it in the main code (browser-xdp-ebpf/src/main.rs):\nuse network_types::eth::EthHdr; [...] let ethhdr = ctx.data() as *const EthHdr; Now that we have retrieved the Ethernet header structure, we can retrieve the various elements the header consists of:\nDST MAC: the destination MAC address SRC MAC: the source MAC address ETHERTYPE: determines the upper-layer protocol (such as IPv4, IPv6, or Arp, to name the most well-known). How can this be done with Aya? Let\u0026rsquo;s review the documentation:\nSo to retrieve the destination address, simply code:\nlet dst_addr = unsafe { (*ethhdr).dst_addr}; info!(\u0026amp;ctx, \u0026#34;dst_addr {:mac} \u0026#34;, dst_addr); We have to use unsafe because we are dereferencing a raw pointer.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Note that the info! macro allows us to convert 6-byte arrays into a MAC addresses. If you prefer uppercase notation, just use :MAC. Now let\u0026rsquo;s try it. Here is the modified main code:\nuse network_types::eth::EthHdr; fn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let ethhdr = ctx.data() as *const EthHdr; let dst_addr = unsafe { (*ethhdr).dst_addr}; info!(\u0026amp;ctx, \u0026#34;dst_addr {:mac} \u0026#34;, dst_addr); info!(\u0026amp;ctx, \u0026#34;received a packet\u0026#34;); Ok(xdp_action::XDP_PASS) } Let\u0026rsquo;s build the program:\ncargo build The compilation works.\nLet\u0026rsquo;s install it in the kernel:\ncargo run We then get the following error:\nError: the BPF_PROG_LOAD syscall failed. Verifier output: 0: R1=ctx() R10=fp0 ; unsafe { (*self.ctx).data as usize } @ xdp.rs:16 0: (61) r1 = *(u32 *)(r1 +0) ; R1_w=pkt(r=0) ; let dst_addr = unsafe { (*ethhdr).dst_addr}; @ main.rs:20 1: (71) r0 = *(u8 *)(r1 +1) invalid access to packet, off=1 size=1, R1(id=0,off=1,r=0) R1 offset is outside of the packet verification time 65 usec stack depth 0 processed 2 insns (limit 1000000) max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0 Caused by: Permission denied (os error 13) The verifier doesn\u0026rsquo;t really like this part of the code:\nlet ethhdr = ctx.data() as *const EthHdr; \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e When we try to install an eBPF program in the Linux kernel, there is a Linux program (the verifier) that checks the code to prevent us from breaking the security of the Linux kernel. The important part of the error is:\ninvalid access to packet, R1 offset is outside of the packet Not very clear. Let\u0026rsquo;s try to explain it better. When we try let ethhdr = ctx.data() as *const EthHdr;, there is memory access. The verifier requires us to prove that this access is always within the packet (between data() and data_end()).\nWe therefore need to perform a check to reassure it before this access:\nif ctx.data() + EthHdr::LEN \u0026gt; ctx.data_end() { return Ok(xdp_action::XDP_PASS); } This can be translated as: if the access is not at the packet level, the XDP program does not process the packet: it lets it continue on its way in the Linux kernel network stack.\nOtherwise, we can convert it to EthHdr:\nlet ethhdr = ctx.data() as *const EthHdr; Here is the complete code for the main function:\nfn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let start = ctx.data() ; let end = ctx.data_end() ; if start + EthHdr::LEN \u0026gt; end { //Check for the verifier return Ok(xdp_action::XDP_PASS); } let ethhdr = start as *const EthHdr; let dst_addr = unsafe { (*ethhdr).dst_addr}; info!(\u0026amp;ctx, \u0026#34;dst_addr {:mac} \u0026#34;, dst_addr); info!(\u0026amp;ctx, \u0026#34;received a packet\u0026#34;); Ok(xdp_action::XDP_PASS) } Let\u0026rsquo;s check that it works:\ncargo run Let\u0026rsquo;s run some pings. We successfully retrieve the MAC address:\n[INFO browser_xdp] dst_addr de:ad:be:ef:00:01 [INFO browser_xdp] received a packet [INFO browser_xdp] dst_addr de:ad:be:ef:00:01 [INFO browser_xdp] received a packet Now that we have successfully retrieved the ethHdr header, how do we retrieve the other headers? Simply add the lengths of the preceding headers.\nObviously, we will use very similar methods for all headers. It would be wise to create a function. Here it is:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 use core::mem::size_of; #[inline(always)] fn ptr_at\u0026lt;T\u0026gt;(ctx: \u0026amp;XdpContext, offset: usize) -\u0026gt; Result\u0026lt;*const T, u16\u0026gt; { let start = ctx.data(); let end = ctx.data_end(); let len = size_of::\u0026lt;T\u0026gt;(); if start + offset + len \u0026gt; end { return Err(1); } Ok((start + offset) as *const T) } A few notes on creating this function:\n(L3) We inline the function for performance reasons (L4) \u0026lt;T\u0026gt;: allows us to define a generic function that doesn\u0026rsquo;t depend on a specific structure the offset lets us to navigate from header to header (offset = 0 for ethHdr) (L7) We had to change how the structure length is calculated, using size_of, to make it work properly. Then the main code becomes:\nfn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0)?; let dst_addr = unsafe { (*ethhdr).dst_addr}; info!(\u0026amp;ctx, \u0026#34;dst_addr {:mac} \u0026#34;, dst_addr); info!(\u0026amp;ctx, \u0026#34;received a packet\u0026#34;); Ok(xdp_action::XDP_PASS) } Now that we have created the function that allows us to traverse the different headers, let\u0026rsquo;s see how we can block or allow packets based on network headers.\nGuided tour of the different headers # Level 1: Network access # What we can filter # We already saw this for the first level: we can retrieve the source MAC address, the destination MAC address, and the EtherType. This allows us to filter based on the MAC address\nSo we\u0026rsquo;ll use the function we created earlier, ptr_at():\nlet ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0)?; To retrieve the MAC addresses and display them:\nlet dst_addr = unsafe { (*ethhdr).dst_addr }; let src_addr = unsafe { (*ethhdr).src_addr }; info!(\u0026amp;ctx, \u0026#34;src: {:mac} =\u0026gt; dst: {:mac}\u0026#34;, src_addr, dst_addr); Let\u0026rsquo;s test it:\ncargo run And ping. Let\u0026rsquo;s look at the result:\n[INFO browser_xdp] src: de:ad:be:ef:00:10 =\u0026gt; dst: de:ad:be:ef:00:01 [INFO browser_xdp] src: de:ad:be:ef:00:10 =\u0026gt; dst: de:ad:be:ef:00:01 To write cleaner code, we can create a function:\n#[inline(always)] fn display_ethhdr(ctx: \u0026amp;XdpContext, ethhdr: *const EthHdr) { let dst_addr = unsafe { (*ethhdr).dst_addr }; let src_addr = unsafe { (*ethhdr).src_addr }; let ethertype = unsafe { (*ethhdr).ether_type }; info!(ctx, \u0026#34;EthHdr: src: {:mac} =\u0026gt; dst: {:mac} ({})\u0026#34;, src_addr, dst_addr, ethertype); } Let\u0026rsquo;s filter # So, to filter a MAC address, we can do the following:\nlet mac: [u8; 6] = [0xde, 0xad, 0xbe, 0xef, 0x00, 0x10]; //de:ad:be:ef:00:10 if mac == src_addr { info!(\u0026amp;ctx, \u0026#34;drop\u0026#34;); return Ok(xdp_action::XDP_DROP); } \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e In a ‚Äúreal‚Äù project, we wouldn\u0026rsquo;t hard-code this. We would create an eBPF map that we would fill in the user space with a list of MAC addresses to filter. We have already seen a similar case in the section dedicated to eBPF maps in the introduction. Let\u0026rsquo;s test it:\ncargo run Let\u0026rsquo;s ping from lb: it no longer pings. Let\u0026rsquo;s look at the result in Aya:\n[INFO browser_xdp] drop [INFO browser_xdp] drop The program correctly identifies the packet and stops it.\nLet\u0026rsquo;s ping from the h2 namespace:\nip netns exec h2 ping -c 2 10.0.0.1 The ping goes through:\n[INFO browser_xdp] received ethhdr packet src: de:ad:be:ef:00:02 =\u0026gt; dst: de:ad:be:ef:00:01 [INFO browser_xdp] received ethhdr packet src: de:ad:be:ef:00:02 =\u0026gt; dst: de:ad:be:ef:00:01 To make it more like xdp-filter, we can create this function that allows us to distinguish whether we want to block the source or the destination:\nenum Mode { Src, Dst, } #[inline(always)] fn drop_mac(ethhdr: *const EthHdr, mac: [u8; 6], mode: Mode) -\u0026gt; bool { let addr = match mode { Mode::Src =\u0026gt; unsafe {(*ethhdr).src_addr}, Mode::Dst =\u0026gt; unsafe {(*ethhdr).dst_addr}, }; mac == addr } In the main code, this gives us:\nfn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0)?; let mac: [u8; 6] = [0xde, 0xad, 0xbe, 0xef, 0x00, 0x10]; //de:ad:be:ef:00:10 display_ethhdr(\u0026amp;ctx, ethhdr); if drop_mac(ethhdr, mac, Mode::Src) { return Ok(xdp_action::XDP_DROP); } Ok(xdp_action::XDP_DROP); } Level up # The Ethertype determines the protocol of the packet in the upper layer.\nTo retrieve it, we can use the following code:\nlet ethertype = unsafe {(*ethhdr).ether_type} ; But there is a cleaner way with the ether_type() method, which checks whether the protocol number actually exists: Instead of memorizing protocol numbers, the network-types crate simplifies things with the EtherType type:\nThis allows us to filter in the following way:\nmatch unsafe { (*ethhdr).ether_type() } { Ok(EtherType::Ipv4) =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } Flows other than IPv4 (e.g., IPv6, Arp) pass through directly and are no longer analyzed.\nLevel 2: Internet # What we can filter # So let\u0026rsquo;s assume that we only want to analyze IPv4 traffic.\nAs with Ethernet, let\u0026rsquo;s look at what data we can retrieve with the IPv4 header: For clarity, the header is shown on several lines. There is significantly more information to retrieve. The ones we will use for this article are:\nPROTOCOL: the upper-level protocol (TCP or UDP, for example) SOURCE ADDRESS: the source IP address DESTINATION ADDRESS: the destination IP address If you find the IPv4 header complex, this is one of the reasons IPv6 was created: its header is a little simpler, making packet processing easier. In Rust, we can retrieve these headers: To retrieve the IPv4 headers, simply shift the pointer to the length of the Ethernet header structure using the function we created:\nlet ipv4hdr: *const Ipv4Hdr = ptr_at(\u0026amp;ctx, EthHdr::LEN)? ; In the same way as for the lower layer, we can create a function:\n#[inline(always)] fn display_iphdr(ctx: \u0026amp;XdpContext, iphdr: *const Ipv4Hdr) { let dst_addr = unsafe { (*iphdr).dst_addr }; let src_addr = unsafe { (*iphdr).src_addr }; let proto = unsafe { (*iphdr).proto }; info!(ctx, \u0026#34;Ipv4Hdr: src: {:i} =\u0026gt; dst: {:i} ({})\u0026#34;, src_addr, dst_addr, proto as u8); } \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e As with MAC addresses, the info! macro simplifies things by converting a 4-byte array into IPv4 notation with :i. Let\u0026rsquo;s test the following code:\nuse network_types::{eth::{EthHdr,EtherType}, ip::Ipv4Hdr, }; fn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0)?; match unsafe { (*ethhdr).ether_type() } { Ok(EtherType::Ipv4) =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } let ipv4hdr: *const Ipv4Hdr = ptr_at(\u0026amp;ctx, EthHdr::LEN)? ; let mac: [u8; 6] = [0xde, 0xad, 0xbe, 0xef, 0x00, 0x10]; //de:ad:be:ef:00:10 //display_ethhdr(\u0026amp;ctx, ethhdr); display_iphdr(\u0026amp;ctx, ipv4hdr); Ok(xdp_action::XDP_PASS) } Let\u0026rsquo;s ping again:\nip netns exec lb ping -c 2 10.0.0.1 On the cargo run side, this gives:\n[INFO browser_xdp] Ipv4Hdr: src: 10.0.0.10 =\u0026gt; dst: 10.0.0.1 (1) [INFO browser_xdp] Ipv4Hdr: src: 10.0.0.10 =\u0026gt; dst: 10.0.0.1 (1) In the same way as with the Mac address, to prevent the lb IP, we can use this function:\n#[inline(always)] fn drop_ip(iphdr: *const Ipv4Hdr, ip: [u8; 4], mode: Mode) -\u0026gt; bool { let addr = match mode { Mode::Src =\u0026gt; unsafe {(*iphdr).src_addr}, Mode::Dst =\u0026gt; unsafe {(*iphdr).dst_addr}, }; ip == addr } The main code then gives:\nfn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0)?; match unsafe { (*ethhdr).ether_type() } { Ok(EtherType::Ipv4) =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } let ipv4hdr: *const Ipv4Hdr = ptr_at(\u0026amp;ctx, EthHdr::LEN)? ; display_iphdr(\u0026amp;ctx, ipv4hdr); if drop_ip(ipv4hdr, [10, 0, 0, 10], Mode::Src) { return Ok(xdp_action::XDP_DROP); } Ok(xdp_action::XDP_PASS) } The ping no longer works:\nip netns exec lb ping -c 2 10.0.0.1 [INFO browser_xdp] Ipv4Hdr: src: 10.0.0.10 =\u0026gt; dst: 10.0.0.1 (1) [INFO browser_xdp] Ipv4Hdr: src: 10.0.0.10 =\u0026gt; dst: 10.0.0.1 (1) The program correctly identifies the packet and stops it.\nLevel up # To go to the next level, you need to know which protocol you want to look at. To do this, use the proto option. It is of type IPProto, which is an enumeration:\nWe will look at UDP at the end of the article. The principle is the same as for Ethertype:\nmatch unsafe { (*ipv4hdr).proto } { IpProto::Udp =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } It is easy to filter if you want to block certain protocols.\nLevel 3: Transport # What we can filter # For UDP, we can retrieve the header in this way:\nlet udphdr: *const UdpHdr = ptr_at(\u0026amp;ctx, EthHdr::LEN + Ipv4Hdr::LEN)? ; Now let\u0026rsquo;s look at the UDP segment header:\nThe most interesting part to filter are the ports.\nIn Rust: Ports are not integers but arrays of 2 bytes. This is not practical. Fortunately, there are the following methods:\nWe can filter at the UDP port level:\n#[inline(always)] fn drop_udp_port(udphdr: *const UdpHdr, port: u16, mode: Mode) -\u0026gt; bool { let packet_port = match mode { Mode::Src =\u0026gt; unsafe {(*udphdr).src_port()}, Mode::Dst =\u0026gt; unsafe {(*udphdr).dst_port()}, }; port == packet_port } Let\u0026rsquo;s test the following code:\nuse network_types::{eth::{EthHdr,EtherType}, ip::{Ipv4Hdr,IpProto}, udp::UdpHdr, }; fn try_browser_xdp(ctx: XdpContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let ethhdr: *const EthHdr = ptr_at(\u0026amp;ctx, 0)?; match unsafe { (*ethhdr).ether_type() } { Ok(EtherType::Ipv4) =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } let ipv4hdr: *const Ipv4Hdr = ptr_at(\u0026amp;ctx, EthHdr::LEN)? ; match unsafe { (*ipv4hdr).proto } { IpProto::Udp =\u0026gt; {} _ =\u0026gt; return Ok(xdp_action::XDP_PASS), } let udphdr: *const UdpHdr = ptr_at(\u0026amp;ctx, EthHdr::LEN + Ipv4Hdr::LEN)? ; display_udphdr(\u0026amp;ctx, udphdr); if drop_udp_port(udphdr, 8888, Mode::Dst){ return Ok(xdp_action::XDP_DROP); } Ok(xdp_action::XDP_PASS) } Let\u0026rsquo;s install the XDP program:\ncargo run Let\u0026rsquo;s create a UDP server with netcat:\nnc -u 0.0.0.0 -l 8000 Now let\u0026rsquo;s create a UDP client:\nip netns exec lb netcat -u 10.0.0.1 8000 coucou This command opens a UDP client and sends the message coucou.\nOn the UDP server side, we can clearly see:\ncoucou But above all, we can clearly see on the cargo run side:\n[INFO browser_xdp] UdpHdr: src: 44024 =\u0026gt; dst: 8000 Now let\u0026rsquo;s test with a UDP server on port 8888:\nnc -u 0.0.0.0 -l 8888 Now let\u0026rsquo;s create a UDP client:\nip netns exec lb netcat -u 10.0.0.1 8888 coucou Nothing is displayed on the server, which is normal because the XDP program has blocked it:\n[INFO browser_xdp] UdpHdr: src: 39540 =\u0026gt; dst: 8888 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rThe functions drop_mac(), drop_ip(), and drop_udp_port() are very similar, and it is entirely possible in Rust to make them generic so that there is only one. The same applies to display_ethdr(), display_iphdr(), and display_udphdr(). You can see the more generic code in the crate dedicated to the blog here and there. Level 4: Application # The crate network-types does not help retrieve application protocol headers. By knowing the port from the previous level, you can easily filter the application. If you filter port 53, you will filter DNS, for example. But if you want to filter a specific request, that\u0026rsquo;s another matter.\nIt is possible to go higher. But application headers can be:\ntoo large for the stack (limited to 512 bytes), requiring the use of eBPF maps; encrypted, as with HTTPS or SSH, making analysis impossible with XDP. This episode is now over! We have seen the basics of creating a firewall like xdp-filter.\nHowever, we haven\u0026rsquo;t seen how to make it a little smarter, for example by avoiding DDoS attacks.\nThat\u0026rsquo;s good timing! In the next episode, we will create an XDP program that will mitigate denial-of-service attacks.\n","date":"29 October 2025","externalUrl":null,"permalink":"/en/ebpf-another-type/xdp/example-1/","section":"Ebpf-Another-Types","summary":"Let‚Äôs see how to block traffic based on various criteria (MAC address, IP, protocol, port, etc.).","title":"Let's Build a Tiny Firewall with XDP","type":"ebpf-another-type"},{"content":"","date":"27 October 2025","externalUrl":null,"permalink":"/tetragon/","section":"Tetragons","summary":"","title":"Tetragons","type":"tetragon"},{"content":"","date":"16 October 2025","externalUrl":null,"permalink":"/en/categories/introduction/","section":"Categories","summary":"","title":"Introduction","type":"categories"},{"content":"","date":"16 October 2025","externalUrl":null,"permalink":"/en/series/lets-learn-another-ebpf-program/","section":"Series","summary":"","title":"Let‚Äôs Learn Another EBPF Program","type":"series"},{"content":"I\u0026rsquo;m getting started with eBPF programming with Aya. The idea behind this series of articles is to learn about a new type of eBPF program and experiment with it using the Rust Aya framework.\nToday, we\u0026rsquo;re going to dive into XDP: eBPF programs capable of filtering or redirecting network packets faster than lightspeed.\nYou\u0026rsquo;ll see that this can be very useful for building an effective firewall that can counter denial-of-service attacks, but also for load balancing millions of network packets.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e If you\u0026rsquo;re not familiar with eBPF, I recommend reading the first two parts of my series Getting Started with eBPF with Aya. This covers the basics and will help you understand the rest of the article. What is XDP? # As you might guess, XDP is a type of network-oriented eBPF program. XDP stands for eXpress Data Path.\nTo fully understand the meaning of this acronym, you need to know how a network packet travels from the network card to an application such as a web server. Traditionally, it follows this path in Linux: XDP operates directly at the driver level, allowing it to respond more quickly than an application firewall. This speed is particularly crucial against distributed denial-of-service (DDoS) attacks.\nTo be precise, XDP can work in three different places depending on the network card support:\nAt the network card firmware level (offloaded mode), but only a few network card models support this At the network driver level (native mode), which is the most common case for standard servers At the kernel network stack level (generic mode), allowing testing on any computer (such as your laptop) Please refer to this page for more details.\nHowever, since XDP operates at a very low network layer, the output data retrieved is raw and untransformed by the Linux network layer, which makes it more difficult to manage for certain tasks (such as monitoring TCP connections and retransmissions).\nFor more information, please refer to the official documentation:\nWe will now discuss the context in which this technology was created.\nOrigin story # The Ancestors of XDP # We didn\u0026rsquo;t wait for XDP to filter or redirect packets in the Linux kernel.\nThe first firewall was implemented in Linux 1.1 in 1994. It was called ipfw and was configured using the ipfwadm command line. It was inspired by the firewall created for FreeBSD. It was replaced by ipchains in Linux 2.2 in 1999, which was more comprehensive and better suited to the kernel\u0026rsquo;s new network layer.\nNetfilter: the immortal # For version 2.4 (2001) of the Linux kernel, a brand new firewall was created: Netfilter and its command line iptables, which every Linux network engineer is still very familiar with today. Netfilter processes network packets at various points in the Linux network stack, well after the driver.\nSince that version, Netfilter has evolved to handle new features such as IPv6 and cgroups.\n\u003c?xml version=\"1.0\" encoding=\"iso-8859-1\"?\u003e\rYou\u0026rsquo;ve probably heard of nftables. It\u0026rsquo;s just a command line that allows you to update rules more efficiently than iptables. To do this, we had to modify the Linux kernel\u0026rsquo;s ‚Äúapi‚Äù. But the engine behind it remains netfilter. Despite its qualities, Linux has never had good reputation for network hardware. For example, most professional switches and routers run on other operating systems. Could XDP reverse this trend?\nXDP: the successor? # In 2014, eBPF was released. But it was two years later, with version 4.8 of the Linux kernel, that XDP finally became usable. It was developed jointly by Brenden Blanco (PLUMgrid Inc) and Tom Herbert (Facebook).\nUnlike other types of eBPF programs, XDP cannot be used with eBPF alone. A hook is placed at the network driver level, allowing the eBPF program to be started. This meant that XDP-compatible drivers had to be developed for it to work. The frameworks at the time also had to be able to handle this new type of program. So, as early as July 2016, even before the official release of the XDP-compatible Linux kernel, it was possible to create XDP programs with BCC:\nSince then, XDP has continued to evolve, notably:\nIn 2018, the appearance of the AF_XDP (Address Family Express Data Path) socket, which allows XDP to be used from user space without going through the network stack. In 2022, the management of large packets (such as Jumbo packets, GRO, or BIG TCP) with XDP Fragment. Today, XDP is considered stable and usable in production.\n\u003c?xml version=\"1.0\" encoding=\"iso-8859-1\"?\u003e\rXDP cannot be considered a replacement for Netfilter. For example, recreating a command equivalent to iptables with XDP would be a colossal task. The bpfilter project aims to translate iptables rules into eBPF programs and does not only use XDP. Finally, here is a brief timeline of the history of XDP:\nNow that XDP is considered stable, a natural question arises: which projects use it?\nWhich projects use XDP? # To challenge the common misconception that ‚ÄúeBPF is only used by three big companies‚Äù, I did a little research on tools that actually use XDP and that you may be using without even knowing it\u0026hellip;\nKatran: Facebook\u0026rsquo;s load balancer # The Katran project is developing a layer 4 XDP load balancer. It is used by Facebook and also by Netflix. In addition, Facebook has created an XDP-based firewall to prevent DDoS attacks.\nCilium: Kubernetes external services # The Cilium project provides a CNI plugin for Kubernetes and can also replace kube-proxy. Under some requirements, Cilium can enable XDP for NodePort, LoadBalancer, and externalIPs services, thereby improving performance.\nCloudflare: preventing DDoS # In 2018, Cloudflare published an article explaining how it reduced DDoS with XDP. Recently, Cloudflare announced that it had mitigated an 22.2 Tbit/s DDoS attack\nAnd many others # There are certainly other lesser-known projects that use XDP, such as Surricata.\nWe will now look at the main difficulties we will encounter when we start creating an XDP program.\nHow to start your XDP program? # For many eBPF programs, the first challenge is finding the hook point. For XDP, it\u0026rsquo;s relatively simple: you just need to know the name of the network interface where you want to hook the XDP program.\nThe real challenge lies in creating a network environment. The traditional solution is to create VMs (with Vagrant, for example) and have them communicate with each other. This solution is entirely possible for XDP, but it seems a bit cumbersome to set up (for labs, for example).\nFor the rest of this guide, I suggest a much lighter solution: using Linux network namespaces. The same mechanism that is used for Docker.\nCreating an environment for XDP # \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rlab\rI\u0026rsquo;m assuming you\u0026rsquo;re using Linux for the demonstration. If not, you can use the Killercoda lab:\nEnvironment creation script # We could create a tutorial for creating network namespaces, but since this is not the main topic and there are already scripts that can be easily found online, I suggest the following script:\ngit clone https://github.com/littlejo/eunomia.dev cd eunomia.dev/docs/tutorials/42-xdp-loadbalancer/ To create the network namespaces:\n./setup.sh \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rI had to install the net-tools package on Debian to access the arp command, which is used in the script to perform functionality checks. This script will create three namespaces that can communicate with each other (lb, h2, and h3) via a bridge (br0):\nip netns list lb (id: 23) h3 (id: 18) h2 (id: 15) To see the IPs of a namespace, you can type:\nip netns exec lb ip -brief -family inet addr lo UNKNOWN 127.0.0.1/8 veth6@if98 UP 10.0.0.10/24 Think of these namespaces as containers, except that inside the namespaces you have all the host commands! These namespaces can be represented as follows: Verifying proper functioning # Although the script already performs the necessary checks, we will still do a few ourselves to show the testing possibilities available.\nWe can ping the IP address of a namespace from the host:\nping -c 3 10.0.0.10 The ping is successful:\nPING 10.0.0.10 (10.0.0.10) 56(84) bytes of data. 64 bytes from 10.0.0.10: icmp_seq=1 ttl=64 time=0.060 ms 64 bytes from 10.0.0.10: icmp_seq=2 ttl=64 time=0.124 ms 64 bytes from 10.0.0.10: icmp_seq=3 ttl=64 time=0.122 ms --- 10.0.0.10 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2053ms rtt min/avg/max/mdev = 0.060/0.102/0.124/0.029 ms To test the connection to a web server in a namespace, I can do it this way in the h2 namespace:\nip netns exec h2 python3 -m http.server 8080 If I want to test that I can connect to the web server from lb, I type on another terminal:\nip netns exec lb curl http://10.0.0.2:8080 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e This will allow us to create a small load balancer in the lb namespace and redirect it to the h2 and h3 namespaces. This provides us a complete test environment for the rest of the series.\nCleaning up # To remove the namespaces and network interfaces, you can restart the machine or just type:\n./teardown.sh My first XDP program # Now let\u0026rsquo;s create a small XDP program in the environment we just created.\nxdp-tools is a suite of tools for creating and debugging XDP programs.\nTo install it on Debian 13, I installed the package:\napt install xdp-tools If you\u0026rsquo;re having trouble installing it, I\u0026rsquo;ve created a container for it (littlejo/xdp-tools). Everything is here. We will use xdp-filter, which lets us to create xdp programs that filter packets.\nWe will install an xdp program on the veth0 interface:\nxdp-filter load veth0 The load option lets you to load the XDP program in the Linux kernel.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e To unload it, simply use the unload option: xdp-filter unload veth0. The following diagram shows what we have done:\nFrom another terminal, you can verify that the ping is working:\nip netns exec lb ping -c 3 10.0.0.1 You can also see it:\nxdp-filter status You can see that xdp has successfully passed 3 packets:\nCURRENT XDP-FILTER STATUS: Aggregate per-action statistics: XDP_ABORTED 0 pkts 0 KiB XDP_DROP 0 pkts 0 KiB XDP_PASS 3 pkts 0 KiB Loaded on interfaces: Enabled features xdpfilt_alw_all veth0 (native mode) tcp,udp,ipv6,ipv4,ethernet,allow Filtered ports: Mode Hit counter Filtered IP addresses: Mode Hit counter Filtered MAC addresses: Mode Hit counter To filter the lb IP:\nxdp-filter ip -m src 10.0.0.10 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Created by potrace 1.10, written by Peter Selinger 2001-2011 You can delete the rule with the -r option: xdp-filter ip -m src -r 10.10.0.10 With this example, it is important to understand that XDP programs only operate on the arrival of the interface (ingress). Thus, the source IP is 10.0.0.10 and the destination IP is always 10.0.0.1.\nIf we wanted to prevent lb from pinging by creating an XDP program on the twin interface veth1, we would have had to run the following command:\nxdp-filter ip -m dst 10.0.0.10 This is because the source IP is now the IP of the veth0 interface and the destination IP is the IP where the echo reply is sent, i.e. 10.0.0.10.\nCheck that the ping no longer works:\nip netns exec lb ping -c 3 10.0.0.1 But you can still ping from another namespace:\nip netns exec h2 ping -c 3 10.0.0.1 We can see this with xdp-filter status:\nCURRENT XDP-FILTER STATUS: Aggregate per-action statistics: XDP_ABORTED 0 pkts 0 KiB XDP_DROP 5 pkts 0 KiB XDP_PASS 16 pkts 1 KiB Loaded on interfaces: Enabled features xdpfilt_alw_all veth0 (native mode) tcp,udp,ipv6,ipv4,ethernet,allow Filtered ports: Mode Hit counter Filtered IP addresses: Mode Hit counter 10.0.0.10 src 5 Filtered MAC addresses: Mode Hit counter \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rIn the next episode, we will show how to recreate the xdp-filter command with Aya. Anatomy of a network packet # Now that we have successfully created XDP programs with xdp-filter, another difficulty that will quickly arise when we try to actually develop an XDP program is network knowledge. As I wrote at the beginning of the article, with XDP we retrieve raw data from the packet, so we need to be able to analyze it by understanding how a network packet is structured.\nA network packet has two parts:\nThe messenger (headers): IP addresses, MAC addresses, the protocol, the port used, etc. This is the part that interests network engineers. The message content (payload): the part that matters users. How are these headers structured? By the different layers of the TCP/IP model. Does that ring a bell? I had (almost) forgotten everything about it myself.\nTCP/IP model # The TCP/IP model has four layers:\nNetwork access: Wired (Ethernet) or wireless (Wi-Fi) Internet: IPv4, IPv6, ICMP, etc. Transport: TCP and UDP Application: HTTP, SSH, DNS, etc. XDP kicks in as soon as layer 1 is received. The packet encapsulates the different layers. The packet will therefore be structured as follows:\nThe network access header (we will only see the Ethernet header: ethernet header (ethhdr)), which will indicate whether we are using IPv4 or IPv6 The Internet header (e.g., Internet Protocol Header (iphdr)) indicates whether the protocol is UDP, TCP, or ICMP. The transport header (e.g., Transmission Control Protocol Header (tcphdr)) indicates which port is being used, for example. The application header is much less standard, so we won\u0026rsquo;t go into that here. Here are the different headers for a DNS request, for example:\nSo, to create an XDP program, you need to go through the different headers in the packet and retrieve a specific element from the header.\nThe UDP header is composed of the following elements:\nSource port: the port from which the packet is sent (a variable port defined by the application) Destination port: the port to which the packet should be sent (for example, port 53 for DNS) Length: total length of the UDP segment (header + payload) Checksum: verification of the packet\u0026rsquo;s integrity. Once we have retrieved the target element, we can decide, for example, whether to block access to the packet.\nIn this episode, we looked at the basics of XDP: what it is used for, its history, who uses it, and the prerequisites for starting an XDP program.\nDoes all this seem abstract to you? We will now move on to the practical side in the next episode: we will create a small XDP firewall with Aya!\n","date":"16 October 2025","externalUrl":null,"permalink":"/en/ebpf-another-type/xdp/intro/","section":"Ebpf-Another-Types","summary":"An introduction to XDP with Aya","title":"XDP: The Ultra-Fast Firewall Inside Linux","type":"ebpf-another-type"},{"content":"","date":"16 October 2025","externalUrl":null,"permalink":"/series/apprenons-un-autre-programme-ebpf/","section":"Series","summary":"","title":"Apprenons Un Autre Programme EBPF","type":"series"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/series/apprenons-uprobe-avec-ebpf-et-aya/","section":"Series","summary":"","title":"Apprenons UProbe Avec EBPF Et Aya","type":"series"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/en/series/getting-started-with-ebpf-uprobes-in-aya/","section":"Series","summary":"","title":"Getting Started With EBPF UProbes in Aya","type":"series"},{"content":"We saw what a uProbe-type program was in part one: a way to profile a program.\nThe purpose of this article is therefore to look at the time it takes for a function in a program written in Rust to execute.\nThis will also allow us to see the difference with a program written in Go for retrieving the attachment points of uProbe-type eBPF programs.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rI assume you are already in an environment for developing with Aya and that you have installed bpftrace. If not, you can use the Killercoda lab:\nIntroduction to the Rust program for testing uProbes # Calculating the decimal places of ùõë # Before creating the eBPF program, we will first retrieve a small program in Rust.\nTo make it a little more inventive than a hello world program, I chose a program that displays an estimate of the number ùõë. By varying the number of decimal places, we can easily change the execution time of the function.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e The number ùõë (Pi) is a number that can be used, for example, to calculate the circumference of a circle. This number has the particularity of having an infinite number of decimal places, which makes calculating them complex. In 2022, the first 100 trillion decimal places were determined. Here are the commands to retrieve and compile it:\ngit clone https://github.com/littlejo/pi_digits_rust cd pi_digits_rust cargo build To test the generated binary, you can then run the following command:\n./target/debug/pi_digits_pure_rust 10 #To get 10 decimal places of Pi Which responds:\n3.1415926536 We have 10 decimal places.\nThe purpose of this article is to retrieve the time taken by the function dedicated to calculating the decimal places of Pi (pi_times_10n_rounded()).\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rYou can test another program compiled as C/C++, Go, Zig, or V of your choice for comparison. How are we going to proceed? # To do this, we will use:\na uProbe-type program to measure the time at the start of the function a uRetProbe-type program to measure the time at the end of the function By subtracting the start time from the end time, we will find the total time required to calculate the decimal places of ùõë.\nBefore that, we first need to find the attachment point for this Rust-written program for these two eBPF programs.\nFinding the attachment point # Now that we have created and compiled the small program, we need to figure out how to trigger the uProbe or uRetProbe eBPF program. When using cargo generate for the aya repo, we need to answer two questions: where is the binary name located and which function is being observed. Let\u0026rsquo;s take a closer look.\nName of the binary # ü§∑ Target to attach the (u|uret)probe? (e.g libc): To ensure the portability of the eBPF program, you must answer with the absolute path of the binary. For example, I created it here: /home/cloud_user/pi_digits/target/debug/pi_digits_pure_rust.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e As the path is a bit long, for the rest of this article, the name of the binary will be given as a relative path for better readability: ./pi_digits_pure_rust) Function name # ü§∑ Function name to attach the (u|uret)probe? (e.g getaddrinfo): What should we answer?\nWe\u0026rsquo;ve already seen this: we can use the bpftrace command, for example:\nbpftrace -l \\ \u0026#39;uprobe:./pi_digits_pure_rust:*pi_times*\u0026#39; We then find:\nuprobe:./pi_digits_pure_rust:pi_times_10n_rounded The function is therefore pi_times_10n_rounded.\nTips # If you pay close attention, in the second part, we saw that, by default, the Go compiler:\ninlines functions, so we couldn\u0026rsquo;t see them We had to add the -l compilation option to prevent this modifies the function name (mangle) We had to add the -N compilation option to prevent this Let\u0026rsquo;s recall what an inline is (here with the Go compiler) using a diagram:\nRust also does this by default. But I didn\u0026rsquo;t do it at the global level, but for the function in particular.\nSo I had to add two attributes in the code before the target function:\n#[no_mangle] #[inline(never)] pub fn pi_times_10n_rounded(n: usize) -\u0026gt; num_bigint::BigInt { //[...] } #[no_mangle]: do not modify the function name #[inline(never)]: never inline the function Now that we have defined the attachment point, we can start creating our two eBPF programs.\nLet\u0026rsquo;s retrieve the launch time of eBPF programs # Let\u0026rsquo;s start simple by creating the two eBPF programs and just retrieving their launch time.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e Continued reading reserved for premium members ‚ú®\nThe full article is only available to premium members.\nBecoming a premium member is easy: just make a small donation üíñ\nIn exchange, you will receive for 1 year (early bird offer):\nAccess to all full articles as soon as they are published Early reading before public release Participation in supporting this independent blog Exclusive access to my vacation photos in Dubai Your donation will help:\nMake me less dependent on large platforms Encourage me to create more technical content Lift the paywall more quickly for everyone üëâ Become a premium member now\n","date":"23 September 2025","externalUrl":null,"permalink":"/en/ebpf-another-type/uprobe/example-3-tr/","section":"Ebpf-Another-Types","summary":"Let‚Äôs profile a small program with eBPF uProbes and uRetProbes in Aya","title":"Let‚Äôs Profile a Small Program Using eBPF uProbes","type":"ebpf-another-type"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/en/tags/uprobe/","section":"Tags","summary":"","title":"Uprobe","type":"tags"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/en/tags/uretprobe/","section":"Tags","summary":"","title":"Uretprobe","type":"tags"},{"content":"We saw what a uProbe-type program was in part one: a way to probe a library.\nWe will verify this with an Aya program that will retrieve the various arguments of the execve() function from Libc.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rI assume you are already in an environment for developing with Aya and that you have installed bpftrace. If not, you can use the Killercoda lab:\nWhat are we really going to do? # Libc # Unlike in the previous section, where we attached our eBPF program to a program, here we are attaching it to a shared library.\nLibc is the standard C library. So every time a C (or C++) program is executed, an eBPF program could potentially be launched.\n\u003c?xml version=\"1.0\" encoding=\"iso-8859-1\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rI refer to libc throughout this chapter. To be more precise, we should refer to glibc (GNU C Library), the most widely used implementation in GNU/Linux distributions (such as Debian or Red Hat). But there are other implementations such as musl (notably for Alpine Linux) or ulibc, which are lighter and more suited to embedded systems. The execve function # execve is a system call (a syscall) from the Linux kernel. But it is also the name of a function in libc that calls this same syscall (a wrapper). Thus, each time the execve() function of libc is called, our uProbe-type eBPF program will be launched.\nThe arguments of the execve function # We also need to retrieve the various arguments of the execve() function.\nTo find its arguments, we could obviously look in the libc source code. But there is an easier way:\nman execve The part that interests us is the following:\nint execve(const char *pathname, char *const _Nullable argv[], char *const _Nullable envp[]); We can see that the function has three arguments:\npathname: the name of the command with the full path (e.g., /bin/bash). It is of type const char * (equivalent in Rust to *const u8). argv: an array of command arguments. It is of type char *const _Nullable[] (equivalent in Rust to *const *const u8) argv[0]: the name of the command argv[1]: the first option etc. envp: an array of command environment variables. It is of type char *const _Nullable[] (equivalent in Rust to *const *const u8). \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e _Nullable simply indicates that the value can be NULL. How to trigger the eBPF program? # Let\u0026rsquo;s take a simple example. If you run a command in a terminal, for example ls, what will happen?\nThanks to the PATH environment variable, the shell (for example bash) will find the right path to locate the ls binary: /usr/bin/ls To execute the binary, the shell will then call the execve() function from libc: execve(\u0026#34;/usr/bin/ls\u0026#34;, [\u0026#39;ls\u0026#39;], [\u0026#34;PATH=/bin:/usr/bin\u0026#34;, ...]) The eBPF program will finally be triggered. Here is a brief summary of all this:\nThere are obviously other programs besides shells that call the execve() function in libc, such as systemd for starting various programs on a Linux system.\nSo we are going to create a program very similar to the one we created with the sys_enter_execve tracepoint in the introductory articles on eBPF, but this one will be attached at the user level to the execve() function of libc.\nLet\u0026rsquo;s generate an uProbe-type Aya program # So we already have the answers to both questions:\nü§∑ Target to attach the (u|uret)probe? (e.g libc): ü§∑ Function name to attach the (u|uret)probe? (e.g getaddrinfo): Let\u0026rsquo;s see how to create an eBPF hello world program for this attachment point.\nLet\u0026rsquo;s test it with bpftrace # First, let\u0026rsquo;s check that it works with the bpftrace command line:\nsudo bpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;Hello execve\\n\u0026#34;); }\u0026#39; uprobe: the type of eBPF program libc: the name of the library execve: the function to debug { printf(\u0026quot;Hello execve\\n\u0026quot;); }: the bpftrace code Each time we run a command on another terminal, we see Hello execve.\nNow let\u0026rsquo;s do it with Aya.\nGenerating and compiling the Aya program # The following cargo generate command generates the eBPF program:\ncargo generate --name test-uprobe-2 \\ -d program_type=uprobe \\ -d uprobe_target=libc \\ -d uprobe_fn_name=execve \\ https://github.com/aya-rs/aya-template \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rTo find the names of the arguments (uprobe_target and uprobe_fn_name), you can look at the test.sh in the aya-template repo. Now let\u0026rsquo;s compile it and install it in the Linux kernel:\ncd test-uprobe-2/ RUST_LOG=info cargo run Testing the program # On another terminal, launch any program:\nls On the cargo run terminal, you will see:\n[INFO test_uprobe] function execve called by libc In the previous section, we left off at this point regarding uProbes. Let\u0026rsquo;s look at how to retrieve the various arguments of the execve() function. Let\u0026rsquo;s start with the first one: the name of the binary.\nLet\u0026rsquo;s retrieve the name of the binary # Let\u0026rsquo;s test with bpftrace # Before modifying the Aya code, let\u0026rsquo;s see how to do it with bpftrace. It\u0026rsquo;s a bit more complicated than a simple hello world.\nTo retrieve the first argument, we use arg0:\nsudo bpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;%d\\n\u0026#34;, arg0); }\u0026#39; We retrieve the address where the first argument is located. How do we \u0026ldquo;convert\u0026rdquo; it to a string? Just use the str() function:\nsudo bpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;%s\\n\u0026#34;, str(arg0)); }\u0026#39; Now that we have the draft with bpftrace, let\u0026rsquo;s see how to implement it with Aya.\nLet\u0026rsquo;s modify the Aya code # We need to modify the following function in the test-uprobe-2-ebpf/src/main.rs file:\nfn try_test_uprobe_2(ctx: ProbeContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { info!(\u0026amp;ctx, \u0026#34;function execve called by libc\u0026#34;); Ok(0) } We therefore need to manipulate the ctx variable. Here is the documentation:\nThere is only one method that interests us:\nThe first element is the name of the binary that is executed.\nSo we need to add something like this:\nlet arg0: *const u8 = ctx.arg(0).ok_or(1u32)?; \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rWe use the type *const u8 because the first argument is of type const char * in C (see man execve) To \u0026ldquo;convert\u0026rdquo; this pointer into a character string, we will do it in a similar way to how we did with Tracepoints in the introductory article on creating eBPF programs with Aya.\nThis gives us the following code:\nfn try_test_uprobe_2(ctx: ProbeContext) -\u0026gt; Result\u0026lt;u32, i64\u0026gt; { let arg0: *const u8 = ctx.arg(0).ok_or(1u32)?; let mut buf = [0u8; 128]; let filename = unsafe { let filename_bytes = bpf_probe_read_user_str_bytes(arg0, \u0026amp;mut buf)?; from_utf8_unchecked(filename_bytes) }; info!(\u0026amp;ctx, \u0026#34;function execve called by libc {}\u0026#34;, filename); Ok(0) } At the time, it wasn\u0026rsquo;t very clear in my mind.\nLet\u0026rsquo;s explain this code in detail:\nThe helper function bpf_probe_read_user_str_bytes() allows you to read the memory address from user space and retrieve its contents with a slice of bytes. You need a buffer for this. from_utf8_unchecked() converts a slice of bytes into an \u0026amp;str (without unchecked, otherwise the eBPF verifier will not accept it). Finally, here is a small diagram explaining how to retrieve a character string from user space:\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e Note the name of the function bpf_probe_read_user_str_bytes, which makes perfect sense for a uProbe. Now let\u0026rsquo;s test the change. # Let\u0026rsquo;s check that the code still works:\nRUST_LOG=info cargo run On another terminal, let\u0026rsquo;s run any command:\nls On the cargo run terminal, you will see:\n[INFO test_uprobe_2] function execve called by libc /usr/bin/ls We left off at this point in the introductory articles on eBPF with Aya. But we could have gone further by retrieving the command options and its environment variables. Let\u0026rsquo;s see how to do that.\nLet\u0026rsquo;s retrieve the command options # Let\u0026rsquo;s test with bpftrace # Before doing this with Aya, we\u0026rsquo;ll look at how to do it with bpftrace. To retrieve the second argument, we must use arg1. Since arg1 is a pointer to a pointer, we cannot use the str() function directly. We must dereference arg1 to obtain a single pointer. To do this, simply use *.\nThis gives us:\nbpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;%s\\n\u0026#34;, str(*arg1)); }\u0026#39; We then retrieve the first element of the array, which is the name of the command. We therefore need to move through the array if we want to retrieve the different options. Each element is 8 bytes in size (only valid in 64-bit).\nTo go to the second element of the array, i.e., the first option, simply move 8 bytes (by adding 8):\nbpftrace -e \\ \u0026#39;uprobe:libc:execve { printf(\u0026#34;%s\\n\u0026#34;, str(*(arg1+8))); }\u0026#39; You will see that the difficulty will be much the same in Rust.\nLet\u0026rsquo;s modify the Aya code # With Aya, to retrieve the second argument, you need to add this piece of code:\nlet argv: *const *const u8 = ctx.arg(1).ok_or(1u32)?; How do we retrieve the nth option of the command? We need to use the add function to shift its pointer to the correct memory address:\nFor example, to retrieve the first option, we will shift by 1:\nlet argv1 = argv.add(1); \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rUnlike bpftrace, where you have to shift by the number of bytes (8 in 64 bits because 8x8=64 bits). The add() function allows you to move from memory address 1 by 1 without taking the architecture into account. However, argv1 is still of type *const *const u8. You now need to dereference it to obtain *const u8.\nThere is a ready-made function for this:\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e The helper function bpf_probe_read_user allows you to read the content stored in the pointer from user space and return a copy of its value. So we have:\nlet argv1_deref: *const u8 = bpf_probe_read_user(argv1)?; Now that argv1_deref is of type *const u8, we need to convert it to \u0026amp;str. This gives us code similar to that used to retrieve the name of the binary. It would probably be useful to create a function for a \u0026ldquo;serious\u0026rdquo; project.\nHere is the complete code for retrieving the first option:\nlet argv: *const *const u8 = ctx.arg(1).ok_or(0u32)?; //arg1 let mut buf = [0u8; 16]; let argname = unsafe { let argv1 = argv.add(1); //arg1+8 let argv1_deref: *const u8 = bpf_probe_read_user(argv1)?; //*(arg1+8) let argname_bytes = bpf_probe_read_user_str_bytes(argv1_deref, \u0026amp;mut buf)?; from_utf8_unchecked(argname_bytes) //str(*(arg1+8)) }; info!(\u0026amp;ctx, \u0026#34;function execve called by libc {}\u0026#34;, argname); //printf(\u0026#34;%s\\n\u0026#34;, str(*(arg1+8))); \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e I have included the equivalent code with bpftrace as a comment. Now let\u0026rsquo;s test the change. # Let\u0026rsquo;s check that the code still works:\nRUST_LOG=info cargo run On another terminal, let\u0026rsquo;s run a command with an option:\nls -lrt On the cargo run terminal, you will see:\n[INFO test_uprobe_2] function execve called by libc /usr/bin/ls [INFO test_uprobe_2] function execve called by libc -lrt This is the behavior we wanted.\nWhat happens if we run a command without an option?\nman On the cargo run terminal, you will only see:\n[INFO test_uprobe_2] function execve called by libc /usr/bin/man What happened?\nThis part of the code was not displayed:\ninfo!(\u0026amp;ctx, \u0026#34;function execve called by libc {}\u0026#34;, argname); Since the command has no arguments, this part of the code threw an error:\nlet argname = unsafe { let argv1 = argv.add(1); //arg1+8 let argv1_deref: *const u8 = bpf_probe_read_user(argv1)?; //*(arg1+8) let argname_bytes = bpf_probe_read_user_str_bytes(argv1_deref, \u0026amp;mut buf)?; from_utf8_unchecked(argname_bytes) //str(*(arg1+8)) }; And so the program crashed and never processed the last info.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rRetrieving environment variables from the command is very similar, since it is the same type as for arguments. This episode is now over! We have seen how to retrieve the arguments of a function in a C program, particularly for character strings and character string arrays, and how to display them.\nIn the next episode, we will see how to profile a program function.\n","date":"23 September 2025","externalUrl":null,"permalink":"/en/ebpf-another-type/uprobe/example-2/","section":"Ebpf-Another-Types","summary":"Let‚Äôs probe the function \u003ccode\u003eexecve\u003c/code\u003e in libc using eBPF uProbe with Aya","title":"Let‚Äôs Probe a Library with an eBPF uProbe","type":"ebpf-another-type"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/en/tags/go/","section":"Tags","summary":"","title":"Go","type":"tags"},{"content":"We saw what a uProbe-type program was in part one: a way to probe the functions of your programs.\nIn this part, we will first create a very simple program in Go and make it interact with two eBPF programs:\nThe first is a uProbe type The second is a uRetProbe type \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rI assume you are already in an environment for developing with Aya and that you have installed the go compiler and bpftrace. If not, you can use the Killercoda lab:\nLet\u0026rsquo;s create a program to test the uProbes # A very simple code # For a change from Rust, we\u0026rsquo;re going to create a small program in Go:\n// hello.go package main import \u0026#34;fmt\u0026#34; func hello() int { fmt.Println(\u0026#34;Hello, world!\u0026#34;) return 3 } func main() { ret := hello() fmt.Println(\u0026#34;Returned:\u0026#34;, ret) } \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rYou can test another compiled program such as C/C++ or Rust if you prefer. How do we activate uProbes? # The purpose of this article is to activate:\nan eBPF program of type uProbe each time we enter the hello() function: an eBPF program of type uRetProbe each time we exit the hello() function: Now that we have seen the ins and outs of the article, let\u0026rsquo;s move on to compiling the program.\nLet\u0026rsquo;s compile the program # To compile it, just type:\ngo build -gcflags=\u0026#34;all=-N -l\u0026#34; -o hello hello.go You may notice that we added an option -gcflags=\u0026quot;all=-N -l\u0026quot;. Normally, you don\u0026rsquo;t need to use this option to compile a Go program:\ngo build -o hello hello.go This also works. So why use this option?\n-gcflags means go compiler flags; these are options passed to the Go compiler. all means that the options apply to all compiled packages. The options specified to the Go compiler are:\n-N: by default, the compiler modifies (mangles) the function name. This option disables this modification. In English, to mangle means to modify, mutilate, or even disfigure. -l: by default, the compiler inlines functions, i.e., it directly integrates the content of the function into the calling code, thus allowing programs to perform better. This option allows you to disable this inline. These options will allow us to keep the functions and make them readable, which will make it easier for us to find the attachment point for our eBPF program.\nHow to find the attachment point? # Now that we have created and compiled the small program, we need to figure out how to trigger the uProbe or uRetProbe type eBPF program. When using cargo generate for the aya repo, we need to answer two questions: where is the binary name and which function is being observed. Let\u0026rsquo;s take a closer look.\nName of the binary # ü§∑ Target to attach the (u|uret)probe? (e.g libc): To ensure the portability of the eBPF program, you must answer with the absolute path of the binary. For example, I created it here: /home/cloud_user/hello.\nFunction name # Once you have answered the first question, there is a second question:\nü§∑ Function name to attach the (u|uret)probe? (e.g getaddrinfo): What should you answer? You might be tempted to answer hello since you set the -N option, which disables name decoration during compilation.\nBut it\u0026rsquo;s a little more complicated than that. The Go compiler still slightly modifies the function name during the compilation stage.\nAs we saw in the previous episode, to find all the functions in a binary, just use bpftrace:\nbpftrace -l \u0026#39;uprobe:/home/cloud_user/hello:*\u0026#39; The -l option lists all available probes uprobe: the type of eBPF program /home/cloud_user/hello: the location of the binary *: the wildcard (0 or more characters) The display format is then:\nuprobe:/home/cloud_user/hello:[function1] uprobe:/home/cloud_user/hello:[function2] uprobe:/home/cloud_user/hello:[function3] uprobe:/home/cloud_user/hello:[function4] etc That\u0026rsquo;s unfortunate: the function name is the same as my file name\u0026hellip; We can\u0026rsquo;t do | grep hello. How can we get around this? With awk, cut, or worse, a regex? Let\u0026rsquo;s keep it simple:\nbpftrace -l \u0026#39;uprobe:/home/cloud_user/hello:*hello*\u0026#39; And it will respond with:\nuprobe:/home/cloud_user/hello:main.hello So the real name of the function is main.hello\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e If you can\u0026rsquo;t install bpftrace, you can use the nm command. It allows you to see all the symbols that are present in a binary file. Now that we have the answers to both questions, we can create our eBPF programs.\nLet\u0026rsquo;s start with the uProbe-type program.\nLet\u0026rsquo;s create an eBPF uProbe program # Let\u0026rsquo;s test with bpftrace # Before diving headfirst into an Aya program, let\u0026rsquo;s check that it works properly with bpftrace, the program that creates an eBPF program from a command line. That\u0026rsquo;s good timing: we already found the beginning in the previous section:\nuprobe:/home/cloud_user/hello:main.hello All that\u0026rsquo;s left to do is add a hello world:\nsudo bpftrace -e \\ \u0026#39;uprobe:/home/cloud_user/hello:main.hello { printf(\u0026#34;Hello go\\n\u0026#34;); }\u0026#39; Historically, you needed root privileges to install an eBPF program in the kernel. With modern Linux, a non-root user can install an eBPF program with just a few additional capabilities such as CAP_BPF. However, bpftrace does not support this: you must be root. In another terminal, let\u0026rsquo;s launch the hello program (without root privileges):\n./hello On the terminal where bpftrace is running, you will see Hello go each time you launch the hello program.\nLet\u0026rsquo;s check that we can create a similar program with Aya.\nGenerating the Aya program # Let\u0026rsquo;s define the different responses for the attachment point in variables. In my case, it will be:\ntarget=/home/cloud_user/hello fn_name=main.hello Now let\u0026rsquo;s run the command to generate the Aya program:\ncargo generate --name test-uprobe \\ -d program_type=uprobe \\ -d uprobe_target=$target \\ -d uprobe_fn_name=$fn_name \\ https://github.com/aya-rs/aya-template Without the options we specified, cargo generate would run in interactive mode: we would have to answer questions.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rTo find the names of the arguments (uprobe_target and uprobe_fn_name), you can look at the test.sh in the aya-template repo. You will get the following output:\nüîß program_type: \u0026#34;uprobe\u0026#34; (value from CLI) üîß uprobe_target: \u0026#34;/home/cloud_user/hello\u0026#34; (value from CLI) üîß uprobe_fn_name: \u0026#34;main.hello\u0026#34; (value from CLI) üîß Destination: /home/cloud_user/test-uprobe ... üîß project-name: test-uprobe ... üîß Generating template ... [ 1/23] Done: .gitignore [ 2/23] Done: Cargo.toml [ 3/23] Done: LICENSE-APACHE [ 4/23] Done: LICENSE-GPL2 [ 5/23] Done: LICENSE-MIT [ 6/23] Done: README.md [ 7/23] Ignored: pre-script.rhai [ 8/23] Done: rustfmt.toml [ 9/23] Done: test-uprobe/Cargo.toml [10/23] Done: test-uprobe/build.rs [11/23] Done: test-uprobe/src/main.rs [12/23] Done: test-uprobe/src [13/23] Done: test-uprobe [14/23] Done: test-uprobe-common/Cargo.toml [15/23] Done: test-uprobe-common/src/lib.rs [16/23] Done: test-uprobe-common/src [17/23] Done: test-uprobe-common [18/23] Done: test-uprobe-ebpf/Cargo.toml [19/23] Done: test-uprobe-ebpf/build.rs [20/23] Done: test-uprobe-ebpf/src/lib.rs [21/23] Done: test-uprobe-ebpf/src/main.rs [22/23] Done: test-uprobe-ebpf/src [23/23] Done: test-uprobe-ebpf üîß Initializing a fresh Git repository ‚ú® Done! New project created /home/cloud_user/test-uprobe Compilation and installation in the kernel # Now that we have generated the program, we need to compile it and install it in the Linux kernel:\ncd test-uprobe/ RUST_LOG=info cargo run For simplicity, I compiled and installed the eBPF program as root. This will take a little time the first time:\nUpdating crates.io index Locking 103 packages to latest compatible versions Adding which v6.0.3 (available: v8.0.0) Downloaded anstyle v1.0.11 Downloaded cfg-if v1.0.1 Downloaded anyhow v1.0.98 Downloaded either v1.15.0 Downloaded cargo_metadata v0.19.2 Downloaded version_check v0.9.5 Downloaded which v6.0.3 Downloaded socket2 v0.6.0 Downloaded mio v1.0.4 [...] warning: test-uprobe@0.1.0: Finished `release` profile [optimized] target(s) in 19.59s Finished `dev` profile [unoptimized + debuginfo] target(s) in 50.16s Running `/root/build-cache/debug/test-uprobe` Waiting for Ctrl-C... Let\u0026rsquo;s test it now # Leave the Aya program running and, on another terminal, launch the program you want to examine. In my case:\n./hello On the terminal where you launched the cargo run command, you should see the following output each time you launch the program:\n[INFO test_uprobe] function main.hello called by /home/cloud_user/hello You can see that the difficulty is the same as with bpftrace, but the compilation time is much longer.\nLet‚Äôs create an eBPF uRetProbe program # We saw an example of a uProbe-type eBPF program where we didn\u0026rsquo;t have to modify the generated code. Now we\u0026rsquo;re going to make things a little more complex with a uRetProbe-type eBPF program and retrieve the return value.\nLet\u0026rsquo;s test with bpftrace # The bpftrace code is then slightly modified:\nsudo bpftrace -e \\ \u0026#39;uretprobe:/home/cloud_user/hello:main.hello { printf(\u0026#34;retval=%d\\n\u0026#34;, retval); }\u0026#39; uprobe is replaced by uretprobe The return variable has been added: retval Run the hello program in another terminal and you will see in the bpftrace terminal:\nretval=3 Let\u0026rsquo;s see how to produce the equivalent program in Aya.\nGenerating the Aya program # The code is generated in a similar way to uProbe:\ntarget=/home/cloud_user/hello fn_name=main.hello cargo generate --name test-uretprobe \\ -d program_type=uretprobe \\ -d uprobe_target=$target \\ -d uprobe_fn_name=$fn_name \\ https://github.com/aya-rs/aya-template Compilation and installation # In the same way, we will compile and install the eBPF program:\ncd test-uretprobe/ RUST_LOG=info cargo run At the end of each hello() function, the eBPF program displays:\n[INFO test_uretprobe] function main.hello called by /home/cloud_user/hello So far, we have done pretty much the same thing as for uProbe. Now let\u0026rsquo;s see how to retrieve the return value 3.\nModifying the code # We need to modify the file test-uretprobe-ebpf/src/main.rs: the kernel space code. Specifically, this piece of code:\nfn try_test_uretprobe(ctx: RetProbeContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { info!(\u0026amp;ctx, \u0026#34;function main.hello called by /home/cloud_user/hello\u0026#34;); Ok(0) } We need to see how to use the RetProbeContext structure to display the return code.\nLet\u0026rsquo;s look at the documentation:\nSo we need to use the ret() method. We\u0026rsquo;ll add something like this:\nlet retval: u32 = ctx.ret().ok_or(1u32)?; \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e If the function has no return value, we display 1u32 (32-bit unsigned integer) because the function signature is Result\u0026lt;u32, u32\u0026gt;. We also need to modify the Aya macro info! to display this value.\nThis gives us the following result:\nfn try_test_uretprobe(ctx: RetProbeContext) -\u0026gt; Result\u0026lt;u32, u32\u0026gt; { let retval: u32 = ctx.ret().ok_or(1u32)?; info!(\u0026amp;ctx, \u0026#34;retval={}\u0026#34;, retval); Ok(0) } Let\u0026rsquo;s test it now. # Apply the changes:\nRUST_LOG=info cargo run Run the hello command in another terminal:\n./hello And on the Aya program side, we get the following display:\n[INFO test_uretprobe] retval=3 This is consistent with what we found with bpftrace.\nThis episode is now complete! We\u0026rsquo;ve seen the basics of making an uProbe and uRetProbe eBPF program react when launching a Go program.\nHowever, we haven\u0026rsquo;t yet explored how to retrieve the arguments of a function.\nThat\u0026rsquo;s perfect timing! In the next episode, we\u0026rsquo;ll probe a well-known library by retrieving function arguments and processing them!\n","date":"15 September 2025","externalUrl":null,"permalink":"/en/ebpf-another-type/uprobe/example-1/","section":"Ebpf-Another-Types","summary":"Let‚Äôs observe a small Go program using uProbes and uRetProbes with Aya","title":"Let‚Äôs Observe a Simple Function in Your Program with uProbes","type":"ebpf-another-type"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/tags/bpftrace/","section":"Tags","summary":"","title":"Bpftrace","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/tags/kprobe/","section":"Tags","summary":"","title":"Kprobe","type":"tags"},{"content":"I\u0026rsquo;m getting started with eBPF programming with Aya. The idea behind this series of articles is to learn about a new type of eBPF program and experiment with it using the Rust Aya framework.\nToday, we\u0026rsquo;re going to dive into uProbes and uRetProbes: eBPF programs that probe user space functions without leaving a trace.\nYou\u0026rsquo;ll see that this can be very useful for profiling, debugging, or even reverse engineering.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e If you\u0026rsquo;re not familiar with eBPF, I recommend reading the first two parts of my series Getting Started with eBPF with Aya. This covers the basics and will help you understand the rest of the article. What is a u‚Ä¢Ret‚Ä¢Probe? # In English, a probe can be defined as a device used to examine or explore something. In eBPF, there are several types: kProbe, kRetProbe, uProbe, uRetProbe, and USDT.\nkProbe: the probe for the kernel # If you consult the eBPF documentation, there is no section dedicated to uProbe or uRetProbe type programs. But there is one dedicated to kProbe:\nThe purpose of kProbe is to observe Linux kernel functions. It can be considered the parent probe. All other probes are in fact the same type of program BPF_PROG_TYPE_KPROBE, but it is just the attachment point that determines how the program is executed.\nkRetProbe: feedback on the kernel probe # The kRetProbe is simply dedicated to observing the return of Linux kernel functions. This probe allows you to check whether the function call has completed successfully.\nWe have briefly looked at kProbe and kRetProbe, which could be the subject of other articles. Let\u0026rsquo;s now talk about the probes that interest us today: uProbe and uRetProbe.\nuProbe: the probe for users # Unlike kProbes, which are dedicated to observing Linux kernel functions, uProbes are dedicated to user space functions: User-space Probes. For example, they could be used to count the number of calls to the malloc and free functions in a C program.\nuProbe also allows you to retrieve the content of the arguments of the observed function. This means you could look at the amount of memory allocated to each malloc or check that free is actually freeing the right pointers.\nuProbes could therefore be integrated into a CI to automate security checks, facilitate debugging, or assist with memory diagnostics.\n\u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rFree Medical icons\rIt may seem paradoxical to want to trace user code from kernel space. However, this has the advantage of being non-intrusive, as there is no need to modify the program. uRetProbe: user probe return # Like kRetProbe, uRetProbe is designed to study the return of the target function in user space: User-space Return Probe. This allows us to discover the value returned by the function. This makes it possible to debug or observe the final behavior of the function.\nBut there is another benefit: by combining the times from uProbe and uRetProbe, we can easily retrieve the time it takes for a function to execute. This makes it possible to profile a function in your program.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e file_type_sql For example, you could use it for SQL queries to identify the longest queries. uRetProbes and uProbes can be used to debug and understand a program for which you do not have the source code. This can be a useful reverse engineering tool.\nHowever, they are limited to programs written in compiled languages: C/C++, Rust, Go, etc. If you have a program developed in another language, USDT might be a good fit for you. Let\u0026rsquo;s talk about it.\nUSDT: the user space tracepoint # USDT stands for User Statically-Defined Tracing. As its name suggests, it is also dedicated to user space programs, but usdt probes must be added to the code in order to use them. USDT is, in fact, derived from uProbe.\nHowever, it is much more accurate than uProbe. The uProbe is confined to the beginning of the function, while the usdt probe can be placed anywhere in the code.\nHere is an example of Python code:\ndef benchmark_module(): loop = 0 for _ in range(100000): pyusdt.trace_start_loop(loop) calculate_pi(1000) pyusdt.trace_stop_loop(loop) loop += 1 With this code, we can get the time it takes to calculate the first 1000 decimal places of œÄ.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rAt the time of writing, the Aya framework does not yet support USDT-type programs. We will now focus on uProbes and uRetProbes for the rest of this article. Let\u0026rsquo;s first talk a little about their history.\nOrigin story # uTrace, the predecessor # The desire to trace user space functions from the Linux kernel did not begin with the introduction of eBPF. For example, a (first?) attempt appeared in 2007 with uTraces:\nHowever, they were never included in the main code due to opposition from certain maintainers.\nHabemus uProbe # It wasn\u0026rsquo;t until 2012 that consensus was finally reached, and uProbes were introduced in version 3.5 of the Linux kernel:\nAt the time, uProbes were limited compared to what we know today.\nThey were then improved with version 3.14 (released in 2014, the same year that eBPF was introduced):\nThis patch made it possible to retrieve a greater amount of data, such as the return value of a function.\nuProbes then became fully usable even though eBPF had not yet been released. Let\u0026rsquo;s see when it was integrated.\nuProbe with eBPF # In the kProbe eBPF documentation, kProbe appeared in 2015 in version 4.1. Alexei Starovoitov, one of eBPF\u0026rsquo;s creators, was the one who initiated it:\nSince a uProbe is a kProbe with a different attachment point, we were able to start developing uProbes with eBPF as of April 2, 2015.\nHowever, we still had to wait for the eBPF frameworks of the time to be able to handle it.\nSo we could already use it in 2016 with BCC as evidenced by Brendan Gregg\u0026rsquo;s tutorial:\nYou can also see his GitHub issue from October 2015: Finally, here is a brief timeline of the history of uProbes:\n\u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\rFree Medical icons\ruRetProbes were introduced at the same time as uProbes. Now that uProbe has been around for over 10 years, it\u0026rsquo;s fair to ask: is it still being used, and if so, by which projects?\nWhich projects use u‚Ä¢Ret‚Ä¢Probe? # To challenge the common misconception that \u0026ldquo;eBPF is only used by three big companies\u0026rdquo;, I did a little research on tools that actually use uProbes, which means you may be using them without even knowing it\u0026hellip;\nPixie: Where is my mind? # The Pixie project uses uProbe in particular to trace TLS connections:\nThere is also an article by Douglas Mendez on capturing HTTPs traffic with Aya.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rThe Pixie Project is an observability tool for applications running on Kubernetes. Parca: Winter is coming! # The Parca project also uses uProbes.\nThe Parca project is a \u0026ldquo;continuous\u0026rdquo; profiling tool, i.e., it profiles systematically. Inspektor Gadget: I\u0026rsquo;m always on duty! # The Inspektor Gadget project has been creating tools based on uProbes and USDT probes since 2024:\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\rThe Inspektor Gadget project provides tools (gadgets) and a framework for collecting data and inspecting the system on Kubernetes. Bonus Track # To conclude this presentation, I would like to share some interesting links that I found while researching uProbes:\nUsing uProbes without eBPF by Brendan Gregg in 2015: Julia Evans\u0026rsquo; excellent blog post on all tracing systems on Linux. You can also read her zine: If uProbes aren\u0026rsquo;t right for you, you might be interested in Eunomia\u0026rsquo;s bpftimes: Now that we\u0026rsquo;ve introduced uProbe and uRetProbe, let\u0026rsquo;s see how to get started with development using Aya.\nHow to start your Aya program? # When you start developing a new eBPF program, the first challenge is getting it to start. To do this, it needs an event-driven trigger. In this episode, this event will be the passage of a uProbe or uRetProbe in the Linux kernel.\nAya makes this task easier. When you run the command:\ncargo generate https://github.com/aya-rs/aya-template You will need to answer two important questions that will help define this event:\nü§∑ Target to attach the (u|uret)probe? (e.g libc): ü§∑ Function name to attach the (u|uret)probe? (e.g getaddrinfo): Let\u0026rsquo;s see how to answer them.\nTarget for attaching the u‚Ä¢Ret‚Ä¢Probe # The first question asks for the name of a library (such as libc) or a binary. The question could have been phrased differently: which file do you want to debug or trace?\nThink of it as a filter:\nIf you choose libc, the eBPF program will only start if a program from libc is running. If you choose a binary, it will only start if the binary is running. But this is not enough to start the eBPF program. You need to be more specific: give the name of a function.\nName of the function to attach the u‚Ä¢Ret‚Ä¢Probe # The second question asks for the function of the binary or library you want to debug.\nFor example:\nIf you choose the name of a function from a C program, the eBPF program will be launched each time it passes through this function. If you choose a function from libc, it will only be launched when a program calls this function from libc. If this seems a little too theoretical, we will finish the chapter by talking about a very useful tool that will allow us to illustrate this.\nGetting started with eBPF using bpftrace # The bpftrace project allows you to quickly create most types of eBPF programs dedicated to tracing, including uProbe and uRetProbe, as well as USDT, kProbe, and kRetProbe (see support here).\nFeel free to install it; it is probably packaged for your favorite Linux distribution.\nThe project was heavily inspired by DTrace, a tracing tool originally created for Unix systems such as Solaris, FreeBSD, and NetBSD in the early 2000s. Enough talk, let\u0026rsquo;s look at an example:\nsudo bpftrace -e \\ \u0026#39;uretprobe:/bin/bash:readline { printf(\u0026#34;%s\\n\u0026#34;, str(retval)); }\u0026#39; What does this mean?\nuretprobe: the type of eBPF program /bin/bash: the target binary readline: the name of the function { printf(\u0026quot;%s\\n\u0026quot;, str(retval)); }: the bpftrace program code (it displays the return value of the function) This command creates an eBPF program of type uRetProbe with the readline function of the bash binary as its attachment point.\nIf you have actually run the command, you will see that this creation is almost immediate! Let\u0026rsquo;s check that it works properly.\nStart another terminal and run a few commands of your choice. Here is an example of what you will see on the bpftrace terminal:\nAttaching 1 probe... ls -lrth hello man woman You can see all the commands you typed on the terminal!\nbpftrace can therefore be a good way to prototype a uProbe or uRetProbe program before generating it with Aya.\nWhat if I want to observe a function other than readline in the bash program? How do I do that? The first instinct would be to go into the bash code and look for another function, but there is an easier and safer way:\nbpftrace -l \u0026#39;uretprobe:/bin/bash:*\u0026#39; This command will list all the functions available in bash.\nWe can see that we can debug 1670 functions in bash: bpftrace -l 'uretprobe:/bin/bash:*' | wc -l Bpftrace will allow us to verify feasibility before creating the program in Rust with Aya.\nIn this episode, we looked at the basics of uProbes and uRetProbes: what they are used for, their history, who uses them, and how to find the right hook. We also looked at bpftrace, a tool that allows you to create probes quickly.\nNow let\u0026rsquo;s move on to the practical stuff. In the next episode, we\u0026rsquo;ll create a small Go program and make it interact with uProbe and uRetProbe eBPF programs using Aya.\n","date":"8 September 2025","externalUrl":null,"permalink":"/en/ebpf-another-type/uprobe/intro/","section":"Ebpf-Another-Types","summary":"An introduction to eBPF uProbes and uRetProbes with Aya","title":"Observability for All Developers with uProbes","type":"ebpf-another-type"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/en/tags/usdt/","section":"Tags","summary":"","title":"Usdt","type":"tags"},{"content":"","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"}]